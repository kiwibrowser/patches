From d8251eb3e39890acd01fd7619382a3f47ed81160 Mon Sep 17 00:00:00 2001
From: Arnaud GRANAL <arnaud@geometry.ee>
Date: Wed, 22 Jan 2020 21:50:54 +0000
Subject: [PATCH] [Kiwi] Introduce extensions support - R80

---
 BUILD.gn                                      |   2 +-
 DEPS                                          |   2 +-
 apps/BUILD.gn                                 |   2 +-
 build/config/compiler/compiler.gni            |   6 +-
 chrome/BUILD.gn                               |   4 +-
 .../android/chrome_main_delegate_android.cc   |   7 +
 chrome/app/bookmarks_strings.grdp             |   6 +-
 chrome/app/chrome_main_delegate.cc            |  13 +
 chrome/app/chromium_strings.grd               |  20 +-
 chrome/app/generated_resources.grd            |  77 +-
 chrome/app/google_chrome_strings.grd          |  20 +-
 chrome/app/profiles_strings.grdp              |  11 +-
 chrome/app/theme/theme_resources.grd          |  28 +-
 chrome/browser/BUILD.gn                       |  41 +-
 chrome/browser/apps/platform_apps/BUILD.gn    |   1 -
 .../api/music_manager_private/BUILD.gn        |   1 +
 .../device_id_android.cc                      | 188 ++++
 .../background_contents_service_factory.cc    |   3 +
 .../background/background_mode_manager.cc     |   1 -
 .../background_mode_manager_android.cc        |  24 +
 chrome/browser/browser_process_impl.cc        |   4 +
 chrome/browser/browser_resources.grd          |  29 +-
 chrome/browser/chrome_browser_main.cc         |  22 +
 chrome/browser/chrome_browser_main_android.cc |   2 +
 chrome/browser/chrome_browser_main_posix.cc   |   2 +-
 .../browser/chrome_content_browser_client.cc  |   9 +-
 .../cookie_settings_factory.cc                |   1 +
 .../host_content_settings_map_factory.cc      |   4 +-
 ...ter_protocol_handler_permission_request.cc |  28 +-
 ...ster_protocol_handler_permission_request.h |   2 +
 chrome/browser/devtools/BUILD.gn              |  10 +-
 chrome/browser/download/download_commands.cc  |  17 +-
 chrome/browser/download/download_commands.h   |   4 +-
 .../download/download_crx_util_android.cc     |  23 -
 .../download/download_danger_prompt.cc        |   5 -
 .../download/download_shelf_context_menu.cc   |  17 -
 chrome/browser/download/download_ui_model.cc  |   4 +-
 chrome/browser/download/download_ui_model.h   |   4 +-
 .../download/drag_download_item_android.cc    |  35 +
 .../download/drag_download_item_aura.cc       |   2 +
 .../enterprise_reporting/policy_info.cc       |   2 +
 chrome/browser/extensions/BUILD.gn            |   9 +-
 .../bookmark_manager_private_api.cc           |   5 -
 .../api/browsing_data/browsing_data_api.cc    |  15 +-
 .../content_settings/content_settings_api.cc  |   4 +
 .../chrome_desktop_report_request_helper.cc   |   7 +-
 .../removable_storage_provider_android.cc     |  19 +
 .../device_id_android.cc                      | 184 ++++
 .../resources_private_api.cc                  |   2 +
 .../safe_browsing_private_event_router.cc     |   5 +
 .../api/tabs/windows_event_router.cc          |   2 -
 .../browser/extensions/bookmark_app_helper.cc | 868 ++++++++++++++++++
 .../chrome_extensions_browser_client.cc       |   7 +
 .../chrome_process_manager_delegate.cc        |   1 +
 .../extensions/extension_install_prompt.cc    |  64 ++
 .../extensions/extension_install_prompt.h     |   4 +
 .../extension_install_prompt_show_params.cc   |   4 -
 .../extensions/extension_uninstall_dialog.cc  |   2 +
 .../global_shortcut_listener_android.cc       |  64 ++
 .../global_shortcut_listener_android.h        |  36 +
 .../display_info_provider_android.cc          |  17 +
 .../display_info_provider_android.h           |  24 +
 chrome/browser/first_run/first_run_dialog.h   |   2 +-
 chrome/browser/first_run/upgrade_util.h       |   4 -
 chrome/browser/flag_descriptions.cc           |   2 -
 chrome/browser/flag_descriptions.h            |   2 -
 ...ome_web_view_permission_helper_delegate.cc |   2 +
 ...rome_web_view_permission_helper_delegate.h |   4 +-
 chrome/browser/media/router/BUILD.gn          |   2 +-
 .../browser/media/router/discovery/BUILD.gn   |   4 +-
 chrome/browser/media/router/media_router.h    |   4 +-
 .../browser/media/router/media_router_base.cc |   2 +-
 .../browser/media/router/media_router_base.h  |   4 +-
 .../media/router/media_router_feature.cc      |   6 +-
 .../media/router/media_router_feature.h       |   2 +-
 .../media_capture_devices_dispatcher.cc       |   7 -
 .../metrics/chrome_feature_list_creator.cc    |   6 +
 .../notification_display_service_impl.cc      |  18 -
 .../obsolete_system_android.cc                |  25 +
 .../attestation_permission_request.cc         |  12 +-
 chrome/browser/platform_util.cc               |  42 -
 chrome/browser/platform_util_android.cc       |   4 +
 .../plugins/plugins_resource_service.cc       |   2 +-
 .../browser_dm_token_storage_android.cc       | 191 ++++
 .../policy/browser_dm_token_storage_android.h |  58 ++
 .../policy/chrome_browser_policy_connector.cc |   2 +-
 ...nfiguration_policy_handler_list_factory.cc |   2 +-
 chrome/browser/prefs/browser_prefs.cc         |  50 +-
 .../prefs/chrome_pref_service_factory.cc      |   2 +-
 ...hrome_browser_main_extra_parts_profiles.cc | 114 ++-
 ...chrome_browser_main_extra_parts_profiles.h |   2 +-
 .../profiles/off_the_record_profile_impl.cc   |  11 +-
 .../profiles/off_the_record_profile_impl.h    |  10 +-
 chrome/browser/profiles/profile.cc            |   4 +-
 chrome/browser/profiles/profile.h             |   6 +-
 chrome/browser/profiles/profile_impl.cc       |  11 +-
 chrome/browser/profiles/profile_impl.h        |   6 +-
 chrome/browser/profiles/profile_manager.cc    |   8 +-
 chrome/browser/profiles/profile_manager.h     |   6 +-
 chrome/browser/profiles/profile_metrics.cc    |   8 +-
 chrome/browser/profiles/profile_metrics.h     |   2 +-
 chrome/browser/profiles/profile_window.cc     |   4 +-
 chrome/browser/profiles/profile_window.h      |   4 -
 chrome/browser/profiles/profiles_state.cc     |   4 +-
 chrome/browser/profiles/profiles_state.h      |   2 +-
 .../render_view_context_menu.cc               |  12 +-
 .../render_view_context_menu.h                |   2 +
 .../resource_coordinator_parts.cc             |   4 +-
 .../resource_coordinator_parts.h              |  12 +-
 .../resource_coordinator/tab_helper.cc        |   4 +-
 .../browser/resource_coordinator/tab_helper.h |   4 +-
 .../tab_manager_web_contents_data.cc          |   3 +
 chrome/browser/resources/BUILD.gn             |   6 +-
 .../resources/md_extensions/extensions.html   |  47 +
 chrome/browser/resources/unpack_pak.py        |   4 +
 chrome/browser/search/instant_service.h       |   4 -
 .../browser/search/instant_service_factory.h  |   4 -
 .../browser/search/instant_service_observer.h |   4 -
 chrome/browser/search/local_ntp_source.h      |   4 -
 .../search/most_visited_iframe_source.h       |   4 -
 .../browser/sharing/click_to_call/feature.cc  |   2 +-
 .../browser/sharing/click_to_call/feature.h   |   2 +-
 .../sharing/shared_clipboard/feature_flags.cc |   2 +-
 .../sharing/shared_clipboard/feature_flags.h  |   2 +-
 .../account_consistency_mode_manager.cc       |   6 +-
 chrome/browser/signin/chrome_signin_helper.cc |   2 +-
 chrome/browser/startup_data.cc                |  25 +-
 .../supervised_user_service.cc                |   2 +
 .../sync/profile_sync_service_factory.cc      |  33 +-
 chrome/browser/ui/BUILD.gn                    |  55 +-
 .../ui/bookmarks/bookmark_utils_desktop.cc    |   9 +-
 chrome/browser/ui/browser.cc                  |   7 +-
 chrome/browser/ui/browser.h                   |   2 +
 .../browser/ui/browser_command_controller.cc  |   4 -
 chrome/browser/ui/browser_commands.cc         |   1 -
 ...r_content_setting_bubble_model_delegate.cc |   2 +-
 .../browser/ui/browser_instant_controller.h   |   4 -
 chrome/browser/ui/browser_list.cc             |   3 +-
 chrome/browser/ui/browser_navigator_params.cc |   4 +-
 chrome/browser/ui/browser_navigator_params.h  |   6 +-
 chrome/browser/ui/browser_otr_state.cc        |   4 -
 chrome/browser/ui/browser_ui_prefs.cc         |   2 +-
 chrome/browser/ui/browser_window.h            |   4 -
 chrome/browser/ui/chrome_pages.cc             |   4 +-
 chrome/browser/ui/chrome_pages.h              |   4 +-
 .../content_setting_bubble_model.cc           |   3 +
 .../content_setting_bubble_model.h            |   2 +-
 chrome/browser/ui/fast_unload_controller.cc   | 487 ++++++++++
 .../ui/native_window_tracker_android.cc       |  26 +
 .../ui/native_window_tracker_android.h        |  26 +
 chrome/browser/ui/page_info/page_info_ui.cc   |  10 +-
 chrome/browser/ui/page_info/page_info_ui.h    |   4 +-
 .../settings/password_manager_presenter.cc    |   4 +-
 .../ui/screen_capture_notification_ui_stub.cc |   2 +
 chrome/browser/ui/search/instant_controller.h |   4 -
 .../browser/ui/search/ntp_user_data_logger.h  |   4 -
 chrome/browser/ui/search/search_ipc_router.h  |   4 -
 .../ui/search/search_ipc_router_policy_impl.h |   4 -
 chrome/browser/ui/search/search_tab_helper.h  |   4 -
 chrome/browser/ui/signin_view_controller.h    |   2 +
 chrome/browser/ui/tab_helpers.cc              |   2 +
 chrome/browser/ui/tabs/tab_strip_model.cc     |   4 +
 chrome/browser/ui/tabs/tab_strip_model.h      |   4 -
 .../component_toolbar_actions_factory.cc      |  59 ++
 chrome/browser/ui/unload_controller.cc        |  35 +-
 chrome/browser/ui/views/BUILD.gn              |   2 -
 .../ui/views/accelerator_utils_android.cc     |  30 +
 .../autofill_popup_view_native_views.cc       |  10 +-
 .../browser/ui/views/browser_dialogs_views.cc |  11 -
 .../ui/views/chrome_views_delegate_android.cc |  15 +
 .../desktop_media_list_view.cc                |   2 +-
 .../ui/views/download/download_item_view.cc   |   2 +
 .../ui/views/dropdown_bar_host_android.cc     |  10 +
 chrome/browser/ui/views/find_bar_host.cc      |   4 -
 .../browser/ui/views/frame/browser_frame.cc   |   1 +
 ...ser_non_client_frame_view_factory_views.cc |   1 -
 .../ui/views/frame/browser_root_view.cc       |   8 +-
 chrome/browser/ui/views/frame/browser_view.cc |  21 +-
 .../ui/views/frame/browser_window_factory.cc  |  10 -
 .../frame/desktop_browser_frame_android.cc    |  75 ++
 .../frame/desktop_browser_frame_android.h     |  63 ++
 .../native_browser_frame_factory_android.cc   |  13 +
 .../ui/views/javascript_dialog_views.cc       |   2 +
 .../views/location_bar/location_bar_view.cc   |  25 +-
 .../ui/views/location_bar/location_bar_view.h |   2 +
 .../omnibox/omnibox_popup_contents_view.cc    |   2 +-
 .../permission_prompt_bubble_view.cc          |   2 +
 .../permission_prompt_impl.cc                 |   2 +
 .../ui/views/profiles/avatar_button.cc        | 559 +++++++++++
 .../ui/views/profiles/profile_menu_view.cc    |   2 +
 .../relaunch_notification_controller.cc       |   2 +
 .../password_reuse_modal_warning_dialog.cc    |   8 +
 chrome/browser/ui/views/tabs/tab_strip.cc     |  12 -
 .../ui/views/tabs/window_finder_android.cc    |  15 +
 .../webui/chrome_web_ui_controller_factory.cc |   2 +
 chrome/browser/ui/webui/discards/BUILD.gn     |   2 +-
 .../ui/webui/media_router/media_router_ui.cc  | 716 +++++++++++++++
 .../webui/settings/change_password_handler.cc |  15 -
 .../webui/signin/inline_login_handler_impl.cc |   4 +
 .../ui/window_sizer/window_sizer_android.cc   |  17 +
 .../ui/zoom/chrome_zoom_level_prefs.cc        |  29 +-
 chrome/browser/web_applications/BUILD.gn      |   3 -
 .../web_applications/components/BUILD.gn      |   3 -
 .../components/web_app_shortcut_android.cc    | 122 +++
 .../components/web_app_shortcut_android.h     |  62 ++
 .../web_applications/extensions/BUILD.gn      |   3 -
 .../extensions/web_app_extension_shortcut.cc  |  10 +-
 .../web_applications/web_app_android.cc       |  44 +
 chrome/chrome_paks.gni                        |   2 +-
 chrome/common/BUILD.gn                        |   3 +-
 chrome/common/chrome_features.cc              |  15 +-
 chrome/common/chrome_features.h               |   8 +-
 chrome/common/chrome_paths.cc                 |   2 +-
 chrome/common/chrome_paths.h                  |   2 +-
 chrome/common/chrome_switches.cc              |   2 +-
 chrome/common/chrome_switches.h               |   2 +-
 chrome/common/extensions/api/api_sources.gni  |   2 +-
 chrome/common/features.gni                    |   4 +-
 chrome/common/pref_names.cc                   |  26 +-
 chrome/common/pref_names.h                    |  26 +-
 chrome/common/url_constants.cc                |   4 +-
 chrome/common/url_constants.h                 |   4 +-
 chrome/common/webui_url_constants.cc          |   4 +-
 chrome/common/webui_url_constants.h           |   4 +-
 .../chrome_content_renderer_client.cc         |   2 +-
 chrome/renderer/media/chrome_key_systems.cc   |   2 +-
 chrome/test/BUILD.gn                          |   2 +-
 chromecast/browser/cast_browser_context.cc    |   2 +-
 chromecast/browser/cast_browser_context.h     |   2 +-
 components/autofill_payments_strings.grdp     |  12 +-
 components/autofill_strings.grdp              |   2 +-
 components/bookmarks/browser/BUILD.gn         |   2 +-
 .../bookmarks/browser/bookmark_node_data.h    |   8 +-
 components/components_strings.grd             |   4 +-
 .../core/browser/cookie_settings.cc           |   1 +
 .../public/event_constants.cc                 |   4 +-
 .../public/event_constants.h                  |   4 +-
 .../public/feature_constants.cc               |   2 +-
 .../public/feature_constants.h                |   2 +-
 components/guest_view/browser/BUILD.gn        |   2 +-
 components/guest_view/renderer/BUILD.gn       |   2 +-
 components/history_strings.grdp               |   2 +-
 components/keep_alive_registry/BUILD.gn       |   2 +-
 components/new_or_sad_tab_strings.grdp        |   2 +-
 components/page_info_strings.grdp             |  10 +-
 .../payments/content/payment_request.cc       |   2 +-
 components/payments/content/payment_request.h |   2 +-
 components/payments_strings.grdp              |   2 +-
 components/pdf_strings.grdp                   |   2 +-
 .../browser/configuration_policy_handler.cc   |   1 +
 .../policy/resources/policy_templates.json    |  10 +-
 components/prefs/pref_service.cc              |   4 +
 components/search/search.cc                   |   4 -
 components/signin/features.gni                |   2 +-
 components/sync_ui_strings.grdp               |   2 +-
 components/ui_devtools/views/BUILD.gn         |   7 +
 .../ui_devtools/views/dom_agent_android.cc    |  44 +
 .../ui_devtools/views/dom_agent_android.h     |  32 +
 .../views/overlay_agent_android.cc            |  44 +
 .../ui_devtools/views/overlay_agent_android.h |  36 +
 .../ui_devtools/views/overlay_agent_views.cc  |   4 -
 components/url_formatter/elide_url.cc         |   4 +-
 components/url_formatter/elide_url.h          |   2 +-
 components/web_modal/BUILD.gn                 |   2 +-
 components/zoom/BUILD.gn                      |   2 +-
 content/app/content_main_runner_impl.cc       |  33 +
 .../content_service_manager_main_delegate.cc  |   2 +
 content/browser/BUILD.gn                      |  16 +-
 content/browser/browser_main.cc               |   4 +
 content/browser/browser_main_loop.cc          |  28 +
 content/browser/browser_main_runner_impl.cc   |   3 +
 .../gpu_process_transport_factory.cc          |   8 -
 content/browser/devtools/BUILD.gn             |   2 +-
 .../frame_host/navigation_controller_impl.cc  |   4 +
 .../browser/frame_host/navigation_request.cc  |   2 +
 .../pepper/pepper_truetype_font_android.cc    |  78 ++
 .../pepper_truetype_font_list_android.cc      |  20 +
 .../renderer_host/render_view_host_impl.cc    |   6 +-
 content/browser/storage_partition_impl.cc     |   5 +-
 content/browser/storage_partition_impl.h      |   6 +-
 .../browser/web_contents/web_contents_impl.cc |   8 +-
 .../browser/web_contents/web_contents_impl.h  |   6 +-
 .../webui/shared_resources_data_source.cc     |   6 +-
 content/public/browser/browser_context.h      |   4 +-
 .../public/browser/content_browser_client.cc  |   2 +-
 .../public/browser/content_browser_client.h   |   2 +-
 content/public/browser/desktop_media_id.cc    |   4 +-
 content/public/browser/desktop_media_id.h     |   2 +-
 content/public/browser/storage_partition.h    |   4 +-
 content/public/common/pepper_plugin_info.h    |   2 +
 content/shell/BUILD.gn                        |   2 +-
 .../shell/browser/shell_browser_context.cc    |   2 +-
 content/shell/browser/shell_browser_context.h |   4 +-
 extensions/BUILD.gn                           |  36 -
 extensions/browser/api/api_resource_manager.h |   8 +
 .../browser/api/messaging/message_service.cc  |   2 +-
 extensions/browser/api/socket/tcp_socket.cc   | 104 +--
 extensions/browser/api/socket/tcp_socket.h    |   2 -
 extensions/browser/api/system_cpu/BUILD.gn    |   1 +
 .../system_cpu/cpu_info_provider_android.cc   |  77 ++
 .../browser/extensions_browser_client.cc      |   1 +
 .../guest_view/web_view/web_view_guest.cc     |   1 +
 extensions/buildflags/buildflags.gni          |   2 +-
 google_apis/BUILD.gn                          |   2 +-
 mojo/public/js/mojo_bindings_resources.grd    |   2 +-
 services/device/public/cpp/hid/BUILD.gn       |   2 +-
 services/service_manager/embedder/main.cc     |  27 +
 services/tracing/public/cpp/trace_startup.cc  |   4 +
 third_party/blink/public/mojom/BUILD.gn       |   2 +-
 ui/android/window_android.h                   |   8 +
 ui/base/BUILD.gn                              |  17 +-
 ui/base/cursor/cursor.cc                      |   2 +-
 ui/base/dragdrop/os_exchange_data.cc          |   4 +-
 ui/base/dragdrop/os_exchange_data.h           |   8 +-
 .../os_exchange_data_provider_android.cc      | 220 +++++
 .../os_exchange_data_provider_android.h       | 101 ++
 .../os_exchange_data_provider_factory.cc      |   4 +-
 ui/events/event.h                             |   1 +
 ui/gfx/BUILD.gn                               |   7 -
 ui/message_center/BUILD.gn                    |   4 +-
 ui/native_theme/native_theme_android.cc       |   3 +-
 ui/native_theme/native_theme_android.h        |   2 +-
 ui/resources/BUILD.gn                         |   4 +-
 ui/resources/ui_resources.grd                 |   8 +-
 ui/views/BUILD.gn                             |  19 +-
 ui/views/controls/menu/menu_config_android.cc |  13 +
 ui/views/controls/menu/menu_controller.cc     |  69 --
 ui/views/controls/menu/menu_host.cc           |  42 -
 ui/views/controls/menu/menu_host.h            |   5 -
 .../native/native_view_host_android.cc        | 121 +++
 .../native/native_view_host_android.h         |  98 ++
 .../unhandled_keyboard_event_handler.cc       |   3 -
 ...nhandled_keyboard_event_handler_default.cc |   2 +-
 ui/views/controls/webview/web_dialog_view.cc  |   6 +-
 ui/views/event_monitor_android.cc             |  65 ++
 ui/views/event_monitor_android.h              |  37 +
 ui/views/metrics_android.cc                   |  36 +
 ui/views/native_cursor_android.cc             |  31 +
 ui/views/view.cc                              |   2 +
 ...ch_selection_controller_factory_android.cc |  22 +
 ...touch_selection_controller_factory_aura.cc |   2 +-
 ui/views/widget/native_widget_android.cc      | 491 ++++++++++
 ui/views/widget/native_widget_android.h       | 192 ++++
 ui/views/widget/widget.cc                     | 113 +--
 ui/webui/resources/css/roboto.css             |   2 +-
 ui/webui/resources/webui_resources.grd        |   6 +-
 346 files changed, 7037 insertions(+), 1291 deletions(-)
 create mode 100644 chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc
 create mode 100644 chrome/browser/background/background_mode_manager_android.cc
 delete mode 100644 chrome/browser/download/download_crx_util_android.cc
 create mode 100644 chrome/browser/download/drag_download_item_android.cc
 create mode 100644 chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc
 create mode 100644 chrome/browser/extensions/api/music_manager_private/device_id_android.cc
 create mode 100644 chrome/browser/extensions/bookmark_app_helper.cc
 create mode 100644 chrome/browser/extensions/global_shortcut_listener_android.cc
 create mode 100644 chrome/browser/extensions/global_shortcut_listener_android.h
 create mode 100644 chrome/browser/extensions/system_display/display_info_provider_android.cc
 create mode 100644 chrome/browser/extensions/system_display/display_info_provider_android.h
 create mode 100644 chrome/browser/obsolete_system/obsolete_system_android.cc
 create mode 100644 chrome/browser/policy/browser_dm_token_storage_android.cc
 create mode 100644 chrome/browser/policy/browser_dm_token_storage_android.h
 create mode 100644 chrome/browser/resources/md_extensions/extensions.html
 create mode 100644 chrome/browser/ui/fast_unload_controller.cc
 create mode 100644 chrome/browser/ui/native_window_tracker_android.cc
 create mode 100644 chrome/browser/ui/native_window_tracker_android.h
 create mode 100644 chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc
 create mode 100644 chrome/browser/ui/views/accelerator_utils_android.cc
 create mode 100644 chrome/browser/ui/views/chrome_views_delegate_android.cc
 create mode 100644 chrome/browser/ui/views/dropdown_bar_host_android.cc
 create mode 100644 chrome/browser/ui/views/frame/desktop_browser_frame_android.cc
 create mode 100644 chrome/browser/ui/views/frame/desktop_browser_frame_android.h
 create mode 100644 chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc
 create mode 100644 chrome/browser/ui/views/profiles/avatar_button.cc
 create mode 100644 chrome/browser/ui/views/tabs/window_finder_android.cc
 create mode 100644 chrome/browser/ui/webui/media_router/media_router_ui.cc
 create mode 100644 chrome/browser/ui/window_sizer/window_sizer_android.cc
 create mode 100644 chrome/browser/web_applications/components/web_app_shortcut_android.cc
 create mode 100644 chrome/browser/web_applications/components/web_app_shortcut_android.h
 create mode 100644 chrome/browser/web_applications/web_app_android.cc
 create mode 100644 components/ui_devtools/views/dom_agent_android.cc
 create mode 100644 components/ui_devtools/views/dom_agent_android.h
 create mode 100644 components/ui_devtools/views/overlay_agent_android.cc
 create mode 100644 components/ui_devtools/views/overlay_agent_android.h
 create mode 100644 content/browser/renderer_host/pepper/pepper_truetype_font_android.cc
 create mode 100644 content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc
 create mode 100644 extensions/browser/api/system_cpu/cpu_info_provider_android.cc
 create mode 100644 ui/base/dragdrop/os_exchange_data_provider_android.cc
 create mode 100644 ui/base/dragdrop/os_exchange_data_provider_android.h
 create mode 100644 ui/views/controls/menu/menu_config_android.cc
 create mode 100644 ui/views/controls/native/native_view_host_android.cc
 create mode 100644 ui/views/controls/native/native_view_host_android.h
 create mode 100644 ui/views/event_monitor_android.cc
 create mode 100644 ui/views/event_monitor_android.h
 create mode 100644 ui/views/metrics_android.cc
 create mode 100644 ui/views/native_cursor_android.cc
 create mode 100644 ui/views/views_touch_selection_controller_factory_android.cc
 create mode 100644 ui/views/widget/native_widget_android.cc
 create mode 100644 ui/views/widget/native_widget_android.h

diff --git a/BUILD.gn b/BUILD.gn
index efaf5b31ee37..56b8e7fd1180 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -240,7 +240,7 @@ group("gn_all") {
 
   deps += root_extra_deps
 
-  if (enable_extensions) {
+  if (false && enable_extensions) {
     deps += [
       "//extensions:extensions_browsertests",
       "//extensions:extensions_unittests",
diff --git a/DEPS b/DEPS
index 20b6b4bb1fbd..cb72214c8cee 100644
--- a/DEPS
+++ b/DEPS
@@ -1499,7 +1499,7 @@ deps = {
     Var('chromium_git') + '/external/khronosgroup/webgl.git' + '@' + 'dd55f3ca8f2ea716ca917a4aaf36f0729fe902b1',
 
   'src/third_party/webrtc':
-    Var('webrtc_git') + '/src.git' + '@' + 'fba51dc69b97f6f170d9c325a38e05ddd69c8b28',
+    Var('webrtc_git') + '/src.git' + '@' + 'refs/branch-heads/3987',
 
   'src/third_party/libgifcodec':
      Var('skia_git') + '/libgifcodec' + '@'+  Var('libgifcodec_revision'),
diff --git a/apps/BUILD.gn b/apps/BUILD.gn
index bba3724ca1d0..18aa35d48877 100644
--- a/apps/BUILD.gn
+++ b/apps/BUILD.gn
@@ -6,7 +6,7 @@ import("//build/config/features.gni")
 import("//build/config/ui.gni")
 import("//extensions/buildflags/buildflags.gni")
 
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 assert(enable_extensions,
        "Cannot depend on extensions because enable_extensions=false.")
 
diff --git a/build/config/compiler/compiler.gni b/build/config/compiler/compiler.gni
index 8ecf5e641af4..459cfc7d83d6 100644
--- a/build/config/compiler/compiler.gni
+++ b/build/config/compiler/compiler.gni
@@ -91,9 +91,9 @@ assert(!is_cfi || use_thin_lto, "CFI requires ThinLTO")
 # For unofficial (e.g. development) builds and non-Chrome branded (e.g. Cronet
 # which doesn't use Crashpad, crbug.com/479283) builds it's useful to be able
 # to unwind at runtime.
-exclude_unwind_tables =
-    is_official_build || (is_chromecast && !is_cast_desktop_build &&
-                          !is_debug && !cast_is_debug && !is_fuchsia)
+exclude_unwind_tables = false
+#    is_official_build || (is_chromecast && !is_cast_desktop_build &&
+#                          !is_debug && !cast_is_debug && !is_fuchsia)
 
 # If true, optimize for size. Does not affect windows builds.
 # Linux & Mac favor speed over size.
diff --git a/chrome/BUILD.gn b/chrome/BUILD.gn
index c38d03923119..d9990cc8e791 100644
--- a/chrome/BUILD.gn
+++ b/chrome/BUILD.gn
@@ -1538,7 +1538,7 @@ group("extra_resources") {
     "//components/autofill/core/browser:autofill_address_rewriter_resources",
   ]
 
-  if (!is_android) {
+  if (true || !is_android) {
     public_deps += [
       "//chrome/browser/resources:bookmarks_resources",
       "//chrome/browser/resources:component_extension_resources",
@@ -1564,7 +1564,7 @@ group("extra_resources") {
     ]
   }
 
-  if (!is_android && !is_chromeos) {
+  if (true || (!is_android && !is_chromeos)) {
     public_deps += [ "//chrome/browser/resources:welcome_resources" ]
   }
 
diff --git a/chrome/app/android/chrome_main_delegate_android.cc b/chrome/app/android/chrome_main_delegate_android.cc
index fe6940b6dc3e..7ed0aac2eef4 100644
--- a/chrome/app/android/chrome_main_delegate_android.cc
+++ b/chrome/app/android/chrome_main_delegate_android.cc
@@ -73,26 +73,33 @@ void ChromeMainDelegateAndroid::SecureDataDirectory() {
 int ChromeMainDelegateAndroid::RunProcess(
     const std::string& process_type,
     const content::MainFunctionParams& main_function_params) {
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 1";
   TRACE_EVENT0("startup", "ChromeMainDelegateAndroid::RunProcess");
   // Defer to the default main method outside the browser process.
   if (!process_type.empty())
     return -1;
 
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 2";
   SecureDataDirectory();
 
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 3";
   // Because the browser process can be started asynchronously as a series of
   // UI thread tasks a second request to start it can come in while the
   // first request is still being processed. Chrome must keep the same
   // browser runner for the second request.
   // Also only record the start time the first time round, since this is the
   // start time of the application, and will be same for all requests.
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 4";
   if (!browser_runner_) {
     startup_metric_utils::RecordMainEntryPointTime(
         chrome::android::GetMainEntryPointTimeTicks());
     browser_runner_ = content::BrowserMainRunner::Create();
+    LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 5";
   }
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 6";
 
   int exit_code = browser_runner_->Initialize(main_function_params);
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegateAndroid::RunProcess - Step 7";
   // On Android we do not run BrowserMain(), so the above initialization of a
   // BrowserMainRunner is all we want to occur. Return >= 0 to avoid running
   // BrowserMain, while preserving any error codes > 0.
diff --git a/chrome/app/bookmarks_strings.grdp b/chrome/app/bookmarks_strings.grdp
index d049041a4e05..7b85cccff7a0 100644
--- a/chrome/app/bookmarks_strings.grdp
+++ b/chrome/app/bookmarks_strings.grdp
@@ -2,7 +2,7 @@
 <!-- Bookmarks specific strings (included from generated_resources.grd). -->
 <grit-part>
   <!-- Begin of Bookmarks Bar strings-->
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <!-- The special folders created when importing from other other browsers. -->
     <if expr="is_win">
       <message name="IDS_BOOKMARK_GROUP_FROM_IE" desc="The group name of bookmarks from Internet Explorer">
@@ -100,7 +100,7 @@
     <message name="IDS_BOOKMARK_BAR_NEW_FOLDER" desc="Menu title for adding a new folder">
       Add &amp;folder...
     </message>
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_SHOW_BOOKMARK_BAR" desc="The toggle to show the bookmark bar">
         &amp;Show bookmarks bar
       </message>
@@ -152,7 +152,7 @@
     <message name="IDS_BOOKMARK_BAR_NEW_FOLDER" desc="In Title Case: Menu title for adding a new folder">
       Add &amp;Folder...
     </message>
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_SHOW_BOOKMARK_BAR" desc="In Title Case: The toggle to show the bookmark bar">
         &amp;Show Bookmarks Bar
       </message>
diff --git a/chrome/app/chrome_main_delegate.cc b/chrome/app/chrome_main_delegate.cc
index 6eb5d8650d96..66220fec822c 100644
--- a/chrome/app/chrome_main_delegate.cc
+++ b/chrome/app/chrome_main_delegate.cc
@@ -520,10 +520,13 @@ ChromeMainDelegate::~ChromeMainDelegate() {
 
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
 void ChromeMainDelegate::PostEarlyInitialization(bool is_running_tests) {
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 1";
+
   // Chrome disallows cookies by default. All code paths that want to use
   // cookies need to go through one of Chrome's URLRequestContexts which have
   // a ChromeNetworkDelegate attached that selectively allows cookies again.
   net::URLRequest::SetDefaultCookiePolicyToBlock();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 2";
 
 #if defined(OS_CHROMEOS)
   // The feature list depends on BrowserPolicyConnectorChromeOS which depends
@@ -531,18 +534,24 @@ void ChromeMainDelegate::PostEarlyInitialization(bool is_running_tests) {
   // list, so initialize them separately later at the end of this function.
   chromeos::InitializeDBus();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 3";
 
   DCHECK(startup_data_);
   auto* chrome_feature_list_creator =
       startup_data_->chrome_feature_list_creator();
   chrome_feature_list_creator->CreateFeatureList();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 4";
   PostFieldTrialInitialization();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 5";
 
   // Initializes the resource bundle and determines the locale.
   std::string actual_locale =
       LoadLocalState(chrome_feature_list_creator, is_running_tests);
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 6";
   chrome_feature_list_creator->SetApplicationLocale(actual_locale);
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 7";
   chrome_feature_list_creator->OverrideCachedUIStrings();
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 8";
 
 #if defined(OS_CHROMEOS)
   // Initialize D-Bus clients that depend on feature list.
@@ -550,10 +559,13 @@ void ChromeMainDelegate::PostEarlyInitialization(bool is_running_tests) {
 #endif
 
 #if defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 8a";
   startup_data_->CreateProfilePrefService();
   net::NetworkChangeNotifier::SetFactory(
       new net::NetworkChangeNotifierFactoryAndroid());
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 8b";
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 9";
 
   if (base::FeatureList::IsEnabled(
           features::kWriteBasicSystemProfileToPersistentHistogramsFile)) {
@@ -565,6 +577,7 @@ void ChromeMainDelegate::PostEarlyInitialization(bool is_running_tests) {
     if (record)
       startup_data_->RecordCoreSystemProfile();
   }
+  LOG(ERROR) << "[Kiwi] ChromeMainDelegate::PostEarlyInitialization - Step 10";
 }
 
 bool ChromeMainDelegate::ShouldCreateFeatureList() {
diff --git a/chrome/app/chromium_strings.grd b/chrome/app/chromium_strings.grd
index 90228f41336b..a3175b77a2e8 100644
--- a/chrome/app/chromium_strings.grd
+++ b/chrome/app/chromium_strings.grd
@@ -149,7 +149,7 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
   <release seq="1" allow_pseudo="false">
     <messages fallback_to_english="true">
       <!-- Settings specific strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="settings_chromium_strings.grdp" />
       </if>
 
@@ -610,7 +610,7 @@ Chromium is unable to recover your settings.
       </if>
 
       <!-- Enterprise sign-in dialog -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_ENTERPRISE_SIGNIN_TITLE" desc="The title of the dialog to confirm linking the browser profile with the signed-in enterprise account">
           Link your Chromium data to this account?
         </message>
@@ -623,7 +623,7 @@ Chromium is unable to recover your settings.
       </if>
 
       <!-- about:browser-switch strings -->
-      <if expr="is_win or is_macosx or (is_linux and not is_chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not is_chromeos)">
         <message name="IDS_ABOUT_BROWSER_SWITCH_DESCRIPTION_UNKNOWN_BROWSER" desc="Description shown while waiting for an alternative browser to open, when the browser name is not auto-detected">
           Your system administrator has configured Chromium to open an alternative browser to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
         </message>
@@ -741,7 +741,7 @@ Chromium is unable to recover your settings.
       </if>
 
       <!-- Material Design User Manager -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <!-- User pod remove sync warning text -->
         <message name="IDS_LOGIN_POD_USER_REMOVE_WARNING_SYNC" desc="Main text shown as a warning when attempting to remove an user.">
           This person's browsing data will be deleted from this device. To recover the data, sign in to Chromium as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
@@ -818,7 +818,7 @@ Chromium is unable to recover your settings.
         </message>
       </if>
 
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Chromium.">
           If an image doesnâ€™t have a useful description, Chromium will try to provide one for you. To create descriptions, images are sent to Google. You can turn this off in settings at any time.
         </message>
@@ -914,7 +914,7 @@ Chromium is unable to recover your settings.
       </message>
 
       <!-- Sync errors. Android uses native UI to handle Sync settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_SYNC_UPGRADE_CLIENT" desc="Message indicating client needs to be upgraded to the latest version.">
           Update Chromium to start sync
         </message>
@@ -1002,7 +1002,7 @@ Chromium is unable to recover your settings.
       </if>
 
       <!-- Welcome page (chrome://welcome) strings -->
-      <if expr="not chromeos and not is_android">
+      <if expr="is_android or not chromeos and not is_android">
         <message name="IDS_WELCOME_HEADER" desc="A message which will appear as the header on the Welcome UI if the user has never run Chromium before.">
           Welcome to Chromium
         </message>
@@ -1015,7 +1015,7 @@ Chromium is unable to recover your settings.
         </message>
       </if>
       <!-- Relaunch notification bubble and dialog. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not chromeos">
           <message name="IDS_RELAUNCH_RECOMMENDED_TITLE" desc="The title of a dialog that tells users that a browser relaunch is recommended for an update available for some number of days.">
             {0, plural,
@@ -1059,7 +1059,7 @@ Chromium is unable to recover your settings.
         </if>
       </if>
       <!-- Chromium launch blocking dialog. -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
          <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_TOOLTIP" desc="The information message of Chromium launch blocking dialog for machine level user cloud policy enrollment.">
           Launching Chromium...
         </message>
@@ -1074,7 +1074,7 @@ Chromium is unable to recover your settings.
         Share a Chromium tab
       </message>
       <!-- User happiness tracking survey UI -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_HATS_BUBBLE_TITLE" translateable="false" desc="The title of Happiness Tracking Survey's invitation banner, it invites users to take a survey">
           Help us improve Chromium
         </message>
diff --git a/chrome/app/generated_resources.grd b/chrome/app/generated_resources.grd
index 872382b55adb..6938d79187ba 100644
--- a/chrome/app/generated_resources.grd
+++ b/chrome/app/generated_resources.grd
@@ -234,7 +234,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
       <!-- Settings specific strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="settings_strings.grdp" />
       </if>
 
@@ -244,7 +244,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
       <!-- Welcome strings -->
-      <if expr="not chromeos and not is_android">
+      <if expr="is_android or not chromeos and not is_android">
         <part file="welcome_strings.grdp" />
       </if>
 
@@ -392,7 +392,7 @@ are declared in tools/grit/grit_rule.gni.
         Disable
       </message>
       <!-- Search strings are only used in webui, so no mobile. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_SEARCH_CLEARED" desc="Message announced to screenreader users when search is cleared.">
           Search cleared
         </message>
@@ -414,7 +414,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
        <!-- content area context menus. Android does not use it -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_CONTENT_CONTEXT_INSPECTELEMENT" desc="The name of the Inspect Element command in the content area context menu">
           I&amp;nspect
         </message>
@@ -914,7 +914,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
       <!-- Page menu. Android has separate strings for its menu -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <message name="IDS_NEW_TAB" desc="The text label of a menu item for opening a new tab">
             New &amp;tab
@@ -1891,7 +1891,7 @@ are declared in tools/grit/grit_rule.gni.
       </message>
 
       <!-- Download Context Menu Items -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <if expr="is_macosx">
             <message name="IDS_DOWNLOAD_MENU_SHOW"
@@ -2132,7 +2132,7 @@ are declared in tools/grit/grit_rule.gni.
       </if>
 
       <!-- Desktop omnibox PWA install icon -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_OMNIBOX_PWA_INSTALL_ICON_LABEL" desc="String for the omnibox icon label promoting an app installation">
           Install
         </message>
@@ -2619,7 +2619,7 @@ are declared in tools/grit/grit_rule.gni.
       </message>
 
       <!-- Win certificate selector dialog strings.  -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_CERT_SELECTOR_SUBJECT_COLUMN" desc="The text of the header for the certificate subject column in the certificate selector dialog.">
           Subject
         </message>
@@ -3244,7 +3244,7 @@ are declared in tools/grit/grit_rule.gni.
       </message>
 
       <!-- Task Manager Window -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <message name="IDS_TASK_MANAGER_KILL" desc="The caption of the Task Manager kill button">
             End process
@@ -3511,7 +3511,7 @@ are declared in tools/grit/grit_rule.gni.
       <message name="IDS_UTILITY_PROCESS_FILE_UTILITY_NAME" desc="The name of the utility process used for various Chrome specific file operations.">
           Chrome File Utilities
       </message>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_UTILITY_PROCESS_PROFILE_IMPORTER_NAME" desc="The name of the utility process used for importing profiles.">
           Profile Importer
         </message>
@@ -4897,7 +4897,7 @@ Keep your key file in a safe place. You will need it to create new versions of y
       </message>
 
       <!-- Pepper Broker Infobar -->
-      <if expr="enable_plugins">
+      <if expr="is_android or enable_plugins">
         <message name="IDS_PEPPER_BROKER_MESSAGE" desc="Message shown when a pepper plugin wants to launch its broker. This message is followed by a 'Learn more' link.">
           <ph name="PEPPER_PLUGIN_NAME">$1<ex>Flash</ex></ph> on <ph name="PEPPER_PLUGIN_DOMAIN">$2<ex>example.com</ex></ph> wants to access your computer
         </message>
@@ -4960,7 +4960,7 @@ Keep your key file in a safe place. You will need it to create new versions of y
       </message>
 
       <!-- about:system strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_ABOUT_SYS_TITLE" desc="about:system page title">
           About System
         </message>
@@ -4991,7 +4991,7 @@ Keep your key file in a safe place. You will need it to create new versions of y
       </if>
 
       <!-- chrome://browser-switch strings -->
-      <if expr="is_win or is_macosx or (is_linux and not is_chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not is_chromeos)">
         <message name="IDS_ABOUT_BROWSER_SWITCH_TITLE" desc="about:browser-switch page title">
           Legacy Browser Support
         </message>
@@ -5466,7 +5466,7 @@ Keep your key file in a safe place. You will need it to create new versions of y
       </message>
 
       <!-- Strings for intent picker -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_TOOLTIP_INTENT_PICKER_ICON" desc="The tooltip for the intent picker bubble icon">
           To open this link, choose an app
         </message>
@@ -5725,20 +5725,7 @@ the Bookmarks menu.">
           No thanks
         </message>
       </if>
-      <if expr="not is_android">
-        <message name="IDS_PASSWORD_MANAGER_SAVE_BUTTON" desc="Save button text for password manager">
-          Save
-        </message>
-        <if expr="use_titlecase">
-          <message name="IDS_PASSWORD_MANAGER_UPDATE_BUTTON" desc="In Title Case: Update button text for password manager">
-            Update Password
-          </message>
-        </if>
-        <if expr="not use_titlecase">
-          <message name="IDS_PASSWORD_MANAGER_UPDATE_BUTTON" desc="Update button text for password manager">
-            Update password
-          </message>
-        </if>
+      <if expr="is_android or not is_android">
         <message name="IDS_PASSWORD_MANAGER_BUBBLE_BLACKLIST_BUTTON" desc="Button text for the 'Save Password' bubble's 'Never remember for this site' option">
           Never
         </message>
@@ -5792,7 +5779,7 @@ the Bookmarks menu.">
       </if>
 
       <!-- Android uses custom UI for Bookmark importing -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- Import Settings Dialog -->
         <if expr="is_win">
           <message name="IDS_IMPORT_FROM_IE" desc="browser combo box: Microsoft Internet Explorer">
@@ -6553,7 +6540,7 @@ the Bookmarks menu.">
       <!-- Settings related strings not specific to chrome://settings.
            (Settings specific strings are in settings_strings.grdp).
            Android uses native UI for settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_TOOLBAR_INFORM_SET_HOME_PAGE" desc="The confirmation message when dropping a link on the Home toolbar button">
            Your home page has been set.
         </message>
@@ -6760,7 +6747,7 @@ the Bookmarks menu.">
           Generate QR code for this Image
         </message>
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_OMNIBOX_QRCODE_GENERATOR_ICON_LABEL" desc="String for the omnibox icon label for the QR code Generator">
           QR code
         </message>
@@ -6929,7 +6916,7 @@ the Bookmarks menu.">
       </message>
 
       <!-- Accessiblility strings for Infobars in Views -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_ACCNAME_INFOBAR_CONTAINER" desc="The accessible name for the infobar container.">
           Infobar Container
         </message>
@@ -6990,7 +6977,7 @@ the Bookmarks menu.">
       </message>
 
       <!-- Managed UI on pages like chrome://settings and chrome://downloads -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="chromeos">
           <message name="IDS_DEVICE_MANAGED_WITH_HYPERLINK" desc="Message to end users in Enterprise/EDU, with a link for more info (ChromeOS)">
             Your <ph name="BEGIN_LINK">&lt;a target="_blank" href="$1"&gt;</ph><ph name="DEVICE_TYPE">$2<ex>Chromebook</ex></ph> is managed<ph name="END_LINK">&lt;/a&gt;</ph> by your organization
@@ -7139,7 +7126,7 @@ the Bookmarks menu.">
       </message>
 
       <!-- Strings used for non-Android builds -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_APP_DEFAULT_PAGE_NAME"
                  desc="Default name for the first 'Apps' page on the New Tab Page.">
           Apps
@@ -7780,7 +7767,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       </if>
 
       <!-- Android uses native UI to handle Sync settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- Sync options dialog strings -->
         <if expr="not chromeos">
           <message name="IDS_SYNC_OVERVIEW" desc="The message that appears in the options dialog when sync has not been set up by the user.">
@@ -7889,7 +7876,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       </if>
 
       <!-- Translate Bubble -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_TRANSLATE_BUBBLE_BEFORE_TRANSLATE_TITLE" desc="Title text for the translate bubble when asking to translate a page.">
           Translate this page?
         </message>
@@ -9044,7 +9031,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       </message>
 
       <!-- Media Galleries. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_MEDIA_GALLERIES_DIALOG_HEADER" desc="Header for media gallery permissions dialog.">
           Media-File Permissions for "<ph name="EXTENSION">$1<ex>Photo Editor</ex></ph>"
         </message>
@@ -9565,7 +9552,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
       </message>
     </if>
 
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <!-- Device Chooser Prompt -->
       <message name="IDS_BLUETOOTH_DEVICE_CHOOSER_PROMPT_ORIGIN" desc="The label that is used to introduce Bluetooth chooser details to the user in a popup when it is from a website.">
         <ph name="Origin">$1<ex>www.google.com</ex></ph> wants to pair
@@ -9675,7 +9662,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </message>
 
     <!-- Serial port chooser -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_SERIAL_PORT_CHOOSER_PROMPT_ORIGIN" desc="The label that is used to introduce serial port chooser details to the user in a popup when it is from a website.">
         <ph name="Origin">$1<ex>www.google.com</ex></ph> wants to connect to a serial port
       </message>
@@ -9694,7 +9681,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </if>
 
     <!-- HID (Human Interface Device) chooser -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_HID_CHOOSER_PROMPT_ORIGIN" desc="The label that is used to introduce the Human Interface Device (HID) chooser details to the user in a popup when it is from a website.">
         <ph name="Origin">$1<ex>www.google.com</ex></ph> wants to connect to a HID device
       </message>
@@ -9755,7 +9742,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </if>
 
     <!-- Framebust / Blocked Redirection intervention message -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <!-- Android strings are declared in android_chrome_strings.grd. -->
       <message name="IDS_REDIRECT_BLOCKED_MESSAGE" desc="The message stating that a redirect (noun) was blocked on this page. This will be followed on a separate line with the address the user was being redirected to.">
         Redirect blocked:
@@ -9861,7 +9848,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </if>
 
     <!-- Download open confirmation dialog -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_DOWNLOAD_OPEN_CONFIRMATION_DIALOG_TITLE" desc="Title of the dialog prompt shown to users when an extension is trying to open a downloaded file.">
         Open download
       </message>
@@ -9983,7 +9970,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </message>
 
     <!-- Relaunch notification bubble and dialog. -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <if expr="not chromeos">
         <message name="IDS_RELAUNCH_ACCEPT_BUTTON" desc="The text in the accept button of a dialog that causes the browser to be relaunched immediately.">
           Relaunch now
@@ -10000,7 +9987,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </if>
 
     <!-- Web-modal dialog shown during Web Authenticaton API requests. -->
-    <if expr="is_win or is_macosx or desktop_linux or chromeos">
+    <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
       <message name="IDS_WEBAUTHN_GENERIC_TITLE" desc="Title of most dialogs shown while the user is authenticating on a web site using a security key.">
         Use your security key with <ph name="APP_NAME">$1<ex>google.com</ex></ph>
       </message>
@@ -10284,7 +10271,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
     </message>
 
     <!-- User happiness tracking survey UI -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <if expr="use_titlecase">
         <message name="IDS_HATS_BUBBLE_OK_LABEL" translateable="false" desc="Button label on Happiness Tracking Survey's invitation banner, clicking the button gives the user's consent on taking the survey.">
           Take Survey
diff --git a/chrome/app/google_chrome_strings.grd b/chrome/app/google_chrome_strings.grd
index d30a18e6f590..5ac17ef7d52c 100644
--- a/chrome/app/google_chrome_strings.grd
+++ b/chrome/app/google_chrome_strings.grd
@@ -151,7 +151,7 @@ chromium_strings.grd. -->
   <release seq="1" allow_pseudo="false">
     <messages fallback_to_english="true">
       <!-- Settings specific strings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="settings_google_chrome_strings.grdp" />
       </if>
 
@@ -622,7 +622,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- Enterprise sign-in dialog -->
-      <if expr="toolkit_views">
+      <if expr="is_android or toolkit_views">
         <message name="IDS_ENTERPRISE_SIGNIN_TITLE" desc="The title of the dialog to confirm linking the browser profile with the signed-in enterprise account">
           Link your Chrome data to this account?
         </message>
@@ -635,7 +635,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- about:browser-switch strings -->
-      <if expr="is_win or is_macosx or (is_linux and not is_chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not is_chromeos)">
         <message name="IDS_ABOUT_BROWSER_SWITCH_DESCRIPTION_UNKNOWN_BROWSER" desc="Description shown while waiting for an alternative browser to open, when the browser name is not auto-detected">
           Your system administrator has configured Google Chrome to open an alternative browser to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
         </message>
@@ -753,7 +753,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- Material Design User Manager -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <!-- User pod remove sync warning text -->
         <message name="IDS_LOGIN_POD_USER_REMOVE_WARNING_SYNC" desc="Main text shown as a warning when attempting to remove an user.">
           This person's browsing data will be deleted from this device. To recover the data, sign in to Chrome as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
@@ -837,7 +837,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- content area context menus. Android does not use it -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Chromium.">
           If an image doesnâ€™t have a useful description, Chrome will try to provide one for you. To create descriptions, images are sent to Google. You can turn this off in settings at any time.
         </message>
@@ -933,7 +933,7 @@ Google Chrome is unable to recover your settings.
       </message>
 
       <!-- Sync errors. Android uses native UI to handle Sync settings -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_SYNC_UPGRADE_CLIENT" desc="Message indicating client needs to be upgraded to the latest version.">
           Update Chrome to start sync
         </message>
@@ -1021,7 +1021,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- Welcome page (chrome://welcome) strings -->
-      <if expr="not chromeos">
+      <if expr="is_android or not chromeos">
         <message name="IDS_WELCOME_HEADER" desc="A message which will appear as the header on the Welcome UI if the user has never run Chrome before.">
           Welcome to Chrome
         </message>
@@ -1034,7 +1034,7 @@ Google Chrome is unable to recover your settings.
         </message>
       </if>
       <!-- Relaunch notification bubble and dialog. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not chromeos">
           <message name="IDS_RELAUNCH_RECOMMENDED_TITLE" desc="The title of a dialog that tells users that a browser relaunch is recommended for an update available for some number of days.">
             {0, plural,
@@ -1079,7 +1079,7 @@ Google Chrome is unable to recover your settings.
       </if>
 
       <!-- Chrome launch blocking dialog. -->
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_TOOLTIP" desc="The information message of Chrome launch blocking dialog for machine level user cloud policy enrollment.">
           Launching Chrome...
         </message>
@@ -1095,7 +1095,7 @@ Google Chrome is unable to recover your settings.
       </message>
 
       <!-- User happiness tracking survey UI -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_HATS_BUBBLE_TITLE" translateable="false" desc="The title of Happiness Tracking Survey's invitation banner, it invites users to take a survey">
           Take a quick survey
         </message>
diff --git a/chrome/app/profiles_strings.grdp b/chrome/app/profiles_strings.grdp
index 55616292b527..3a3868b880a8 100644
--- a/chrome/app/profiles_strings.grdp
+++ b/chrome/app/profiles_strings.grdp
@@ -456,18 +456,13 @@
     <message name="IDS_SYNC_USER_NAME_IN_USE_ERROR" desc="Mobile: An error message shown when a user tries to sign in to sync using a user name that's already in use by another profile.">
       This account is already being used on this device.
     </message>
-  </if>
-  <if expr="not is_android">
-    <message name="IDS_SYNC_USER_NAME_IN_USE_ERROR" desc="An error message shown when a user tries to sign in to sync using a user name that's already in use by another profile.">
-      This account is already being used on this computer.
-    </message>
     <message name="IDS_SYNC_USER_NAME_IN_USE_BY_ERROR" desc="An error message shown when a user tries to sign in to sync using a user name that's already in use by another profile. This error message includes the avatar name of the existing duplicate profile and only appears in the signin error tab modal dialog.">
-      This account is already being used on this computer by <ph name="AVATAR_NAME">$1<ex>Jane</ex></ph>.
+      This account is already being used on this device by <ph name="AVATAR_NAME">$1<ex>Jane</ex></ph>.
     </message>
   </if>
 
   <!-- Android does not support multiple profiles and supervised users -->
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <!-- Create Profile Dialog -->
     <message name="IDS_PROFILES_CREATE_TITLE" desc="Title of the create profile dialog">
       Add person
@@ -500,7 +495,7 @@
     </message>
   </if>
 
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <!-- User manager web UI -->
     <if expr="use_titlecase">
       <message name="IDS_ADD_USER_BUTTON" desc="Text shown on an add user button on login/locker screen">
diff --git a/chrome/app/theme/theme_resources.grd b/chrome/app/theme/theme_resources.grd
index 7b6f1aee39f3..f4b6823d6470 100644
--- a/chrome/app/theme/theme_resources.grd
+++ b/chrome/app/theme/theme_resources.grd
@@ -25,10 +25,10 @@
       <!-- KEEP THESE IN ALPHABETICAL ORDER!  DO NOT ADD TO RANDOM PLACES JUST
            BECAUSE YOUR RESOURCES ARE FUNCTIONALLY RELATED OR FALL UNDER THE
            SAME CONDITIONALS. -->
-      <if expr="is_linux or is_win or chromeos">
+      <if expr="is_android or is_linux or is_win or chromeos">
         <structure type="chrome_scaled_image" name="IDR_ACCESSIBILITY_CAPTIONS_PREVIEW_BACKGROUND" file="common/captions-preview-bg.png" />
       </if>
-      <if expr="toolkit_views and not is_macosx">
+      <if expr="is_android or toolkit_views and not is_macosx">
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE" file="common/app_window_close.png" />
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE_H" file="common/app_window_close_hover.png" />
         <structure type="chrome_scaled_image" name="IDR_APP_WINDOW_CLOSE_P" file="common/app_window_close_active.png" />
@@ -70,7 +70,7 @@
       <if expr="is_win">
         <structure type="chrome_scaled_image" name="IDR_BOOKMARK_BAR_FOLDER_MANAGED" file="win/bookmark_bar_folder_managed.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_BOOKMARK_BAR_APPS_SHORTCUT" file="common/apps_bookmark_bar_icon.png" />
         <structure type="chrome_scaled_image" name="IDR_BOOKMARKS_FAVICON" file="common/favicon_bookmarks.png" />
       </if>
@@ -78,7 +78,7 @@
         <structure type="chrome_scaled_image" name="IDR_BUTTON_USER_IMAGE_CHOOSE_FILE" file="cros/choose_file.png" />
         <structure type="chrome_scaled_image" name="IDR_BUTTON_USER_IMAGE_TAKE_PHOTO" file="cros/take_photo.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
       <!-- Note: Tab close buttons are not traditional buttons.  Tab close buttons
            fill a background with a color from the theme and tile IDR_CLOSE_1 over it.
            See chrome/browser/ui/views/tabs/tab.cc -->
@@ -94,7 +94,7 @@
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_DEVICE_DISABLED" file="cros/device_disabled.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_DOWNLOADS_FAVICON" file="common/favicon_downloads.png" />
         <structure type="chrome_scaled_image" name="IDR_ERROR_NETWORK_OFFLINE" file="common/error_network_offline.png" />
       </if>
@@ -132,7 +132,7 @@
       <if expr="_google_chrome">
         <structure type="chrome_scaled_image" name="IDR_GOOGLE_ICON" file="google_chrome/google_icon.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_HELP_MENU" file="common/help_16.png" />
         <structure type="chrome_scaled_image" name="IDR_HIDE_PASSWORD_HOVER" file="common/hide_password_hover.png" />
         <if expr="not chromeos">
@@ -148,7 +148,7 @@
       <if expr="enable_service_discovery">
         <structure type="chrome_scaled_image" name="IDR_LOCAL_DISCOVERY_CLOUDPRINT_ICON" file="common/cloudprint.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_MANAGEMENT_FAVICON" file="common/favicon_management.png" />
         <structure type="chrome_scaled_image" name="IDR_MAXIMIZE_BUTTON_MASK" file="common/maximize_button_mask.png" />
         <structure type="chrome_scaled_image" name="IDR_MINIMIZE_BUTTON_MASK" file="common/minimize_button_mask.png" />
@@ -159,7 +159,7 @@
         <structure type="chrome_scaled_image" name="IDR_NOTIFICATION_EASYUNLOCK_ENABLED" file="cros/notification_easyunlock_enabled.png" />
       </if>
       <structure type="chrome_scaled_image" name="IDR_PLUGINS_FAVICON" file="common/favicon_extensions.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_PRERENDER" file="common/prerender_succeed_icon.png" />
       </if>
       <if expr="not _google_chrome">
@@ -242,14 +242,14 @@
         <structure type="chrome_scaled_image" name="IDR_PROFILE_AVATAR_55" file="common/modern_avatars/abstract/avatar_sandwich.png" />
       </if>
       <structure type="chrome_scaled_image" name="IDR_PROFILE_AVATAR_PLACEHOLDER_LARGE" file="common/profile_avatar_placeholder_large.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_PROFILES_DICE_TURN_ON_SYNC" file="common/turn_on_sync_illustration.png" />
       </if>
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_RESET_WARNING" file="cros/reset_warning.png" />
       </if>
       <structure type="chrome_scaled_image" name="IDR_RESTORE_BUTTON_MASK" file="common/restore_button_mask.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_SAFETY_TIP_LOOKALIKE_ILLUSTRATION_DARK" file="common/safety_tip_lookalike_illustration_dark.png" />
         <structure type="chrome_scaled_image" name="IDR_SAFETY_TIP_LOOKALIKE_ILLUSTRATION_LIGHT" file="common/safety_tip_lookalike_illustration_light.png" />
         <structure type="chrome_scaled_image" name="IDR_SAFETY_TIP_SUSPICIOUS_ILLUSTRATION_DARK" file="common/safety_tip_suspicious_illustration_dark.png" />
@@ -265,7 +265,7 @@
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_SECONDARY_USER_SETTINGS" file="cros/secondary_user_settings.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_SETTINGS_FAVICON" file="common/favicon_settings.png" />
         <structure type="chrome_scaled_image" name="IDR_SHOW_PASSWORD_HOVER" file="common/show_password_hover.png" />
       </if>
@@ -287,7 +287,7 @@
       <if expr="chromeos">
         <structure type="chrome_scaled_image" name="IDR_TAB_RECORDING_INDICATOR" file="cros/tab_recording_indicator.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_COOKIE_BLOCKING_ON_HEADER" file="common/cookie_blocking_on_header.png" />
         <structure type="chrome_scaled_image" name="IDR_COOKIE_BLOCKING_OFF_HEADER" file="common/cookie_blocking_off_header.png" />
       </if>
@@ -327,7 +327,7 @@
       <structure type="chrome_scaled_image" name="IDR_THEME_WINDOW_CONTROL_BACKGROUND" file="notused.png" />
       <structure type="chrome_scaled_image" name="IDR_TRANSLATE_BUBBLE_ICON" file="common/translate_bubble_icon.png" />
       <if expr="not _google_chrome">
-        <if expr="not is_android">
+        <if expr="is_android or not is_android">
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON" file="chromium/webstore_icon.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_16" file="chromium/webstore_icon_16.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_24" file="chromium/webstore_icon_24.png" />
@@ -335,7 +335,7 @@
         </if>
       </if>
       <if expr="_google_chrome">
-        <if expr="not is_android">
+        <if expr="is_android or not is_android">
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON" file="google_chrome/webstore_icon.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_16" file="google_chrome/webstore_icon_16.png" />
           <structure type="chrome_scaled_image" name="IDR_WEBSTORE_ICON_24" file="google_chrome/webstore_icon_24.png" />
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index d5684b2e3301..7ec580ca4241 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -407,7 +407,6 @@ jumbo_static_library("browser") {
     "download/download_core_service_factory.h",
     "download/download_core_service_impl.cc",
     "download/download_core_service_impl.h",
-    "download/download_crx_util_android.cc",
     "download/download_file_picker.cc",
     "download/download_file_picker.h",
     "download/download_history.cc",
@@ -1221,6 +1220,8 @@ jumbo_static_library("browser") {
     "plugins/pdf_plugin_placeholder_observer.h",
     "policy/browser_dm_token_storage.cc",
     "policy/browser_dm_token_storage.h",
+    "policy/browser_dm_token_storage_android.cc",
+    "policy/browser_dm_token_storage_android.h",
     "policy/browser_dm_token_storage_linux.cc",
     "policy/browser_dm_token_storage_linux.h",
     "policy/browser_dm_token_storage_mac.h",
@@ -1567,7 +1568,6 @@ jumbo_static_library("browser") {
     "sessions/session_common_utils.h",
     "sessions/session_data_deleter.cc",
     "sessions/session_data_deleter.h",
-    "sessions/session_restore_android.cc",
     "sessions/session_tab_helper.cc",
     "sessions/session_tab_helper.h",
     "sessions/tab_restore_service_factory.cc",
@@ -3011,7 +3011,8 @@ jumbo_static_library("browser") {
       ]
       deps += [ "//chrome/android/modules/dev_ui/provider:native" ]
     }
-  } else {  # !is_android
+  }
+  if (true) {  # !is_android
     sources += [
       "accessibility/invert_bubble_prefs.cc",
       "accessibility/invert_bubble_prefs.h",
@@ -3059,12 +3060,6 @@ jumbo_static_library("browser") {
       "badging/badge_manager_delegate.h",
       "badging/badge_manager_factory.cc",
       "badging/badge_manager_factory.h",
-      "banners/app_banner_manager_desktop.cc",
-      "banners/app_banner_manager_desktop.h",
-      "bluetooth/bluetooth_chooser_context.cc",
-      "bluetooth/bluetooth_chooser_context.h",
-      "bluetooth/bluetooth_chooser_context_factory.cc",
-      "bluetooth/bluetooth_chooser_context_factory.h",
       "bookmarks/bookmark_html_writer.cc",
       "bookmarks/bookmark_html_writer.h",
       "certificate_viewer.h",
@@ -3295,7 +3290,6 @@ jumbo_static_library("browser") {
       "metrics/desktop_session_duration/desktop_session_duration_tracker.h",
       "metrics/first_web_contents_profiler.cc",
       "metrics/first_web_contents_profiler.h",
-      "metrics/incognito_observer_desktop.cc",
       "metrics/tab_stats_data_store.cc",
       "metrics/tab_stats_data_store.h",
       "metrics/tab_stats_tracker.cc",
@@ -3308,6 +3302,7 @@ jumbo_static_library("browser") {
       "notifications/profile_notification.cc",
       "notifications/profile_notification.h",
       "obsolete_system/obsolete_system.h",
+      "obsolete_system/obsolete_system_android.cc",
       "obsolete_system/obsolete_system_linux.cc",
       "obsolete_system/obsolete_system_mac.cc",
       "obsolete_system/obsolete_system_win.cc",
@@ -3676,7 +3671,7 @@ jumbo_static_library("browser") {
         "chrome_browser_main_posix.h",
         "first_run/first_run_internal_posix.cc",
         "importer/firefox_profile_lock_posix.cc",
-        "process_singleton_posix.cc",
+#        "process_singleton_posix.cc",
         "task_manager/sampling/shared_sampler_posix.cc",
       ]
     }
@@ -4142,7 +4137,7 @@ jumbo_static_library("browser") {
     defines += [ "USE_CRAS" ]
   }
 
-  if (!is_android && !is_chromeos) {
+  if (true || (!is_android && !is_chromeos)) {
     sources += [
       "first_run/upgrade_util.cc",
       "first_run/upgrade_util.h",
@@ -4165,14 +4160,6 @@ jumbo_static_library("browser") {
       "notifications/screen_lock_notification_blocker.cc",
       "notifications/screen_lock_notification_blocker.h",
       "platform_util.cc",
-      "policy/chrome_browser_cloud_management_controller.cc",
-      "policy/chrome_browser_cloud_management_controller.h",
-      "policy/chrome_browser_cloud_management_register_watcher.cc",
-      "policy/chrome_browser_cloud_management_register_watcher.h",
-      "policy/cloud/chrome_browser_cloud_management_helper.cc",
-      "policy/cloud/chrome_browser_cloud_management_helper.h",
-      "policy/cloud/user_policy_signin_service.cc",
-      "policy/cloud/user_policy_signin_service.h",
       "policy/cloud/user_policy_signin_service_internal.h",
       "profiles/avatar_menu.cc",
       "profiles/avatar_menu.h",
@@ -4202,7 +4189,8 @@ jumbo_static_library("browser") {
       "upgrade_detector/upgrade_detector_impl.cc",
       "upgrade_detector/upgrade_detector_impl.h",
     ]
-  } else {
+  }
+  if (true) {
     sources += [
       "media/protected_media_identifier_permission_context.cc",
       "media/protected_media_identifier_permission_context.h",
@@ -4265,6 +4253,10 @@ jumbo_static_library("browser") {
     deps += [ "//ui/views" ]
   }
 
+  sources += [
+    "download/drag_download_item_android.cc",
+  ]
+
   if (use_aura) {
     # Cross-platform Aura files.
     sources += [
@@ -4297,6 +4289,7 @@ jumbo_static_library("browser") {
       "background/background_application_list_model.h",
       "background/background_mode_manager.cc",
       "background/background_mode_manager.h",
+      "background/background_mode_manager_android.cc",
       "background/background_mode_manager_aura.cc",
       "background/background_mode_manager_chromeos.cc",
       "background/background_mode_manager_mac.mm",
@@ -5067,7 +5060,7 @@ jumbo_static_library("browser") {
     }
   }
 
-  if (enable_session_service) {
+  if (true || enable_session_service) {
     sources += [
       "sessions/session_restore.cc",
       "sessions/session_restore.h",
@@ -5438,7 +5431,7 @@ grit("resources") {
     }
   }
 
-  if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+  if (true || is_win || is_mac || is_desktop_linux || is_chromeos) {
     deps += [
       "//chrome/browser/resources/discards:discards_resources_gen",
       "//chrome/browser/resources/management:polymer3_elements",
@@ -5471,7 +5464,7 @@ grit("resources") {
     ]
   }
 
-  if (is_chromeos && optimize_webui) {
+  if (false && optimize_webui) {
     deps += [
       "//chrome/browser/resources/chromeos/bluetooth_pairing_dialog:build",
       "//chrome/browser/resources/chromeos/internet_config_dialog:build",
diff --git a/chrome/browser/apps/platform_apps/BUILD.gn b/chrome/browser/apps/platform_apps/BUILD.gn
index 37975f0e9c3e..5cdc8a4ca2b5 100644
--- a/chrome/browser/apps/platform_apps/BUILD.gn
+++ b/chrome/browser/apps/platform_apps/BUILD.gn
@@ -47,7 +47,6 @@ source_set("platform_apps") {
   deps = [
     "//chrome/app:command_ids",
     "//chrome/browser/extensions",
-    "//chrome/browser/media/router/discovery",
     "//chrome/browser/web_applications/extensions",
     "//chrome/common",
     "//components/crx_file",
diff --git a/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn b/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
index 3a47764325bb..f69743907dcd 100644
--- a/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/BUILD.gn
@@ -13,6 +13,7 @@ source_set("music_manager_private") {
     "device_id.cc",
     "device_id.h",
     "device_id_chromeos.cc",
+    "device_id_android.cc",
     "device_id_linux.cc",
     "device_id_mac.cc",
     "device_id_win.cc",
diff --git a/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc
new file mode 100644
index 000000000000..b5e1b2b68156
--- /dev/null
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc
@@ -0,0 +1,188 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/apps/platform_apps/api/music_manager_private/device_id.h"
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  // Must be included before ifaddrs.h.
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/task/post_task.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace chrome_apps {
+namespace api {
+
+namespace {
+
+typedef base::Callback<bool(const void* bytes, size_t size)>
+    IsValidMacAddressCallback;
+
+const char kDiskByUuidDirectoryName[] = "/dev/disk/by-uuid";
+const char* const kDeviceNames[] = {
+    "sda1", "hda1", "dm-0", "xvda1", "sda2", "hda2", "dm-1", "xvda2",
+};
+
+// Map from device name to disk uuid
+typedef std::map<base::FilePath, base::FilePath> DiskEntries;
+
+std::string GetDiskUuid() {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  DiskEntries disk_uuids;
+  base::FileEnumerator files(base::FilePath(kDiskByUuidDirectoryName),
+                             false,  // Recursive.
+                             base::FileEnumerator::FILES);
+  do {
+    base::FilePath file_path = files.Next();
+    if (file_path.empty())
+      break;
+
+    base::FilePath target_path;
+    if (!base::ReadSymbolicLink(file_path, &target_path))
+      continue;
+
+    base::FilePath device_name = target_path.BaseName();
+    base::FilePath disk_uuid = file_path.BaseName();
+    disk_uuids[device_name] = disk_uuid;
+  } while (true);
+
+  // Look for first device name matching an entry of |kDeviceNames|.
+  std::string result;
+  for (size_t i = 0; i < base::size(kDeviceNames); i++) {
+    DiskEntries::iterator it = disk_uuids.find(base::FilePath(kDeviceNames[i]));
+    if (it != disk_uuids.end()) {
+      DVLOG(1) << "Returning uuid: \"" << it->second.value()
+               << "\" for device \"" << it->first.value() << "\"";
+      result = it->second.value();
+      break;
+    }
+  }
+
+  // Log failure (at most once) for diagnostic purposes.
+  static bool error_logged = false;
+  if (result.empty() && !error_logged) {
+    error_logged = true;
+    LOG(ERROR) << "Could not find appropriate disk uuid.";
+    for (DiskEntries::iterator it = disk_uuids.begin(); it != disk_uuids.end();
+         ++it) {
+      LOG(ERROR) << "  DeviceID=" << it->first.value()
+                 << ", uuid=" << it->second.value();
+    }
+  }
+
+  return result;
+}
+
+class MacAddressProcessor {
+ public:
+  explicit MacAddressProcessor(
+      const IsValidMacAddressCallback& is_valid_mac_address)
+      : is_valid_mac_address_(is_valid_mac_address) {}
+
+  bool ProcessInterface(struct ifaddrs* ifaddr,
+                        const char* const prefixes[],
+                        size_t prefixes_count) {
+    const int MAC_LENGTH = 6;
+    struct ifreq ifinfo;
+
+    memset(&ifinfo, 0, sizeof(ifinfo));
+    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
+
+    int sd = socket(AF_INET, SOCK_DGRAM, 0);
+    int result = ioctl(sd, SIOCGIFHWADDR, &ifinfo);
+    close(sd);
+
+    if (result != 0)
+      return true;
+
+    const char* mac_address =
+        static_cast<const char*>(ifinfo.ifr_hwaddr.sa_data);
+    if (!is_valid_mac_address_.Run(mac_address, MAC_LENGTH))
+      return true;
+
+    if (!IsValidPrefix(ifinfo.ifr_name, prefixes, prefixes_count))
+      return true;
+
+    // Got one!
+    found_mac_address_ =
+        base::ToLowerASCII(base::HexEncode(mac_address, MAC_LENGTH));
+    return false;
+  }
+
+  std::string mac_address() const { return found_mac_address_; }
+
+ private:
+  bool IsValidPrefix(const char* name,
+                     const char* const prefixes[],
+                     size_t prefixes_count) {
+    for (size_t i = 0; i < prefixes_count; i++) {
+      if (strncmp(prefixes[i], name, strlen(prefixes[i])) == 0)
+        return true;
+    }
+    return false;
+  }
+
+  const IsValidMacAddressCallback& is_valid_mac_address_;
+  std::string found_mac_address_;
+};
+
+std::string GetMacAddress(
+    const IsValidMacAddressCallback& is_valid_mac_address) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  int rv = -1;
+  if (rv < 0) {
+    PLOG(ERROR) << "getifaddrs failed " << rv;
+    return "";
+  }
+
+  MacAddressProcessor processor(is_valid_mac_address);
+  return processor.mac_address();
+}
+
+void GetRawDeviceIdImpl(const IsValidMacAddressCallback& is_valid_mac_address,
+                        const DeviceId::IdCallback& callback) {
+  std::string disk_id = GetDiskUuid();
+  std::string mac_address = GetMacAddress(is_valid_mac_address);
+
+  std::string raw_device_id;
+  if (!mac_address.empty() && !disk_id.empty()) {
+    raw_device_id = mac_address + disk_id;
+  }
+
+  base::PostTask(FROM_HERE, {content::BrowserThread::UI},
+                 base::BindOnce(callback, raw_device_id));
+}
+
+}  // namespace
+
+// static
+void DeviceId::GetRawDeviceId(const IdCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::PostTask(
+      FROM_HERE, traits(),
+      base::BindOnce(&GetRawDeviceIdImpl,
+                     base::Bind(&DeviceId::IsValidMacAddress), callback));
+}
+
+}  // namespace api
+}  // namespace chrome_apps
diff --git a/chrome/browser/background/background_contents_service_factory.cc b/chrome/browser/background/background_contents_service_factory.cc
index f866434c509e..81653e7dcfa1 100644
--- a/chrome/browser/background/background_contents_service_factory.cc
+++ b/chrome/browser/background/background_contents_service_factory.cc
@@ -32,8 +32,10 @@ BackgroundContentsServiceFactory::BackgroundContentsServiceFactory()
     : BrowserContextKeyedServiceFactory(
           "BackgroundContentsService",
           BrowserContextDependencyManager::GetInstance()) {
+#if 0
   DependsOn(extensions::ExtensionRegistryFactory::GetInstance());
   DependsOn(extensions::ExtensionSystemFactory::GetInstance());
+#endif
 }
 
 BackgroundContentsServiceFactory::~BackgroundContentsServiceFactory() {}
@@ -46,6 +48,7 @@ KeyedService* BackgroundContentsServiceFactory::BuildServiceInstanceFor(
 
 void BackgroundContentsServiceFactory::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* user_prefs) {
+  LOG(ERROR) << "[Kiwi] BackgroundContentsServiceFactory::RegisterProfilePrefs";
   user_prefs->RegisterDictionaryPref(prefs::kRegisteredBackgroundContents);
 }
 
diff --git a/chrome/browser/background/background_mode_manager.cc b/chrome/browser/background/background_mode_manager.cc
index 4b1cbb53aaed..91179fb90e13 100644
--- a/chrome/browser/background/background_mode_manager.cc
+++ b/chrome/browser/background/background_mode_manager.cc
@@ -564,7 +564,6 @@ void BackgroundModeManager::ExecuteCommand(int command_id, int event_flags) {
     case IDC_EXIT:
       RecordMenuItemClick(MENU_ITEM_EXIT);
       base::RecordAction(UserMetricsAction("Exit"));
-      chrome::CloseAllBrowsers();
       break;
     case IDC_STATUS_TRAY_KEEP_CHROME_RUNNING_IN_BACKGROUND: {
       // Background mode must already be enabled (as otherwise this menu would
diff --git a/chrome/browser/background/background_mode_manager_android.cc b/chrome/browser/background/background_mode_manager_android.cc
new file mode 100644
index 000000000000..7a88d95dc624
--- /dev/null
+++ b/chrome/browser/background/background_mode_manager_android.cc
@@ -0,0 +1,24 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/background/background_mode_manager.h"
+
+#include "base/sequenced_task_runner.h"
+
+// No background jobs for aura for now.
+
+void BackgroundModeManager::EnableLaunchOnStartup(bool should_launch) {
+  NOTIMPLEMENTED();
+}
+
+void BackgroundModeManager::DisplayClientInstalledNotification(
+    const base::string16& name) {
+  NOTIMPLEMENTED();
+}
+
+// static
+scoped_refptr<base::SequencedTaskRunner>
+BackgroundModeManager::CreateTaskRunner() {
+  return nullptr;
+}
diff --git a/chrome/browser/browser_process_impl.cc b/chrome/browser/browser_process_impl.cc
index 554dacc43ed2..629f68c43a6d 100644
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -240,6 +240,7 @@ BrowserProcessImpl::BrowserProcessImpl(StartupData* startup_data) {
 }
 
 void BrowserProcessImpl::Init() {
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 1";
 #if defined(OS_CHROMEOS)
   // Forces creation of |metrics_services_manager_client_| if neccessary
   // (typically this call is a no-op as MetricsServicesManager has already been
@@ -268,13 +269,16 @@ void BrowserProcessImpl::Init() {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::AppWindowClient::Set(ChromeAppWindowClient::GetInstance());
 
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 2";
   extension_event_router_forwarder_ =
       base::MakeRefCounted<extensions::EventRouterForwarder>();
 
   EnsureExtensionsClientInitialized();
 
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 3";
   extensions_browser_client_ =
       std::make_unique<extensions::ChromeExtensionsBrowserClient>();
+  LOG(ERROR) << "BrowserProcessImpl::Init - Step 4: " << extensions_browser_client_;
   extensions_browser_client_->AddAPIProvider(
       std::make_unique<chrome_apps::ChromeAppsBrowserAPIProvider>());
   extensions::ExtensionsBrowserClient::Set(extensions_browser_client_.get());
diff --git a/chrome/browser/browser_resources.grd b/chrome/browser/browser_resources.grd
index 1deaa699ca4d..4dbf5edc9776 100644
--- a/chrome/browser/browser_resources.grd
+++ b/chrome/browser/browser_resources.grd
@@ -8,18 +8,17 @@
   </outputs>
   <release seq="1">
     <structures>
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
         <structure name="IDR_SIGNIN_SHARED_CSS_JS" file="${root_gen_dir}\chrome\browser\resources\signin\signin_shared_css.js" use_base_dir="false" preprocess="true" type="chrome_html" />
         <structure name="IDR_SIGNIN_SHARED_OLD_CSS_HTML" file="resources\signin\signin_shared_old_css.html" preprocess="true" allowexternalscript="true" type="chrome_html" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- New Tab Page WebUI. -->
         <structure name="IDR_INCOGNITO_TAB_HTML" file="resources\ntp4\incognito_tab.html" compress="gzip" flattenhtml="true" type="chrome_html" />
         <structure name="IDR_GUEST_TAB_HTML" file="resources\ntp4\guest_tab.html" compress="gzip" flattenhtml="true" type="chrome_html" />
         <structure name="IDR_NEW_INCOGNITO_TAB_THEME_CSS" file="resources\ntp4\new_incognito_tab_theme.css" compress="gzip" flattenhtml="true" type="chrome_html" />
         <structure name="IDR_NEW_TAB_4_HTML" file="resources\ntp4\new_tab.html" compress="gzip" flattenhtml="true" type="chrome_html" />
         <structure name="IDR_NEW_TAB_4_THEME_CSS" file="resources\ntp4\new_tab_theme.css" compress="gzip" flattenhtml="true" type="chrome_html" />
-
       </if>
       <if expr="chromeos">
         <structure name="IDR_FIRST_RUN_HTML" file="resources\chromeos\first_run\first_run.html" compress="gzip" flattenhtml="true" type="chrome_html" />
@@ -41,7 +40,7 @@
       </if>
     </structures>
     <includes>
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
         <include name="IDR_DISCARDS_MOJO_API_JS" file="resources\discards\mojo_api.js" compress="gzip" type="BINDATA" />
         <include name="IDR_DISCARDS_DATABASE_TAB_JS" file="${root_gen_dir}\chrome\browser\resources\discards\database_tab.js" use_base_dir="false" compress="gzip" type="BINDATA" />
         <include name="IDR_DISCARDS_DISCARDS_MAIN_JS" file="${root_gen_dir}\chrome\browser\resources\discards\discards_main.js" use_base_dir="false" compress="gzip" type="BINDATA" />
@@ -54,7 +53,7 @@
         <include name="IDR_DISCARDS_MOJO_PUBLIC_BASE_PROCESS_ID_MOJOM_LITE_JS" file="${root_gen_dir}\mojo\public\mojom\base\process_id.mojom-lite.js" compress="gzip" use_base_dir="false" type="BINDATA" />
         <include name="IDR_DISCARDS_SORTED_TABLE_BEHAVIOR_JS" file="resources\discards\sorted_table_behavior.js" compress="gzip" type="BINDATA" />
       </if>
-      <if expr="is_win or is_macosx or (is_linux and not is_chromeos)">
+      <if expr="is_android or is_win or is_macosx or (is_linux and not is_chromeos)">
         <include name="IDR_BROWSER_SWITCH_APP_JS" file="${root_gen_dir}\chrome\browser\resources\browser_switch\app.js" compress="gzip" use_base_dir="false" type="BINDATA" />
         <include name="IDR_BROWSER_SWITCH_PROXY_JS" file="resources\browser_switch\browser_switch_proxy.js" compress="gzip" type="BINDATA" />
         <include name="IDR_BROWSER_SWITCH_HTML" file="resources\browser_switch\browser_switch.html" compress="gzip" allowexternalscript="true" type="BINDATA" />
@@ -70,7 +69,7 @@
         <include name="IDR_ABOUT_NACL_CSS" file="resources\about_nacl\about_nacl.css" compress="gzip" flattenhtml="true" type="chrome_html" />
         <include name="IDR_ABOUT_NACL_JS" file="resources\about_nacl\about_nacl.js" compress="gzip" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_ABOUT_SYS_HTML" file="resources\about_sys\about_sys.html" compress="gzip" type="BINDATA" />
         <include name="IDR_ABOUT_SYS_CSS" file="resources\about_sys\about_sys.css" compress="gzip" flattenhtml="true" type="BINDATA" />
         <include name="IDR_ABOUT_SYS_JS" file="resources\about_sys\about_sys.js" compress="gzip" type="BINDATA" />
@@ -163,7 +162,7 @@
         <include name="IDR_APP_MANAGEMENT_INDEX_HTML" file="resources\app_management\index.html" compress="gzip" type="BINDATA" />
       </if>
 
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <!-- Page not available for guest. -->
         <include name="IDR_PAGE_NOT_AVAILABLE_FOR_GUEST_APP_HTML" file="resources\page_not_available_for_guest\app.html" type="BINDATA" />
       </if>
@@ -213,10 +212,10 @@
       <if expr="chromeos">
         <include name="IDR_PLUGIN_DB_JSON" file="resources\plugin_metadata\plugins_chromeos.json" type="BINDATA" />
       </if>
-      <if expr="desktop_linux">
+      <if expr="is_android or desktop_linux">
         <include name="IDR_PLUGIN_DB_JSON" file="resources\plugin_metadata\plugins_linux.json" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_MANAGEMENT_HTML" file="resources\management\management.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" compress="gzip" />
         <include name="IDR_MANAGEMENT_UI_JS" file="${root_gen_dir}/chrome/browser/resources/management/management_ui.js" use_base_dir="false" type="BINDATA" compress="gzip" preprocess="true" />
         <include name="IDR_MANAGEMENT_BROWSER_PROXY_JS" file="resources\management\management_browser_proxy.js" type="BINDATA" compress="gzip" preprocess="true" />
@@ -226,7 +225,7 @@
       <include name="IDR_SITE_ENGAGEMENT_JS" file="resources\engagement\site_engagement.js" flattenhtml="true" type="BINDATA" compress="gzip" />
       <include name="IDR_SITE_ENGAGEMENT_DETAILS_MOJOM_LITE_JS" file="${root_gen_dir}\chrome\browser\engagement\site_engagement_details.mojom-lite.js" use_base_dir="false" type="BINDATA" compress="gzip" />
       <include name="IDR_URL_MOJOM_LITE_JS" file="${root_gen_dir}\url\mojom\url.mojom-lite.js" use_base_dir="false" type="BINDATA" compress="gzip" />
-      <if expr="is_win or is_macosx or desktop_linux or chromeos">
+      <if expr="is_android or is_win or is_macosx or desktop_linux or chromeos">
         <include name="IDR_SYNC_DISABLED_CONFIRMATION_HTML" file="resources\signin\sync_confirmation\sync_disabled_confirmation.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
         <include name="IDR_SYNC_DISABLED_CONFIRMATION_JS" file="resources\signin\sync_confirmation\sync_disabled_confirmation.js" type="BINDATA" />
         <include name="IDR_SYNC_CONFIRMATION_HTML" file="resources\signin\sync_confirmation\sync_confirmation.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
@@ -236,7 +235,7 @@
         <include name="IDR_SYNC_CONFIRMATION_IMAGES_SYNC_CONFIRMATION_ILLUSTRATION_SVG" file="resources\signin\sync_confirmation\images\sync_confirmation_illustration.svg" type="BINDATA" compress="gzip" />
         <include name="IDR_SYNC_CONFIRMATION_IMAGES_SYNC_CONFIRMATION_ILLUSTRATION_DARK_SVG" file="resources\signin\sync_confirmation\images\sync_confirmation_illustration_dark.svg" type="BINDATA" compress="gzip" />
       </if>
-      <if expr="is_win or is_macosx or desktop_linux">
+      <if expr="is_android or is_win or is_macosx or desktop_linux">
         <include name="IDR_SIGNIN_EMAIL_CONFIRMATION_HTML" file="resources\signin\signin_email_confirmation\signin_email_confirmation.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
         <include name="IDR_SIGNIN_EMAIL_CONFIRMATION_APP_JS" file="${root_gen_dir}\chrome\browser\resources\signin\signin_email_confirmation\signin_email_confirmation_app.js" use_base_dir="false" preprocess="true" type="BINDATA" />
         <include name="IDR_SIGNIN_ERROR_HTML" file="resources\signin\signin_error\signin_error.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" />
@@ -344,7 +343,7 @@
         <include name="IDR_QUICKOFFICE_MANIFEST" file="resources\chromeos\quickoffice\manifest.json" type="BINDATA" />
         <include name="IDR_PRODUCT_CHROMEOS_SYNC_CONSENT_SCREEN_ICONS" file="internal\resources\chromeos-sync-consent-icons.html" type="BINDATA" />
       </if>
-      <if expr="not is_android and not chromeos">
+      <if expr="is_android or not is_android and not chromeos">
         <include name="IDR_CONTROL_BAR_HTML" file="resources\user_manager\control_bar.html" type="BINDATA" />
         <include name="IDR_CONTROL_BAR_JS" file="resources\user_manager\control_bar.js" type="BINDATA" />
         <include name="IDR_CREATE_PROFILE_HTML" file="resources\user_manager\create_profile.html" type="BINDATA" />
@@ -362,7 +361,7 @@
         <include name="IDR_USER_MANAGER_TUTORIAL_HTML" file="resources\user_manager\user_manager_tutorial.html" type="BINDATA" />
         <include name="IDR_USER_MANAGER_TUTORIAL_JS" file="resources\user_manager\user_manager_tutorial.js" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_IDENTITY_INTERNALS_HTML" file="resources\identity_internals\identity_internals.html" compress="gzip" type="BINDATA" />
         <include name="IDR_IDENTITY_INTERNALS_CSS" file="resources\identity_internals\identity_internals.css" compress="gzip" type="BINDATA" />
         <include name="IDR_IDENTITY_INTERNALS_JS" file="resources\identity_internals\identity_internals.js" compress="gzip" type="BINDATA" />
@@ -442,7 +441,7 @@
         </if>
         <include name="IDR_BRAILLE_MANIFEST" file="resources\chromeos\accessibility\braille_ime\manifest.json" type="BINDATA" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_MEDIA_ROUTER_INTERNALS_HTML" file="resources\media_router\media_router_internals.html" compress="gzip" type="BINDATA" />
         <include name="IDR_MEDIA_ROUTER_INTERNALS_CSS" file="resources\media_router\media_router_internals.css" compress="gzip" type="BINDATA" />
         <include name="IDR_MEDIA_ROUTER_INTERNALS_JS" file="resources\media_router\media_router_internals.js" compress="gzip" type="BINDATA" />
@@ -503,7 +502,7 @@
         <include name="IDR_RESET_PASSWORD_JS" file="resources\reset_password\reset_password.js" type="BINDATA" compress="gzip" />
         <include name="IDR_RESET_PASSWORD_MOJOM_LITE_JS" file="${root_gen_dir}\chrome\browser\ui\webui\reset_password\reset_password.mojom-lite.js" use_base_dir="false" type="BINDATA" compress="gzip" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_TAB_RANKER_EXAMPLE_PREPROCESSOR_CONFIG_PB" file="resource_coordinator\tab_ranker\example_preprocessor_config.pb" type="BINDATA" />
         <include name="IDR_TAB_RANKER_PAIRWISE_EXAMPLE_PREPROCESSOR_CONFIG_PB" file="resource_coordinator\tab_ranker\pairwise_preprocessor_config.pb" type="BINDATA" />
       </if>
diff --git a/chrome/browser/chrome_browser_main.cc b/chrome/browser/chrome_browser_main.cc
index 5f4fd7f66362..29b0fd1173c3 100644
--- a/chrome/browser/chrome_browser_main.cc
+++ b/chrome/browser/chrome_browser_main.cc
@@ -847,9 +847,11 @@ int ChromeBrowserMainParts::PreEarlyInitialization() {
 }
 
 void ChromeBrowserMainParts::PostEarlyInitialization() {
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainParts::PostEarlyInitialization - Step 1";
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::PostEarlyInitialization");
   for (size_t i = 0; i < chrome_extra_parts_.size(); ++i)
     chrome_extra_parts_[i]->PostEarlyInitialization();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainParts::PostEarlyInitialization - Step 2";
 }
 
 void ChromeBrowserMainParts::ToolkitInitialized() {
@@ -888,6 +890,7 @@ void ChromeBrowserMainParts::PostMainMessageLoopStart() {
 }
 
 int ChromeBrowserMainParts::PreCreateThreads() {
+LOG(ERROR) << "[Kiwi] ChromeBrowserMainParts::PreCreateThreads - Step 1";
   // IMPORTANT
   // Calls in this function should not post tasks or create threads as
   // components used to handle those tasks are not yet available. This work
@@ -995,18 +998,22 @@ int ChromeBrowserMainParts::ApplyFirstRunPrefs() {
 }
 
 int ChromeBrowserMainParts::PreCreateThreadsImpl() {
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 1";
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::PreCreateThreadsImpl")
   run_message_loop_ = false;
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 2";
 
   if (browser_process_->GetApplicationLocale().empty()) {
     ShowMissingLocaleMessageBox();
     return chrome::RESULT_CODE_MISSING_DATA;
   }
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 3";
 
 #if !defined(OS_ANDROID)
   chrome::MaybeShowInvalidUserDataDirWarningDialog();
 #endif  // !defined(OS_ANDROID)
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 4";
   DCHECK(!user_data_dir_.empty());
 
   // Force MediaCaptureDevicesDispatcher to be created on UI thread.
@@ -1021,22 +1028,28 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
   first_run::IsChromeFirstRun();
 
 #endif  // !defined(OS_ANDROID)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 5";
 
   PrefService* local_state = browser_process_->local_state();
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 6";
 #if defined(OS_CHROMEOS)
   chromeos::CrosSettings::Initialize(local_state);
   chromeos::StatsReportingController::Initialize(local_state);
   arc::StabilityMetricsManager::Initialize(local_state);
 #endif  // defined(OS_CHROMEOS)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 7";
 
   {
     TRACE_EVENT0(
         "startup",
         "ChromeBrowserMainParts::PreCreateThreadsImpl:InitBrowserProcessImpl");
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 8";
     browser_process_->Init();
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 9";
   }
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 10";
 #if !defined(OS_ANDROID)
   // Create the RunLoop for MainMessageLoopRun() to use, and pass a copy of
   // its QuitClosure to the BrowserProcessImpl to call when it is time to exit.
@@ -1056,12 +1069,14 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
   base::trace_event::TraceEventETWExport::EnableETWExport();
 #endif  // OS_WIN
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 11";
   // Reset the command line in the crash report details, since we may have
   // just changed it to include experiments.
   crash_keys::SetCrashKeysFromCommandLine(
       *base::CommandLine::ForCurrentProcess());
 
   browser_process_->browser_policy_connector()->OnResourceBundleCreated();
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 12";
 
 // Android does first run in Java instead of native.
 // Chrome OS has its own out-of-box-experience code.
@@ -1085,6 +1100,7 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
 #endif  // defined(OS_MACOSX) || defined(OS_LINUX)
   }
 #endif  // !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 13";
 
 #if defined(OS_LINUX) || defined(OS_OPENBSD)
   // Set the product channel for crash reports.
@@ -1113,6 +1129,7 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
       new vr::XRSessionRequestConsentManagerImpl());
 #endif  // defined(OS_WIN)
 #endif  // BUILDFLAG(ENABLE_VR)
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 14";
 
   // Enable Navigation Tracing only if a trace upload url is specified.
   if (parsed_command_line_.HasSwitch(switches::kEnableNavigationTracing) &&
@@ -1120,11 +1137,13 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
     tracing::SetupNavigationTracing();
   }
 
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 15";
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
   metrics::DesktopSessionDurationTracker::Initialize();
   ProfileActivityMetricsRecorder::Initialize();
 #endif
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 16";
   metrics::RendererUptimeTracker::Initialize();
 
   // Add Site Isolation switches as dictated by policy.
@@ -1150,16 +1169,19 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
         switches::kDisableSiteIsolationForPolicy);
   }
 #endif
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 19";
 
   // ChromeOS needs ui::ResourceBundle::InitSharedInstance to be called before
   // this.
   browser_process_->PreCreateThreads(parsed_command_line());
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 20";
 
   // This must occur in PreCreateThreads() because it initializes global state
   // which is then read by all threads without synchronization. It must be after
   // browser_process_->PreCreateThreads() as that instantiates the IOThread
   // which is used in SetupMetrics().
   SetupMetrics();
+  LOG(ERROR) << "ChromeBrowserMainParts::PreCreateThreadsImpl - Step 21";
 
   return service_manager::RESULT_CODE_NORMAL_EXIT;
 }
diff --git a/chrome/browser/chrome_browser_main_android.cc b/chrome/browser/chrome_browser_main_android.cc
index 024fdb1893e4..46ac9cec77a4 100644
--- a/chrome/browser/chrome_browser_main_android.cc
+++ b/chrome/browser/chrome_browser_main_android.cc
@@ -34,10 +34,12 @@ ChromeBrowserMainPartsAndroid::~ChromeBrowserMainPartsAndroid() {
 }
 
 int ChromeBrowserMainPartsAndroid::PreCreateThreads() {
+LOG(ERROR) << "[Kiwi] ChromeBrowserMainPartsAndroid::PreCreateThreads - Step 1";
   TRACE_EVENT0("startup", "ChromeBrowserMainPartsAndroid::PreCreateThreads")
 
   int result_code = ChromeBrowserMainParts::PreCreateThreads();
 
+LOG(ERROR) << "[Kiwi] ChromeBrowserMainPartsAndroid::PreCreateThreads - Step 2";
   // The ChildExitObserver needs to be created before any child process is
   // created because it needs to be notified during process creation.
   crash_reporter::ChildExitObserver::Create();
diff --git a/chrome/browser/chrome_browser_main_posix.cc b/chrome/browser/chrome_browser_main_posix.cc
index 0b19e94ef71c..9a060be5283a 100644
--- a/chrome/browser/chrome_browser_main_posix.cc
+++ b/chrome/browser/chrome_browser_main_posix.cc
@@ -174,6 +174,6 @@ void ChromeBrowserMainPartsPosix::ShowMissingLocaleMessageBox() {
   // for now, crash.
   NOTREACHED();
 #else
-#error "Need MessageBox implementation."
+
 #endif
 }
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 5cdfec3a834b..f07b7478a0e5 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -414,7 +414,7 @@
 #include "chrome/browser/chrome_browser_main_posix.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/badging/badge_manager.h"
 #include "chrome/browser/devtools/chrome_devtools_manager_delegate.h"
 #include "chrome/browser/devtools/devtools_window.h"
@@ -1211,6 +1211,7 @@ void ChromeContentBrowserClient::SetApplicationLocale(
 std::unique_ptr<content::BrowserMainParts>
 ChromeContentBrowserClient::CreateBrowserMainParts(
     const content::MainFunctionParams& parameters) {
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 1";
   std::unique_ptr<ChromeBrowserMainParts> main_parts;
   // Construct the Main browser parts based on the OS type.
 #if defined(OS_WIN)
@@ -1236,12 +1237,14 @@ ChromeContentBrowserClient::CreateBrowserMainParts(
   main_parts =
       std::make_unique<ChromeBrowserMainParts>(parameters, startup_data_);
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 2";
 
   bool add_profiles_extra_parts = true;
 #if defined(OS_ANDROID)
   if (startup_data_->HasBuiltProfilePrefService())
     add_profiles_extra_parts = false;
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 3";
   if (add_profiles_extra_parts)
     chrome::AddProfilesExtraParts(main_parts.get());
 
@@ -1259,6 +1262,7 @@ ChromeContentBrowserClient::CreateBrowserMainParts(
 #endif
 #endif
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 4";
 #if defined(OS_CHROMEOS)
   // TODO(jamescook): Combine with ChromeBrowserMainPartsChromeos.
   main_parts->AddParts(new ChromeBrowserMainExtraPartsAsh());
@@ -1268,6 +1272,7 @@ ChromeContentBrowserClient::CreateBrowserMainParts(
   main_parts->AddParts(new ChromeBrowserMainExtraPartsX11());
 #endif
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 5";
   main_parts->AddParts(new ChromeBrowserMainExtraPartsPerformanceManager);
 
   main_parts->AddParts(new ChromeBrowserMainExtraPartsProfiling);
@@ -1276,8 +1281,10 @@ ChromeContentBrowserClient::CreateBrowserMainParts(
 
   main_parts->AddParts(new ChromeBrowserMainExtraPartsGpu);
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 6";
   chrome::AddMetricsExtraParts(main_parts.get());
 
+  LOG(ERROR) << "[Kiwi] ChromeContentBrowserClient::CreateBrowserMainParts - Step 7";
   return main_parts;
 }
 
diff --git a/chrome/browser/content_settings/cookie_settings_factory.cc b/chrome/browser/content_settings/cookie_settings_factory.cc
index 0042cb71ae8e..ed7760a78296 100644
--- a/chrome/browser/content_settings/cookie_settings_factory.cc
+++ b/chrome/browser/content_settings/cookie_settings_factory.cc
@@ -43,6 +43,7 @@ CookieSettingsFactory::~CookieSettingsFactory() {
 
 void CookieSettingsFactory::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
+  LOG(ERROR) << "[Kiwi] CookieSettingsFactory::RegisterProfilePrefs";
   content_settings::CookieSettings::RegisterProfilePrefs(registry);
 }
 
diff --git a/chrome/browser/content_settings/host_content_settings_map_factory.cc b/chrome/browser/content_settings/host_content_settings_map_factory.cc
index 47b1443298ec..2a09eb16b64b 100644
--- a/chrome/browser/content_settings/host_content_settings_map_factory.cc
+++ b/chrome/browser/content_settings/host_content_settings_map_factory.cc
@@ -44,7 +44,7 @@ HostContentSettingsMapFactory::HostContentSettingsMapFactory()
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
   DependsOn(SupervisedUserSettingsServiceFactory::GetInstance());
 #endif
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if false && BUILDFLAG(ENABLE_EXTENSIONS)
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
 #endif
@@ -85,7 +85,7 @@ scoped_refptr<RefcountedKeyedService>
       /*store_last_modified=*/true,
       base::FeatureList::IsEnabled(features::kPermissionDelegation)));
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if false && BUILDFLAG(ENABLE_EXTENSIONS)
   // These must be registered before before the HostSettings are passed over to
   // the IOThread.  Simplest to do this on construction.
   extensions::ExtensionService::RegisterContentSettings(settings_map.get(),
diff --git a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
index b79eb6c2b0d0..8e73c94e8be4 100644
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
@@ -27,7 +27,7 @@ RegisterProtocolHandlerPermissionRequest::
 
 PermissionRequest::IconId RegisterProtocolHandlerPermissionRequest::GetIconId()
     const {
-  return vector_icons::kProtocolHandlerIcon;
+  return 0;
 }
 
 base::string16
@@ -43,6 +43,32 @@ RegisterProtocolHandlerPermissionRequest::GetMessageTextFragment() const {
                    base::UTF8ToUTF16(old_handler.url().host_piece()));
 }
 
+base::string16
+RegisterProtocolHandlerPermissionRequest::GetMessageText() const {
+  ProtocolHandler old_handler = registry_->GetHandlerFor(handler_.protocol());
+  return old_handler.IsEmpty()
+             ? l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_FRAGMENT,
+                   handler_.GetProtocolDisplayName())
+             : l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_REPLACE_FRAGMENT,
+                   handler_.GetProtocolDisplayName(),
+                   base::UTF8ToUTF16(old_handler.url().host_piece()));
+}
+
+base::string16
+RegisterProtocolHandlerPermissionRequest::GetTitleText() const {
+  ProtocolHandler old_handler = registry_->GetHandlerFor(handler_.protocol());
+  return old_handler.IsEmpty()
+             ? l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_FRAGMENT,
+                   handler_.GetProtocolDisplayName())
+             : l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM_REPLACE_FRAGMENT,
+                   handler_.GetProtocolDisplayName(),
+                   base::UTF8ToUTF16(old_handler.url().host_piece()));
+}
+
 GURL RegisterProtocolHandlerPermissionRequest::GetOrigin() const {
   return origin_;
 }
diff --git a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
index 2cb9d62d8cda..95f499191abb 100644
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
@@ -25,6 +25,8 @@ class RegisterProtocolHandlerPermissionRequest : public PermissionRequest {
  private:
   // PermissionRequest:
   IconId GetIconId() const override;
+  base::string16 GetTitleText() const override;
+  base::string16 GetMessageText() const override;
   base::string16 GetMessageTextFragment() const override;
   GURL GetOrigin() const override;
   void PermissionGranted() override;
diff --git a/chrome/browser/devtools/BUILD.gn b/chrome/browser/devtools/BUILD.gn
index fbdc1752d9f8..060974c837d2 100644
--- a/chrome/browser/devtools/BUILD.gn
+++ b/chrome/browser/devtools/BUILD.gn
@@ -4,13 +4,13 @@
 
 import("//extensions/buildflags/buildflags.gni")
 
-if (!is_android) {
+if (true || !is_android) {
   import("//build/config/features.gni")
   import("//chrome/common/features.gni")
   import("//tools/grit/grit_rule.gni")
 }
 
-if (!is_android) {
+if (true || !is_android) {
   _inspector_protocol = "//third_party/inspector_protocol"
   import("$_inspector_protocol/inspector_protocol.gni")
 
@@ -107,7 +107,7 @@ static_library("devtools") {
     "//ui/events:dom_keycode_converter",
   ]
 
-  if (!is_android) {
+  if (true || !is_android) {
     deps += [
       "//chrome:extra_resources",
       "//chrome:resources",
@@ -199,7 +199,7 @@ static_library("devtools") {
   } else {
     sources += [ "devtools_dock_tile.cc" ]
   }
-  if (!is_android) {
+  if (true || !is_android) {
     deps += [
       ":protocol_generated_sources",
       "//third_party/inspector_protocol:crdtp",
@@ -234,7 +234,7 @@ static_library("test_support") {
   sources = []
   deps = []
 
-  if (!is_android) {
+  if (true || !is_android) {
     deps += [
       "//base",
       "//chrome/browser/ui",
diff --git a/chrome/browser/download/download_commands.cc b/chrome/browser/download/download_commands.cc
index 671936f200db..1855bf61fc7d 100644
--- a/chrome/browser/download/download_commands.cc
+++ b/chrome/browser/download/download_commands.cc
@@ -26,7 +26,7 @@
 #include "net/base/url_util.h"
 #include "ui/base/clipboard/scoped_clipboard_writer.h"
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || true
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/scoped_tabbed_browser_displayer.h"
@@ -153,7 +153,7 @@ void DownloadCommands::ExecuteCommand(Command command) {
   model_->ExecuteCommand(this, command);
 }
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || true
 
 Browser* DownloadCommands::GetBrowser() const {
   chrome::ScopedTabbedBrowserDisplayer browser_displayer(model_->profile());
@@ -167,18 +167,7 @@ bool DownloadCommands::IsDownloadPdf() const {
 }
 
 bool DownloadCommands::CanOpenPdfInSystemViewer() const {
-#if defined(OS_WIN)
-  bool is_adobe_pdf_reader_up_to_date = false;
-  if (IsDownloadPdf() && IsAdobeReaderDefaultPDFViewer()) {
-    is_adobe_pdf_reader_up_to_date =
-        DownloadTargetDeterminer::IsAdobeReaderUpToDate();
-  }
-  return IsDownloadPdf() &&
-         (IsAdobeReaderDefaultPDFViewer() ? is_adobe_pdf_reader_up_to_date
-                                          : true);
-#elif defined(OS_MACOSX) || defined(OS_LINUX)
-  return IsDownloadPdf();
-#endif
+  return false;
 }
 
 #endif  // defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
diff --git a/chrome/browser/download/download_commands.h b/chrome/browser/download/download_commands.h
index 030b88657da7..9520e1bf1439 100644
--- a/chrome/browser/download/download_commands.h
+++ b/chrome/browser/download/download_commands.h
@@ -11,9 +11,7 @@
 #include "content/public/browser/page_navigator.h"
 #include "ui/gfx/image/image.h"
 
-#if !defined(OS_ANDROID)
 class Browser;
-#endif
 
 class DownloadUIModel;
 
@@ -45,7 +43,7 @@ class DownloadCommands {
   bool IsCommandVisible(Command command) const;
   void ExecuteCommand(Command command);
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || true
   bool IsDownloadPdf() const;
   bool CanOpenPdfInSystemViewer() const;
   Browser* GetBrowser() const;
diff --git a/chrome/browser/download/download_crx_util_android.cc b/chrome/browser/download/download_crx_util_android.cc
deleted file mode 100644
index 2eb36d4a5762..000000000000
--- a/chrome/browser/download/download_crx_util_android.cc
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-//
-// Download code which handles CRX files (extensions, themes, apps, ...).
-
-#include "chrome/browser/download/download_crx_util.h"
-
-namespace download_crx_util {
-
-bool IsExtensionDownload(const download::DownloadItem& download_item) {
-  // Extensions are not supported on Android. We want to treat them as
-  // normal file downloads.
-  return false;
-}
-
-bool IsTrustedExtensionDownload(Profile* profile,
-                                const download::DownloadItem& item) {
-  // Extensions are not supported on Android, return the safe default.
-  return false;
-}
-
-}  // namespace download_crx_util
diff --git a/chrome/browser/download/download_danger_prompt.cc b/chrome/browser/download/download_danger_prompt.cc
index 7c6c282338a0..b6a266a73783 100644
--- a/chrome/browser/download/download_danger_prompt.cc
+++ b/chrome/browser/download/download_danger_prompt.cc
@@ -91,11 +91,6 @@ void DownloadDangerPrompt::SendSafeBrowsingDownloadReport(
   }
   report.set_url(download.GetURL().spec());
   report.set_did_proceed(did_proceed);
-  std::string token =
-    safe_browsing::DownloadProtectionService::GetDownloadPingToken(
-        &download);
-  if (!token.empty())
-    report.set_token(token);
   std::string serialized_report;
   if (report.SerializeToString(&serialized_report))
     sb_service->SendSerializedDownloadReport(serialized_report);
diff --git a/chrome/browser/download/download_shelf_context_menu.cc b/chrome/browser/download/download_shelf_context_menu.cc
index 3a5090bd3eb7..4cc14e2f7051 100644
--- a/chrome/browser/download/download_shelf_context_menu.cc
+++ b/chrome/browser/download/download_shelf_context_menu.cc
@@ -127,23 +127,6 @@ base::string16 DownloadShelfContextMenu::GetLabelForCommandId(
       id = IDS_DOWNLOAD_MENU_KEEP;
       break;
     case DownloadCommands::ALWAYS_OPEN_TYPE: {
-      if (download_commands_) {
-        bool can_open_pdf_in_system_viewer =
-            download_commands_->CanOpenPdfInSystemViewer();
-#if defined(OS_WIN)
-        if (can_open_pdf_in_system_viewer) {
-          id = IsAdobeReaderDefaultPDFViewer()
-                   ? IDS_DOWNLOAD_MENU_ALWAYS_OPEN_PDF_IN_READER
-                   : IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
-          break;
-        }
-#elif defined(OS_MACOSX) || defined(OS_LINUX)
-        if (can_open_pdf_in_system_viewer) {
-          id = IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
-          break;
-        }
-#endif
-      }
       id = IDS_DOWNLOAD_MENU_ALWAYS_OPEN_TYPE;
       break;
     }
diff --git a/chrome/browser/download/download_ui_model.cc b/chrome/browser/download/download_ui_model.cc
index cb684f9e69ec..a720b04a4cef 100644
--- a/chrome/browser/download/download_ui_model.cc
+++ b/chrome/browser/download/download_ui_model.cc
@@ -22,7 +22,7 @@
 #include "ui/base/text/bytes_formatting.h"
 #include "ui/gfx/text_elider.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -507,7 +507,7 @@ bool DownloadUIModel::ShouldPromoteOrigin() const {
   return false;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 bool DownloadUIModel::IsCommandEnabled(
     const DownloadCommands* download_commands,
     DownloadCommands::Command command) const {
diff --git a/chrome/browser/download/download_ui_model.h b/chrome/browser/download/download_ui_model.h
index b7eb87fdb28b..3111fb9b69c5 100644
--- a/chrome/browser/download/download_ui_model.h
+++ b/chrome/browser/download/download_ui_model.h
@@ -19,7 +19,7 @@
 #include "components/offline_items_collection/core/offline_item.h"
 #include "components/safe_browsing/buildflags.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/download/download_commands.h"
 #endif
 
@@ -286,7 +286,7 @@ class DownloadUIModel {
   // security reasons.
   virtual bool ShouldPromoteOrigin() const;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Methods related to DownloadCommands.
   // Returns whether the given download command is enabled for this download.
   virtual bool IsCommandEnabled(const DownloadCommands* download_commands,
diff --git a/chrome/browser/download/drag_download_item_android.cc b/chrome/browser/download/drag_download_item_android.cc
new file mode 100644
index 000000000000..dbd451570d79
--- /dev/null
+++ b/chrome/browser/download/drag_download_item_android.cc
@@ -0,0 +1,35 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/download/drag_download_item.h"
+
+#include <string>
+
+#include "build/build_config.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/download/public/common/download_item.h"
+#include "net/base/mime_util.h"
+#include "ui/aura/client/drag_drop_client.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_event_dispatcher.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/file_info.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/display/screen.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/views/button_drag_utils.h"
+#include "ui/views/widget/widget.h"
+#include "url/gurl.h"
+
+#if defined(OS_CHROMEOS)
+#include "chrome/browser/chromeos/drive/download_handler.h"
+#include "content/public/browser/download_item_utils.h"
+#endif
+
+void DragDownloadItem(const download::DownloadItem* download,
+                      gfx::Image* icon,
+                      gfx::NativeView view) {
+}
diff --git a/chrome/browser/download/drag_download_item_aura.cc b/chrome/browser/download/drag_download_item_aura.cc
index 8b26fda78cac..1eb89de0a550 100644
--- a/chrome/browser/download/drag_download_item_aura.cc
+++ b/chrome/browser/download/drag_download_item_aura.cc
@@ -31,6 +31,7 @@
 void DragDownloadItem(const download::DownloadItem* download,
                       gfx::Image* icon,
                       gfx::NativeView view) {
+#if 0
   DCHECK(download);
   DCHECK_EQ(download::DownloadItem::COMPLETE, download->GetState());
 
@@ -59,4 +60,5 @@ void DragDownloadItem(const download::DownloadItem* download,
           std::move(data), root_window, view, location,
           ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_LINK,
           ui::DragDropTypes::DRAG_EVENT_SOURCE_MOUSE);
+#endif
 }
diff --git a/chrome/browser/enterprise_reporting/policy_info.cc b/chrome/browser/enterprise_reporting/policy_info.cc
index 0ebac66a590a..fdbb49f9d00c 100644
--- a/chrome/browser/enterprise_reporting/policy_info.cc
+++ b/chrome/browser/enterprise_reporting/policy_info.cc
@@ -110,6 +110,7 @@ void AppendExtensionPolicyInfoIntoProfileReport(
 
 void AppendMachineLevelUserCloudPolicyFetchTimestamp(
     em::ChromeUserProfileInfo* profile_info) {
+#if 0
 #if !defined(OS_CHROMEOS)
   policy::MachineLevelUserCloudPolicyManager* manager =
       g_browser_process->browser_policy_connector()
@@ -122,6 +123,7 @@ void AppendMachineLevelUserCloudPolicyFetchTimestamp(
   timestamp->set_timestamp(
       manager->core()->client()->last_policy_timestamp().ToJavaTime());
 #endif
+#endif
 }
 
 }  // namespace enterprise_reporting
diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index 9d69db7aa109..ab62d9c08d02 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -221,6 +221,7 @@ jumbo_static_library("extensions") {
     "api/image_writer_private/removable_storage_provider_chromeos.cc",
     "api/image_writer_private/removable_storage_provider_mac.cc",
     "api/image_writer_private/removable_storage_provider_win.cc",
+    "api/image_writer_private/removable_storage_provider_android.cc",
     "api/image_writer_private/unzip_helper.cc",
     "api/image_writer_private/unzip_helper.h",
     "api/image_writer_private/write_from_file_operation.cc",
@@ -623,6 +624,7 @@ jumbo_static_library("extensions") {
     "global_shortcut_listener_mac.mm",
     "global_shortcut_listener_win.cc",
     "global_shortcut_listener_win.h",
+    "global_shortcut_listener_android.cc",
     "install_gate.h",
     "install_observer.cc",
     "install_observer.h",
@@ -660,8 +662,6 @@ jumbo_static_library("extensions") {
     "permissions_based_management_policy_provider.h",
     "permissions_updater.cc",
     "permissions_updater.h",
-    "plugin_manager.cc",
-    "plugin_manager.h",
     "policy_extension_reinstaller.cc",
     "policy_extension_reinstaller.h",
     "policy_handlers.cc",
@@ -693,6 +693,8 @@ jumbo_static_library("extensions") {
     "system_display/display_info_provider_chromeos.h",
     "system_display/display_info_provider_mac.cc",
     "system_display/display_info_provider_mac.h",
+    "system_display/display_info_provider_android.cc",
+    "system_display/display_info_provider_android.h",
     "system_display/display_info_provider_win.cc",
     "system_display/display_info_provider_win.h",
     "tab_helper.cc",
@@ -789,7 +791,6 @@ jumbo_static_library("extensions") {
     "//chrome/browser/devtools",
     "//chrome/browser/engagement:mojo_bindings",
     "//chrome/browser/media/router",
-    "//chrome/browser/media/router/discovery",
     "//chrome/browser/resource_coordinator:mojo_bindings",
     "//chrome/browser/safe_browsing",
     "//chrome/browser/web_applications/components",
@@ -1092,7 +1093,7 @@ jumbo_static_library("extensions") {
     }
   }
 
-  if (!is_android) {
+  if (true || !is_android) {
     sources += [
       "api/processes/processes_api.cc",
       "api/processes/processes_api.h",
diff --git a/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc b/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc
index d0c59bb4cc40..5482fd3506cb 100644
--- a/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc
+++ b/chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.cc
@@ -445,11 +445,6 @@ bool BookmarkManagerPrivateStartDragFunction::RunOnReady() {
   if (params->is_from_touch)
     source = ui::DragDropTypes::DRAG_EVENT_SOURCE_TOUCH;
 
-  chrome::DragBookmarks(GetProfile(),
-                        {std::move(nodes), params->drag_node_index,
-                         web_contents->GetContentNativeView(), source,
-                         gfx::Point(params->x, params->y)});
-
   return true;
 }
 
diff --git a/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc b/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc
index e73cd3f30320..25c77b5adecf 100644
--- a/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc
+++ b/chrome/browser/extensions/api/browsing_data/browsing_data_api.cc
@@ -347,20 +347,7 @@ bool BrowsingDataRemoverFunction::RunAsync() {
     return false;
   }
 
-  if (removal_mask_ &
-      ChromeBrowsingDataRemoverDelegate::DATA_TYPE_PLUGIN_DATA) {
-    // If we're being asked to remove plugin data, check whether it's actually
-    // supported.
-    PostTask(FROM_HERE,
-             {base::ThreadPool(), base::MayBlock(),
-              base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN,
-              base::TaskPriority::USER_VISIBLE},
-             base::BindOnce(
-                 &BrowsingDataRemoverFunction::CheckRemovingPluginDataSupported,
-                 this, PluginPrefs::GetForProfile(GetProfile())));
-  } else {
-    StartRemoving();
-  }
+  StartRemoving();
 
   // Will finish asynchronously.
   return true;
diff --git a/chrome/browser/extensions/api/content_settings/content_settings_api.cc b/chrome/browser/extensions/api/content_settings/content_settings_api.cc
index 8895ee152cf8..59ba6c27eb9c 100644
--- a/chrome/browser/extensions/api/content_settings/content_settings_api.cc
+++ b/chrome/browser/extensions/api/content_settings/content_settings_api.cc
@@ -320,15 +320,18 @@ bool ContentSettingsContentSettingGetResourceIdentifiersFunction::RunAsync() {
     return true;
   }
 
+#if 0
   PluginService::GetInstance()->GetPlugins(base::BindOnce(
       &ContentSettingsContentSettingGetResourceIdentifiersFunction::
           OnGotPlugins,
       this));
+#endif
   return true;
 }
 
 void ContentSettingsContentSettingGetResourceIdentifiersFunction::OnGotPlugins(
     const std::vector<content::WebPluginInfo>& plugins) {
+#if 0
   PluginFinder* finder = PluginFinder::GetInstance();
   std::set<std::string> group_identifiers;
   std::unique_ptr<base::ListValue> list(new base::ListValue());
@@ -353,6 +356,7 @@ void ContentSettingsContentSettingGetResourceIdentifiersFunction::OnGotPlugins(
           &ContentSettingsContentSettingGetResourceIdentifiersFunction::
               SendResponse,
           this, true));
+#endif
 }
 
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc b/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
index f1bf1cfcfd85..9f46db3a8241 100644
--- a/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
+++ b/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
@@ -83,12 +83,7 @@ std::string GetProfileId(const Profile* profile) {
 // Returns last policy fetch timestamp of machine level user cloud policy if
 // it exists. Otherwise, returns zero.
 int64_t GetMachineLevelUserCloudPolicyFetchTimestamp() {
-  policy::MachineLevelUserCloudPolicyManager* manager =
-      g_browser_process->browser_policy_connector()
-          ->machine_level_user_cloud_policy_manager();
-  if (!manager || !manager->IsClientRegistered())
-    return 0;
-  return manager->core()->client()->last_policy_timestamp().ToJavaTime();
+  return 0;
 }
 
 void AppendAdditionalBrowserInformation(em::ChromeDesktopReportRequest* request,
diff --git a/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc b/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc
new file mode 100644
index 000000000000..2f8221f7163f
--- /dev/null
+++ b/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_android.cc
@@ -0,0 +1,19 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stdint.h>
+
+#include "base/files/file_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "chrome/browser/extensions/api/image_writer_private/removable_storage_provider.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace extensions {
+// static
+scoped_refptr<StorageDeviceList>
+RemovableStorageProvider::PopulateDeviceList() {
+  return nullptr;
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/music_manager_private/device_id_android.cc b/chrome/browser/extensions/api/music_manager_private/device_id_android.cc
new file mode 100644
index 000000000000..44c257851067
--- /dev/null
+++ b/chrome/browser/extensions/api/music_manager_private/device_id_android.cc
@@ -0,0 +1,184 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/api/music_manager_private/device_id.h"
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  // Must be included before ifaddrs.h.
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/macros.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/task_scheduler/post_task.h"
+#include "base/threading/thread_restrictions.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace {
+
+using extensions::api::DeviceId;
+
+typedef base::Callback<bool(const void* bytes, size_t size)>
+    IsValidMacAddressCallback;
+
+const char kDiskByUuidDirectoryName[] = "/dev/disk/by-uuid";
+const char* const kDeviceNames[] = {
+  "sda1", "hda1", "dm-0", "xvda1", "sda2", "hda2", "dm-1", "xvda2",
+};
+// Fedora 15 uses biosdevname feature where Embedded ethernet uses the
+// "em" prefix and PCI cards use the p[0-9]c[0-9] format based on PCI
+// slot and card information.
+// Map from device name to disk uuid
+typedef std::map<base::FilePath, base::FilePath> DiskEntries;
+
+std::string GetDiskUuid() {
+  base::AssertBlockingAllowed();
+
+  DiskEntries disk_uuids;
+  base::FileEnumerator files(base::FilePath(kDiskByUuidDirectoryName),
+                             false,  // Recursive.
+                             base::FileEnumerator::FILES);
+  do {
+    base::FilePath file_path = files.Next();
+    if (file_path.empty())
+      break;
+
+    base::FilePath target_path;
+    if (!base::ReadSymbolicLink(file_path, &target_path))
+      continue;
+
+    base::FilePath device_name = target_path.BaseName();
+    base::FilePath disk_uuid = file_path.BaseName();
+    disk_uuids[device_name] = disk_uuid;
+  } while (true);
+
+  // Look for first device name matching an entry of |kDeviceNames|.
+  std::string result;
+  for (size_t i = 0; i < arraysize(kDeviceNames); i++) {
+    DiskEntries::iterator it =
+        disk_uuids.find(base::FilePath(kDeviceNames[i]));
+    if (it != disk_uuids.end()) {
+      DVLOG(1) << "Returning uuid: \"" << it->second.value()
+               << "\" for device \"" << it->first.value() << "\"";
+      result = it->second.value();
+      break;
+    }
+  }
+
+  // Log failure (at most once) for diagnostic purposes.
+  static bool error_logged = false;
+  if (result.empty() && !error_logged) {
+    error_logged = true;
+    LOG(ERROR) << "Could not find appropriate disk uuid.";
+    for (DiskEntries::iterator it = disk_uuids.begin();
+        it != disk_uuids.end(); ++it) {
+      LOG(ERROR) << "  DeviceID=" << it->first.value() << ", uuid="
+                 << it->second.value();
+    }
+  }
+
+  return result;
+}
+
+class MacAddressProcessor {
+ public:
+  explicit MacAddressProcessor(
+      const IsValidMacAddressCallback& is_valid_mac_address)
+      : is_valid_mac_address_(is_valid_mac_address) {
+  }
+
+  bool ProcessInterface(struct ifaddrs *ifaddr,
+                        const char* const prefixes[],
+                        size_t prefixes_count) {
+    const int MAC_LENGTH = 6;
+    struct ifreq ifinfo;
+
+    memset(&ifinfo, 0, sizeof(ifinfo));
+    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
+
+    int sd = socket(AF_INET, SOCK_DGRAM, 0);
+    int result = ioctl(sd, SIOCGIFHWADDR, &ifinfo);
+    close(sd);
+
+    if (result != 0)
+      return true;
+
+    const char* mac_address =
+        static_cast<const char*>(ifinfo.ifr_hwaddr.sa_data);
+    if (!is_valid_mac_address_.Run(mac_address, MAC_LENGTH))
+      return true;
+
+    if (!IsValidPrefix(ifinfo.ifr_name, prefixes, prefixes_count))
+      return true;
+
+    // Got one!
+    found_mac_address_ =
+        base::ToLowerASCII(base::HexEncode(mac_address, MAC_LENGTH));
+    return false;
+  }
+
+  std::string mac_address() const { return found_mac_address_; }
+
+ private:
+  bool IsValidPrefix(const char* name,
+                     const char* const prefixes[],
+                     size_t prefixes_count) {
+    for (size_t i = 0; i < prefixes_count; i++) {
+      if (strncmp(prefixes[i], name, strlen(prefixes[i])) == 0)
+        return true;
+    }
+    return false;
+  }
+
+  const IsValidMacAddressCallback& is_valid_mac_address_;
+  std::string found_mac_address_;
+};
+
+std::string GetMacAddress(
+    const IsValidMacAddressCallback& is_valid_mac_address) {
+  return "";
+}
+
+void GetRawDeviceIdImpl(const IsValidMacAddressCallback& is_valid_mac_address,
+                        const DeviceId::IdCallback& callback) {
+  base::AssertBlockingAllowed();
+
+  std::string disk_id = GetDiskUuid();
+  std::string mac_address = GetMacAddress(is_valid_mac_address);
+
+  std::string raw_device_id;
+  if (!mac_address.empty() && !disk_id.empty()) {
+    raw_device_id = mac_address + disk_id;
+  }
+
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                                   base::BindOnce(callback, raw_device_id));
+}
+
+}  // namespace
+
+namespace extensions {
+namespace api {
+
+// static
+void DeviceId::GetRawDeviceId(const IdCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::PostTaskWithTraits(
+      FROM_HERE, traits(),
+      base::BindOnce(&GetRawDeviceIdImpl,
+                     base::Bind(&DeviceId::IsValidMacAddress), callback));
+}
+
+}  // namespace api
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/resources_private/resources_private_api.cc b/chrome/browser/extensions/api/resources_private/resources_private_api.cc
index 3f4c26989429..ec24f31641ab 100644
--- a/chrome/browser/extensions/api/resources_private/resources_private_api.cc
+++ b/chrome/browser/extensions/api/resources_private/resources_private_api.cc
@@ -42,6 +42,7 @@ void AddStringsForIdentity(base::DictionaryValue* dict) {
 
 void AddStringsForPdf(base::DictionaryValue* dict) {
   static constexpr webui::LocalizedString kPdfResources[] = {
+#if 0
     {"passwordDialogTitle", IDS_PDF_PASSWORD_DIALOG_TITLE},
     {"passwordPrompt", IDS_PDF_NEED_PASSWORD},
     {"passwordSubmit", IDS_PDF_PASSWORD_SUBMIT},
@@ -111,6 +112,7 @@ void AddStringsForPdf(base::DictionaryValue* dict) {
     {"annotationFormWarningKeepEditing", IDS_PDF_KEEP_EDITING},
     {"annotationFormWarningDiscard", IDS_PDF_DISCARD},
 #endif  // defined(OS_CHROMEOS)
+#endif
   };
   for (const auto& resource : kPdfResources)
     dict->SetString(resource.name, l10n_util::GetStringUTF16(resource.id));
diff --git a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
index ff2386afdd55..22aa2440b193 100644
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -721,9 +721,11 @@ void SafeBrowsingPrivateEventRouter::RealtimeReportingPrefChanged(
 
 void SafeBrowsingPrivateEventRouter::IfAuthorized(
     base::OnceCallback<void(bool)> cont) {
+#if 0
   if (binary_upload_service_) {
     binary_upload_service_->IsAuthorized(std::move(cont));
   }
+#endif
 }
 
 void SafeBrowsingPrivateEventRouter::ReportRealtimeEvent(
@@ -787,6 +789,7 @@ const user_manager::User* SafeBrowsingPrivateEventRouter::GetChromeOSUser() {
 #endif
 
 bool SafeBrowsingPrivateEventRouter::IsRealtimeReportingAvailable() {
+#if 0
 #if defined(OS_CHROMEOS)
   // The device must be managed.
   if (!g_browser_process->platform_part()
@@ -805,6 +808,8 @@ bool SafeBrowsingPrivateEventRouter::IsRealtimeReportingAvailable() {
 #else
   return policy::ChromeBrowserCloudManagementController::IsEnabled();
 #endif
+#endif
+  return false;
 }
 
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/tabs/windows_event_router.cc b/chrome/browser/extensions/api/tabs/windows_event_router.cc
index 5f41fa24c34b..7c3a75fe261c 100644
--- a/chrome/browser/extensions/api/tabs/windows_event_router.cc
+++ b/chrome/browser/extensions/api/tabs/windows_event_router.cc
@@ -164,8 +164,6 @@ WindowsEventRouter::WindowsEventRouter(Profile* profile)
                  content::NotificationService::AllSources());
 #elif defined(TOOLKIT_VIEWS)
   views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);
-#else
-#error Unsupported
 #endif
 
   AppWindowRegistry* registry = AppWindowRegistry::Get(profile_);
diff --git a/chrome/browser/extensions/bookmark_app_helper.cc b/chrome/browser/extensions/bookmark_app_helper.cc
new file mode 100644
index 000000000000..6929527c18c4
--- /dev/null
+++ b/chrome/browser/extensions/bookmark_app_helper.cc
@@ -0,0 +1,868 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/bookmark_app_helper.h"
+
+#include <stddef.h>
+
+#include <cctype>
+#include <string>
+#include <utility>
+
+#include "base/command_line.h"
+#include "base/feature_list.h"
+#include "base/macros.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/time/time.h"
+#include "build/build_config.h"
+#include "chrome/browser/banners/app_banner_manager.h"
+#include "chrome/browser/banners/app_banner_manager_desktop.h"
+#include "chrome/browser/banners/app_banner_settings_helper.h"
+#include "chrome/browser/bitmap_fetcher/bitmap_fetcher.h"
+#include "chrome/browser/bitmap_fetcher/bitmap_fetcher_delegate.h"
+#include "chrome/browser/chrome_notification_types.h"
+#include "chrome/browser/extensions/convert_web_app.h"
+#include "chrome/browser/extensions/crx_installer.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/favicon_downloader.h"
+#include "chrome/browser/extensions/launch_util.h"
+#include "chrome/browser/extensions/tab_helper.h"
+#include "chrome/browser/installable/installable_data.h"
+#include "chrome/browser/installable/installable_manager.h"
+#include "chrome/browser/installable/installable_params.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/app_list/app_list_util.h"
+#include "chrome/browser/ui/browser_commands.h"
+#include "chrome/browser/ui/browser_dialogs.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/extensions/application_launch.h"
+#include "chrome/browser/web_applications/web_app.h"
+#include "chrome/browser/webshare/share_target_pref_helper.h"
+#include "chrome/common/chrome_features.h"
+#include "chrome/common/extensions/api/url_handlers/url_handlers_parser.h"
+#include "chrome/common/extensions/extension_constants.h"
+#include "chrome/common/extensions/manifest_handlers/app_launch_info.h"
+#include "chrome/common/origin_trials/chrome_origin_trial_policy.h"
+#include "chrome/common/url_constants.h"
+#include "chrome/grit/platform_locale_settings.h"
+#include "components/prefs/pref_service.h"
+#include "content/public/browser/navigation_controller.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/browser/notification_source.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/content_switches.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/notification_types.h"
+#include "extensions/browser/pref_names.h"
+#include "extensions/common/constants.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/url_pattern.h"
+#include "net/base/load_flags.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+#include "net/url_request/url_request.h"
+#include "skia/ext/image_operations.h"
+#include "skia/ext/platform_canvas.h"
+#include "third_party/blink/public/common/manifest/web_display_mode.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/color_analysis.h"
+#include "ui/gfx/color_utils.h"
+#include "ui/gfx/font.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/image/canvas_image_source.h"
+#include "ui/gfx/image/image.h"
+
+#if defined(OS_MACOSX)
+#include "chrome/browser/web_applications/web_app_mac.h"
+#include "chrome/common/chrome_switches.h"
+#endif
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif  // defined(OS_WIN)
+
+#if defined(OS_CHROMEOS)
+// gn check complains on Linux Ozone.
+#include "ash/public/cpp/shelf_model.h"  // nogncheck
+#include "chrome/browser/ui/ash/launcher/chrome_launcher_controller.h"
+#endif
+
+namespace {
+
+using extensions::BookmarkAppHelper;
+
+// Overlays a shortcut icon over the bottom left corner of a given image.
+class GeneratedIconImageSource : public gfx::CanvasImageSource {
+ public:
+  explicit GeneratedIconImageSource(char letter, SkColor color, int output_size)
+      : gfx::CanvasImageSource(gfx::Size(output_size, output_size), false),
+        letter_(letter),
+        color_(color),
+        output_size_(output_size) {}
+  ~GeneratedIconImageSource() override {}
+
+ private:
+  // gfx::CanvasImageSource overrides:
+  void Draw(gfx::Canvas* canvas) override {
+    const uint8_t kLumaThreshold = 190;
+    const int icon_size = output_size_ * 3 / 4;
+    const int icon_inset = output_size_ / 8;
+    const size_t border_radius = output_size_ / 16;
+    const size_t font_size = output_size_ * 7 / 16;
+
+    std::string font_name =
+        l10n_util::GetStringUTF8(IDS_SANS_SERIF_FONT_FAMILY);
+#if defined(OS_CHROMEOS)
+    const std::string kChromeOSFontFamily = "Noto Sans";
+    font_name = kChromeOSFontFamily;
+#endif
+
+    // Draw a rounded rect of the given |color|.
+    cc::PaintFlags background_flags;
+    background_flags.setAntiAlias(true);
+    background_flags.setColor(color_);
+
+    gfx::Rect icon_rect(icon_inset, icon_inset, icon_size, icon_size);
+    canvas->DrawRoundRect(icon_rect, border_radius, background_flags);
+
+    // The text rect's size needs to be odd to center the text correctly.
+    gfx::Rect text_rect(icon_inset, icon_inset, icon_size + 1, icon_size + 1);
+    // Draw the letter onto the rounded rect. The letter's color depends on the
+    // luma of |color|.
+    const uint8_t luma = color_utils::GetLuma(color_);
+    canvas->DrawStringRectWithFlags(
+        base::string16(1, std::toupper(letter_)),
+        gfx::FontList(gfx::Font(font_name, font_size)),
+        (luma > kLumaThreshold) ? SK_ColorBLACK : SK_ColorWHITE,
+        text_rect,
+        gfx::Canvas::TEXT_ALIGN_CENTER);
+  }
+
+  char letter_;
+
+  SkColor color_;
+
+  int output_size_;
+
+  DISALLOW_COPY_AND_ASSIGN(GeneratedIconImageSource);
+};
+
+std::set<int> SizesToGenerate() {
+  // Generate container icons from smaller icons.
+  const int kIconSizesToGenerate[] = {
+      extension_misc::EXTENSION_ICON_SMALL,
+      extension_misc::EXTENSION_ICON_SMALL * 2,
+      extension_misc::EXTENSION_ICON_MEDIUM,
+      extension_misc::EXTENSION_ICON_MEDIUM * 2,
+      extension_misc::EXTENSION_ICON_LARGE,
+      extension_misc::EXTENSION_ICON_LARGE * 2,
+  };
+  return std::set<int>(kIconSizesToGenerate,
+                       kIconSizesToGenerate + arraysize(kIconSizesToGenerate));
+}
+
+void GenerateIcons(
+    std::set<int> generate_sizes,
+    const GURL& app_url,
+    SkColor generated_icon_color,
+    std::map<int, BookmarkAppHelper::BitmapAndSource>* bitmap_map) {
+  // The letter that will be painted on the generated icon.
+  char icon_letter = ' ';
+  std::string domain_and_registry(
+      net::registry_controlled_domains::GetDomainAndRegistry(
+          app_url,
+          net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES));
+  if (!domain_and_registry.empty()) {
+    icon_letter = domain_and_registry[0];
+  } else if (app_url.has_host()) {
+    icon_letter = app_url.host_piece()[0];
+  }
+
+  // If no color has been specified, use a dark gray so it will stand out on the
+  // black shelf.
+  if (generated_icon_color == SK_ColorTRANSPARENT)
+    generated_icon_color = SK_ColorDKGRAY;
+
+  for (int size : generate_sizes) {
+    extensions::BookmarkAppHelper::GenerateIcon(
+        bitmap_map, size, generated_icon_color, icon_letter);
+  }
+}
+
+void ReplaceWebAppIcons(
+    std::map<int, BookmarkAppHelper::BitmapAndSource> bitmap_map,
+    WebApplicationInfo* web_app_info) {
+  web_app_info->icons.clear();
+
+  // Populate the icon data into the WebApplicationInfo we are using to
+  // install the bookmark app.
+  for (const auto& pair : bitmap_map) {
+    WebApplicationInfo::IconInfo icon_info;
+    icon_info.data = pair.second.bitmap;
+    icon_info.url = pair.second.source_url;
+    icon_info.width = icon_info.data.width();
+    icon_info.height = icon_info.data.height();
+    web_app_info->icons.push_back(icon_info);
+  }
+}
+
+// Class to handle installing a bookmark app after it has synced. Handles
+// downloading and decoding the icons.
+class BookmarkAppInstaller : public base::RefCounted<BookmarkAppInstaller>,
+                             public content::WebContentsObserver {
+ public:
+  BookmarkAppInstaller(ExtensionService* service,
+                       const WebApplicationInfo& web_app_info)
+      : service_(service),
+        web_app_info_(web_app_info) {}
+
+  void Run() {
+    for (const auto& icon : web_app_info_.icons) {
+      if (icon.url.is_valid())
+        urls_to_download_.push_back(icon.url);
+    }
+
+    if (urls_to_download_.size()) {
+      // Matched in OnIconsDownloaded.
+      AddRef();
+      SetupWebContents();
+
+      return;
+    }
+
+    FinishInstallation();
+  }
+
+  void SetupWebContents() {
+    // Spin up a web contents process so we can use FaviconDownloader.
+    // This is necessary to make sure we pick up all of the images provided
+    // in favicon URLs. Without this, bookmark app sync can fail due to
+    // missing icons which are not correctly extracted from a favicon.
+    // (The eventual error indicates that there are missing files, which
+    // are the not-extracted favicon images).
+    //
+    // TODO(dominickn): refactor bookmark app syncing to reuse one web
+    // contents for all pending synced bookmark apps. This will avoid
+    // pathological cases where n renderers for n bookmark apps are spun up on
+    // first sign-in to a new machine.
+    web_contents_ = content::WebContents::Create(
+        content::WebContents::CreateParams(service_->profile()));
+    Observe(web_contents_.get());
+
+    // Load about:blank so that the process actually starts.
+    // Image download continues in DidFinishLoad.
+    content::NavigationController::LoadURLParams load_params(
+        GURL("about:blank"));
+    load_params.transition_type = ui::PAGE_TRANSITION_GENERATED;
+    web_contents_->GetController().LoadURLWithParams(load_params);
+  }
+
+  void DidFinishLoad(content::RenderFrameHost* render_frame_host,
+                     const GURL& validated_url) override {
+    favicon_downloader_.reset(new FaviconDownloader(
+        web_contents_.get(), urls_to_download_,
+        "Extensions.BookmarkApp.Icon.HttpStatusCodeClassOnSync",
+        base::BindOnce(&BookmarkAppInstaller::OnIconsDownloaded,
+                       base::Unretained(this))));
+
+    // Skip downloading the page favicons as everything in is the URL list.
+    favicon_downloader_->SkipPageFavicons();
+    favicon_downloader_->Start();
+  }
+
+ private:
+  friend class base::RefCounted<BookmarkAppInstaller>;
+  ~BookmarkAppInstaller() override {}
+
+  void OnIconsDownloaded(bool success,
+                         const std::map<GURL, std::vector<SkBitmap>>& bitmaps) {
+    // Ignore the unsuccessful case, as the necessary icons will be generated.
+    if (success) {
+      for (const auto& url_bitmaps : bitmaps) {
+        for (const auto& bitmap : url_bitmaps.second) {
+          // Only accept square icons.
+          if (bitmap.empty() || bitmap.width() != bitmap.height())
+            continue;
+
+          downloaded_bitmaps_.push_back(
+              BookmarkAppHelper::BitmapAndSource(url_bitmaps.first, bitmap));
+        }
+      }
+    }
+    FinishInstallation();
+    Release();
+  }
+
+  void FinishInstallation() {
+    // Ensure that all icons that are in web_app_info are present, by generating
+    // icons for any sizes which have failed to download. This ensures that the
+    // created manifest for the bookmark app does not contain links to icons
+    // which are not actually created and linked on disk.
+
+    // Ensure that all icon widths in the web app info icon array are present in
+    // the sizes to generate set. This ensures that we will have all of the
+    // icon sizes from when the app was originally added, even if icon URLs are
+    // no longer accessible.
+    std::set<int> sizes_to_generate = SizesToGenerate();
+    for (const auto& icon : web_app_info_.icons)
+      sizes_to_generate.insert(icon.width);
+
+    std::map<int, BookmarkAppHelper::BitmapAndSource> size_map =
+        BookmarkAppHelper::ResizeIconsAndGenerateMissing(
+            downloaded_bitmaps_, sizes_to_generate, &web_app_info_);
+    BookmarkAppHelper::UpdateWebAppIconsWithoutChangingLinks(size_map,
+                                                             &web_app_info_);
+    scoped_refptr<extensions::CrxInstaller> installer(
+        extensions::CrxInstaller::CreateSilent(service_));
+    installer->set_error_on_unsupported_requirements(true);
+    installer->InstallWebApp(web_app_info_);
+  }
+
+  ExtensionService* service_;
+  WebApplicationInfo web_app_info_;
+
+  std::unique_ptr<content::WebContents> web_contents_;
+  std::unique_ptr<FaviconDownloader> favicon_downloader_;
+  std::vector<GURL> urls_to_download_;
+  std::vector<BookmarkAppHelper::BitmapAndSource> downloaded_bitmaps_;
+};
+
+}  // namespace
+
+namespace extensions {
+
+// static
+void BookmarkAppHelper::UpdateWebAppInfoFromManifest(
+    const blink::Manifest& manifest,
+    WebApplicationInfo* web_app_info,
+    ForInstallableSite for_installable_site) {
+  if (!manifest.short_name.is_null())
+    web_app_info->title = manifest.short_name.string();
+
+  // Give the full length name priority.
+  if (!manifest.name.is_null())
+    web_app_info->title = manifest.name.string();
+
+  // Set the url based on the manifest value, if any.
+  if (manifest.start_url.is_valid())
+    web_app_info->app_url = manifest.start_url;
+
+  if (for_installable_site == ForInstallableSite::kYes) {
+    // If there is no scope present, use 'start_url' without the filename as the
+    // scope. This does not match the spec but it matches what we do on Android.
+    // See: https://github.com/w3c/manifest/issues/550
+    if (!manifest.scope.is_empty())
+      web_app_info->scope = manifest.scope;
+    else if (manifest.start_url.is_valid())
+      web_app_info->scope = manifest.start_url.Resolve(".");
+  }
+
+  if (manifest.theme_color)
+    web_app_info->theme_color = *manifest.theme_color;
+
+  // If any icons are specified in the manifest, they take precedence over any
+  // we picked up from the web_app stuff.
+  if (!manifest.icons.empty()) {
+    web_app_info->icons.clear();
+    for (const auto& icon : manifest.icons) {
+      // TODO(benwells): Take the declared icon density and sizes into account.
+      WebApplicationInfo::IconInfo info;
+      info.url = icon.src;
+      web_app_info->icons.push_back(info);
+    }
+  }
+}
+
+// static
+std::map<int, BookmarkAppHelper::BitmapAndSource>
+BookmarkAppHelper::ConstrainBitmapsToSizes(
+    const std::vector<BookmarkAppHelper::BitmapAndSource>& bitmaps,
+    const std::set<int>& sizes) {
+  std::map<int, BitmapAndSource> output_bitmaps;
+  std::map<int, BitmapAndSource> ordered_bitmaps;
+  for (const BitmapAndSource& bitmap_and_source : bitmaps) {
+    const SkBitmap& bitmap = bitmap_and_source.bitmap;
+    DCHECK(bitmap.width() == bitmap.height());
+    ordered_bitmaps[bitmap.width()] = bitmap_and_source;
+  }
+
+  if (ordered_bitmaps.size() > 0) {
+    for (const auto& size : sizes) {
+      // Find the closest not-smaller bitmap, or failing that use the largest
+      // icon available.
+      auto bitmaps_it = ordered_bitmaps.lower_bound(size);
+      if (bitmaps_it != ordered_bitmaps.end())
+        output_bitmaps[size] = bitmaps_it->second;
+      else
+        output_bitmaps[size] = ordered_bitmaps.rbegin()->second;
+
+      // Resize the bitmap if it does not exactly match the desired size.
+      if (output_bitmaps[size].bitmap.width() != size) {
+        output_bitmaps[size].bitmap = skia::ImageOperations::Resize(
+            output_bitmaps[size].bitmap, skia::ImageOperations::RESIZE_LANCZOS3,
+            size, size);
+      }
+    }
+  }
+
+  return output_bitmaps;
+}
+
+// static
+void BookmarkAppHelper::GenerateIcon(
+    std::map<int, BookmarkAppHelper::BitmapAndSource>* bitmaps,
+    int output_size,
+    SkColor color,
+    char letter) {
+  // Do nothing if there is already an icon of |output_size|.
+  if (bitmaps->count(output_size))
+    return;
+
+  gfx::ImageSkia icon_image(
+      std::make_unique<GeneratedIconImageSource>(letter, color, output_size),
+      gfx::Size(output_size, output_size));
+  SkBitmap& dst = (*bitmaps)[output_size].bitmap;
+  if (dst.tryAllocPixels(icon_image.bitmap()->info())) {
+    icon_image.bitmap()->readPixels(dst.info(), dst.getPixels(), dst.rowBytes(),
+                                    0, 0);
+  }
+}
+
+// static
+bool BookmarkAppHelper::BookmarkOrHostedAppInstalled(
+    content::BrowserContext* browser_context,
+    const GURL& url) {
+  ExtensionRegistry* registry = ExtensionRegistry::Get(browser_context);
+  const ExtensionSet& extensions = registry->enabled_extensions();
+
+  // Iterate through the extensions and extract the LaunchWebUrl (bookmark apps)
+  // or check the web extent (hosted apps).
+  for (const scoped_refptr<const Extension>& extension : extensions) {
+    if (!extension->is_hosted_app())
+      continue;
+
+    if (extension->web_extent().MatchesURL(url) ||
+        AppLaunchInfo::GetLaunchWebURL(extension.get()) == url) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// static
+std::map<int, BookmarkAppHelper::BitmapAndSource>
+BookmarkAppHelper::ResizeIconsAndGenerateMissing(
+    std::vector<BookmarkAppHelper::BitmapAndSource> icons,
+    std::set<int> sizes_to_generate,
+    WebApplicationInfo* web_app_info) {
+  // Resize provided icons to make sure we have versions for each size in
+  // |sizes_to_generate|.
+  std::map<int, BitmapAndSource> resized_bitmaps(
+      ConstrainBitmapsToSizes(icons, sizes_to_generate));
+
+  // Also add all provided icon sizes.
+  for (const BitmapAndSource& icon : icons) {
+    if (resized_bitmaps.find(icon.bitmap.width()) == resized_bitmaps.end())
+      resized_bitmaps.insert(std::make_pair(icon.bitmap.width(), icon));
+  }
+
+  // Determine the color that will be used for the icon's background. For this
+  // the dominant color of the first icon found is used.
+  if (resized_bitmaps.size()) {
+    color_utils::GridSampler sampler;
+    web_app_info->generated_icon_color =
+        color_utils::CalculateKMeanColorOfBitmap(
+            resized_bitmaps.begin()->second.bitmap);
+  }
+
+  // Work out what icons we need to generate here. Icons are only generated if
+  // there is no icon in the required size.
+  std::set<int> generate_sizes;
+  for (int size : sizes_to_generate) {
+    if (resized_bitmaps.find(size) == resized_bitmaps.end())
+      generate_sizes.insert(size);
+  }
+  GenerateIcons(generate_sizes, web_app_info->app_url,
+                web_app_info->generated_icon_color, &resized_bitmaps);
+
+  return resized_bitmaps;
+}
+
+// static
+void BookmarkAppHelper::UpdateWebAppIconsWithoutChangingLinks(
+    std::map<int, BookmarkAppHelper::BitmapAndSource> bitmap_map,
+    WebApplicationInfo* web_app_info) {
+  // First add in the icon data that have urls with the url / size data from the
+  // original web app info, and the data from the new icons (if any).
+  for (auto& icon : web_app_info->icons) {
+    if (!icon.url.is_empty() && icon.data.empty()) {
+      const auto& it = bitmap_map.find(icon.width);
+      if (it != bitmap_map.end() && it->second.source_url == icon.url)
+        icon.data = it->second.bitmap;
+    }
+  }
+
+  // Now add in any icons from the updated list that don't have URLs.
+  for (const auto& pair : bitmap_map) {
+    if (pair.second.source_url.is_empty()) {
+      WebApplicationInfo::IconInfo icon_info;
+      icon_info.data = pair.second.bitmap;
+      icon_info.width = pair.first;
+      icon_info.height = pair.first;
+      web_app_info->icons.push_back(icon_info);
+    }
+  }
+}
+
+BookmarkAppHelper::BitmapAndSource::BitmapAndSource() {
+}
+
+BookmarkAppHelper::BitmapAndSource::BitmapAndSource(const GURL& source_url_p,
+                                                    const SkBitmap& bitmap_p)
+    : source_url(source_url_p),
+      bitmap(bitmap_p) {
+}
+
+BookmarkAppHelper::BitmapAndSource::~BitmapAndSource() {
+}
+
+BookmarkAppHelper::BookmarkAppHelper(Profile* profile,
+                                     WebApplicationInfo web_app_info,
+                                     content::WebContents* contents,
+                                     WebappInstallSource install_source)
+    : profile_(profile),
+      contents_(contents),
+      web_app_info_(web_app_info),
+      crx_installer_(extensions::CrxInstaller::CreateSilent(
+          ExtensionSystem::Get(profile)->extension_service())),
+      install_source_(install_source),
+      weak_factory_(this) {
+  if (contents)
+    installable_manager_ = InstallableManager::FromWebContents(contents);
+
+  // Use the last bookmark app creation type. The launch container is decided by
+  // the system for desktop PWAs.
+  if (!base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {
+    web_app_info_.open_as_window =
+        profile_->GetPrefs()->GetInteger(
+            extensions::pref_names::kBookmarkAppCreationLaunchType) ==
+        extensions::LAUNCH_TYPE_WINDOW;
+  }
+
+  // The default app title is the page title, which can be quite long. Limit the
+  // default name used to something sensible.
+  const int kMaxDefaultTitle = 40;
+  if (web_app_info_.title.length() > kMaxDefaultTitle) {
+    web_app_info_.title = web_app_info_.title.substr(0, kMaxDefaultTitle - 3) +
+                          base::UTF8ToUTF16("...");
+  }
+
+  registrar_.Add(this,
+                 extensions::NOTIFICATION_CRX_INSTALLER_DONE,
+                 content::Source<CrxInstaller>(crx_installer_.get()));
+
+  registrar_.Add(this,
+                 extensions::NOTIFICATION_EXTENSION_INSTALL_ERROR,
+                 content::Source<CrxInstaller>(crx_installer_.get()));
+
+  crx_installer_->set_error_on_unsupported_requirements(true);
+}
+
+BookmarkAppHelper::~BookmarkAppHelper() {}
+
+void BookmarkAppHelper::Create(const CreateBookmarkAppCallback& callback) {
+  callback_ = callback;
+
+  // Do not fetch the manifest for extension URLs.
+  if (contents_ &&
+      !contents_->GetVisibleURL().SchemeIs(extensions::kExtensionScheme)) {
+    // Null in tests. OnDidPerformInstallableCheck is called via a testing API.
+    // TODO(crbug.com/829232) ensure this is consistent with other calls to
+    // GetData.
+    if (installable_manager_) {
+      InstallableParams params;
+      params.check_eligibility = true;
+      params.valid_primary_icon = true;
+      params.valid_manifest = true;
+      // Do not wait for a service worker if it doesn't exist.
+      params.has_worker = true;
+      installable_manager_->GetData(
+          params, base::Bind(&BookmarkAppHelper::OnDidPerformInstallableCheck,
+                             weak_factory_.GetWeakPtr()));
+    }
+  } else {
+    for_installable_site_ = ForInstallableSite::kNo;
+    OnIconsDownloaded(true, std::map<GURL, std::vector<SkBitmap>>());
+  }
+}
+
+void BookmarkAppHelper::OnDidPerformInstallableCheck(
+    const InstallableData& data) {
+  DCHECK(data.manifest_url.is_valid() || data.manifest->IsEmpty());
+
+  if (contents_->IsBeingDestroyed())
+    return;
+
+  for_installable_site_ = data.error_code == NO_ERROR_DETECTED
+                              ? ForInstallableSite::kYes
+                              : ForInstallableSite::kNo;
+
+  UpdateWebAppInfoFromManifest(*data.manifest, &web_app_info_,
+                               for_installable_site_);
+
+  // TODO(mgiuca): Web Share Target should have its own flag, rather than using
+  // the experimental-web-platform-features flag. https://crbug.com/736178.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kEnableExperimentalWebPlatformFeatures)) {
+    UpdateShareTargetInPrefs(data.manifest_url, *data.manifest,
+                             profile_->GetPrefs());
+  }
+
+  // Add icon urls to download from the WebApplicationInfo.
+  std::vector<GURL> web_app_info_icon_urls;
+  for (auto& info : web_app_info_.icons) {
+    if (!info.url.is_valid())
+      continue;
+
+    // Skip downloading icon if we already have it from the InstallableManager.
+    if (info.url == data.primary_icon_url && data.primary_icon)
+      continue;
+
+    web_app_info_icon_urls.push_back(info.url);
+  }
+
+  // Add the primary icon to the final bookmark app creation data.
+  if (data.primary_icon_url.is_valid()) {
+    WebApplicationInfo::IconInfo primary_icon_info;
+    const SkBitmap& icon = *data.primary_icon;
+    primary_icon_info.url = data.primary_icon_url;
+    primary_icon_info.data = icon;
+    primary_icon_info.width = icon.width();
+    primary_icon_info.height = icon.height();
+    web_app_info_.icons.push_back(primary_icon_info);
+  }
+
+  favicon_downloader_.reset(new FaviconDownloader(
+      contents_, web_app_info_icon_urls,
+      "Extensions.BookmarkApp.Icon.HttpStatusCodeClassOnCreate",
+      base::BindOnce(&BookmarkAppHelper::OnIconsDownloaded,
+                     weak_factory_.GetWeakPtr())));
+
+  // If the manifest specified icons, don't use the page icons.
+  if (!data.manifest->icons.empty())
+    favicon_downloader_->SkipPageFavicons();
+
+  favicon_downloader_->Start();
+}
+
+void BookmarkAppHelper::OnIconsDownloaded(
+    bool success,
+    const std::map<GURL, std::vector<SkBitmap>>& bitmaps) {
+  // The tab has navigated away during the icon download. Cancel the bookmark
+  // app creation.
+  if (!success) {
+    favicon_downloader_.reset();
+    callback_.Run(nullptr, web_app_info_);
+    return;
+  }
+
+  std::vector<BitmapAndSource> downloaded_icons;
+  for (const std::pair<GURL, std::vector<SkBitmap>>& url_bitmap : bitmaps) {
+    for (const SkBitmap& bitmap : url_bitmap.second) {
+      if (bitmap.empty() || bitmap.width() != bitmap.height())
+        continue;
+
+      downloaded_icons.push_back(BitmapAndSource(url_bitmap.first, bitmap));
+    }
+  }
+
+  // Add all existing icons from WebApplicationInfo.
+  for (const WebApplicationInfo::IconInfo& icon_info : web_app_info_.icons) {
+    const SkBitmap& icon = icon_info.data;
+    if (!icon.drawsNothing() && icon.width() == icon.height()) {
+      downloaded_icons.push_back(BitmapAndSource(icon_info.url, icon));
+    }
+  }
+
+  // Ensure that the necessary-sized icons are available by resizing larger
+  // icons down to smaller sizes, and generating icons for sizes where resizing
+  // is not possible.
+  web_app_info_.generated_icon_color = SK_ColorTRANSPARENT;
+  std::map<int, BitmapAndSource> size_to_icons = ResizeIconsAndGenerateMissing(
+      downloaded_icons, SizesToGenerate(), &web_app_info_);
+  ReplaceWebAppIcons(size_to_icons, &web_app_info_);
+  favicon_downloader_.reset();
+
+  if (!contents_) {
+    // The web contents can be null in tests.
+    OnBubbleCompleted(true, web_app_info_);
+    return;
+  }
+
+  Browser* browser = chrome::FindBrowserWithWebContents(contents_);
+  if (!browser) {
+    // The browser can be null in tests.
+    OnBubbleCompleted(true, web_app_info_);
+    return;
+  }
+
+  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing) &&
+      for_installable_site_ == ForInstallableSite::kYes) {
+    web_app_info_.open_as_window = true;
+    chrome::ShowPWAInstallDialog(
+        contents_, web_app_info_,
+        base::BindOnce(&BookmarkAppHelper::OnBubbleCompleted,
+                       weak_factory_.GetWeakPtr()));
+  } else {
+    chrome::ShowBookmarkAppDialog(
+        contents_, web_app_info_,
+        base::BindOnce(&BookmarkAppHelper::OnBubbleCompleted,
+                       weak_factory_.GetWeakPtr()));
+  }
+}
+
+void BookmarkAppHelper::OnBubbleCompleted(
+    bool user_accepted,
+    const WebApplicationInfo& web_app_info) {
+  if (user_accepted) {
+    web_app_info_ = web_app_info;
+    crx_installer_->InstallWebApp(web_app_info_);
+
+    if (InstallableMetrics::IsReportableInstallSource(install_source_) &&
+        for_installable_site_ == ForInstallableSite::kYes) {
+      InstallableMetrics::TrackInstallEvent(install_source_);
+    }
+  } else {
+    callback_.Run(nullptr, web_app_info_);
+  }
+}
+
+void BookmarkAppHelper::FinishInstallation(const Extension* extension) {
+  // Set the default 'open as' preference for use next time the dialog is
+  // shown.
+  extensions::LaunchType launch_type = web_app_info_.open_as_window
+                                           ? extensions::LAUNCH_TYPE_WINDOW
+                                           : extensions::LAUNCH_TYPE_REGULAR;
+
+  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {
+    DCHECK_NE(ForInstallableSite::kUnknown, for_installable_site_);
+    launch_type = for_installable_site_ == ForInstallableSite::kYes
+                      ? extensions::LAUNCH_TYPE_WINDOW
+                      : extensions::LAUNCH_TYPE_REGULAR;
+  }
+  profile_->GetPrefs()->SetInteger(
+      extensions::pref_names::kBookmarkAppCreationLaunchType, launch_type);
+
+  // Set the launcher type for the app.
+  extensions::SetLaunchType(profile_, extension->id(), launch_type);
+
+  if (!contents_) {
+    // The web contents can be null in tests.
+    callback_.Run(extension, web_app_info_);
+    return;
+  }
+
+  // Record an app banner added to homescreen event to ensure banners are not
+  // shown for this app.
+  AppBannerSettingsHelper::RecordBannerEvent(
+      contents_, web_app_info_.app_url, web_app_info_.app_url.spec(),
+      AppBannerSettingsHelper::APP_BANNER_EVENT_DID_ADD_TO_HOMESCREEN,
+      base::Time::Now());
+
+  Browser* browser = chrome::FindBrowserWithWebContents(contents_);
+  if (!browser) {
+    // The browser can be null in tests.
+    callback_.Run(extension, web_app_info_);
+    return;
+  }
+
+#if !defined(OS_CHROMEOS)
+  // Pin the app to the relevant launcher depending on the OS.
+  Profile* current_profile = profile_->GetOriginalProfile();
+#endif  // !defined(OS_CHROMEOS)
+
+// On Mac, shortcuts are automatically created for hosted apps when they are
+// installed, so there is no need to create them again.
+#if !defined(OS_MACOSX)
+#if !defined(OS_CHROMEOS)
+  web_app::ShortcutLocations creation_locations;
+#if defined(OS_LINUX) || defined(OS_WIN)
+  creation_locations.on_desktop = true;
+#else
+  creation_locations.on_desktop = false;
+#endif
+  creation_locations.applications_menu_location =
+      web_app::APP_MENU_LOCATION_SUBDIR_CHROMEAPPS;
+  creation_locations.in_quick_launch_bar = false;
+  web_app::CreateShortcuts(web_app::SHORTCUT_CREATION_BY_USER,
+                           creation_locations, current_profile, extension);
+#else
+  ChromeLauncherController::instance()->shelf_model()->PinAppWithID(
+      extension->id());
+#endif  // !defined(OS_CHROMEOS)
+
+  // Reparent the tab into an app window immediately when opening as a window.
+  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing) &&
+      launch_type == extensions::LAUNCH_TYPE_WINDOW &&
+      !profile_->IsOffTheRecord()) {
+    ReparentWebContentsIntoAppBrowser(contents_, extension);
+  }
+#endif  // !defined(OS_MACOSX)
+
+#if defined(OS_MACOSX)
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+                 switches::kDisableHostedAppShimCreation)) {
+    web_app::RevealAppShimInFinderForApp(current_profile, extension);
+  }
+#endif
+
+  callback_.Run(extension, web_app_info_);
+}
+
+void BookmarkAppHelper::Observe(int type,
+                                const content::NotificationSource& source,
+                                const content::NotificationDetails& details) {
+  // TODO(dominickn): bookmark app creation fails when extensions cannot be
+  // created (e.g. due to management policies). Add to shelf visibility should
+  // be gated on whether extensions can be created - see crbug.com/545541.
+  switch (type) {
+    case extensions::NOTIFICATION_CRX_INSTALLER_DONE: {
+      const Extension* extension =
+          content::Details<const Extension>(details).ptr();
+      if (extension) {
+        DCHECK_EQ(AppLaunchInfo::GetLaunchWebURL(extension),
+                  web_app_info_.app_url);
+        FinishInstallation(extension);
+      } else {
+        callback_.Run(nullptr, web_app_info_);
+      }
+      break;
+    }
+    case extensions::NOTIFICATION_EXTENSION_INSTALL_ERROR:
+      callback_.Run(nullptr, web_app_info_);
+      break;
+    default:
+      NOTREACHED();
+      break;
+  }
+}
+
+void CreateOrUpdateBookmarkApp(ExtensionService* service,
+                               WebApplicationInfo* web_app_info) {
+  scoped_refptr<BookmarkAppInstaller> installer(
+      new BookmarkAppInstaller(service, *web_app_info));
+  installer->Run();
+}
+
+bool IsValidBookmarkAppUrl(const GURL& url) {
+  URLPattern origin_only_pattern(Extension::kValidBookmarkAppSchemes);
+  origin_only_pattern.SetMatchAllURLs(true);
+  return url.is_valid() && origin_only_pattern.MatchesURL(url);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/chrome_extensions_browser_client.cc b/chrome/browser/extensions/chrome_extensions_browser_client.cc
index d756f63cbc39..a343a02cd764 100644
--- a/chrome/browser/extensions/chrome_extensions_browser_client.cc
+++ b/chrome/browser/extensions/chrome_extensions_browser_client.cc
@@ -90,13 +90,20 @@ bool ExtensionsDisabled(const base::CommandLine& command_line) {
 }  // namespace
 
 ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient() {
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 1";
   AddAPIProvider(std::make_unique<CoreExtensionsBrowserAPIProvider>());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 2";
   AddAPIProvider(std::make_unique<ChromeExtensionsBrowserAPIProvider>());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 3";
 
   process_manager_delegate_.reset(new ChromeProcessManagerDelegate);
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 4";
   api_client_.reset(new ChromeExtensionsAPIClient);
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 5";
   SetCurrentChannel(chrome::GetChannel());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 6";
   resource_manager_.reset(new ChromeComponentExtensionResourceManager());
+  LOG(ERROR) << "ChromeExtensionsBrowserClient::ChromeExtensionsBrowserClient - Step 7";
 }
 
 ChromeExtensionsBrowserClient::~ChromeExtensionsBrowserClient() {}
diff --git a/chrome/browser/extensions/chrome_process_manager_delegate.cc b/chrome/browser/extensions/chrome_process_manager_delegate.cc
index 2cfdb3380c10..3a94e6568f3d 100644
--- a/chrome/browser/extensions/chrome_process_manager_delegate.cc
+++ b/chrome/browser/extensions/chrome_process_manager_delegate.cc
@@ -30,6 +30,7 @@
 namespace extensions {
 
 ChromeProcessManagerDelegate::ChromeProcessManagerDelegate() {
+  LOG(ERROR) << "[Kiwi] ChromeProcessManagerDelegate::ChromeProcessManagerDelegate - Step 1";
   BrowserList::AddObserver(this);
   DCHECK(g_browser_process);
   // The profile manager can be null in unit tests.
diff --git a/chrome/browser/extensions/extension_install_prompt.cc b/chrome/browser/extensions/extension_install_prompt.cc
index 613f22f4fee6..3e60ccfe7234 100644
--- a/chrome/browser/extensions/extension_install_prompt.cc
+++ b/chrome/browser/extensions/extension_install_prompt.cc
@@ -20,6 +20,9 @@
 #include "chrome/browser/ui/extensions/extension_install_ui_factory.h"
 #include "chrome/grit/generated_resources.h"
 #include "chrome/grit/theme_resources.h"
+#include "components/app_modal/javascript_app_modal_dialog.h"
+#include "components/app_modal/javascript_dialog_manager.h"
+#include "components/app_modal/native_app_modal_dialog.h"
 #include "components/strings/grit/components_strings.h"
 #include "content/public/browser/web_contents.h"
 #include "extensions/browser/disable_reason.h"
@@ -379,6 +382,17 @@ base::string16 ExtensionInstallPrompt::Prompt::GetUserCount() const {
   return base::string16();
 }
 
+base::string16 ExtensionInstallPrompt::Prompt::GetPermissionsAsString() const {
+  base::string16 result = base::string16();
+  result = result + GetDialogTitle() + base::ASCIIToUTF16("\n") + base::ASCIIToUTF16("\n");
+  result = result + GetPermissionsHeading() + base::ASCIIToUTF16("\n") + base::ASCIIToUTF16("\n");
+  result = result + base::JoinString(prompt_permissions_.permissions,
+                                     base::ASCIIToUTF16("\n")) + base::ASCIIToUTF16("\n");
+  result = result + base::JoinString(prompt_permissions_.details,
+                                     base::ASCIIToUTF16("\n"));
+  return result;
+}
+
 size_t ExtensionInstallPrompt::Prompt::GetPermissionCount() const {
   return prompt_permissions_.permissions.size();
 }
@@ -488,6 +502,7 @@ ExtensionInstallPrompt::ExtensionInstallPrompt(content::WebContents* contents)
                    : nullptr),
       extension_(nullptr),
       install_ui_(extensions::CreateExtensionInstallUI(profile_)),
+      contents_(contents),
       show_params_(new ExtensionInstallPromptShowParams(contents)),
       did_call_show_dialog_(false) {}
 
@@ -609,6 +624,37 @@ void ExtensionInstallPrompt::LoadImageIfNeeded() {
                                          weak_factory_.GetWeakPtr()));
 }
 
+// Ensures that OnDialogClosed is only called once.
+class CloseDialogCallbackWrapper
+    : public base::RefCountedThreadSafe<CloseDialogCallbackWrapper> {
+ public:
+  explicit CloseDialogCallbackWrapper(ExtensionInstallPrompt::DoneCallback callback)
+      : callback_(std::move(callback)) {}
+
+  void Run(bool dialog_was_suppressed,
+           bool success,
+           const base::string16& user_input) {
+  if (success) {
+    LOG(INFO) << "[EXTENSIONS] We received result from extension dialog (ACCEPTED)";
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+         FROM_HERE, base::BindOnce(std::move(callback_),
+                                  ExtensionInstallPrompt::Result::ACCEPTED));
+  } else {
+    LOG(INFO) << "[EXTENSIONS] We received result from extension dialog (REJECTED)";
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+         FROM_HERE,
+         base::BindOnce(std::move(callback_),
+                        ExtensionInstallPrompt::Result::USER_CANCELED));
+  }
+  }
+
+ private:
+  friend class base::RefCountedThreadSafe<CloseDialogCallbackWrapper>;
+  ~CloseDialogCallbackWrapper() {}
+
+  ExtensionInstallPrompt::DoneCallback callback_;
+};
+
 void ExtensionInstallPrompt::ShowConfirmation() {
   std::unique_ptr<const PermissionSet> permissions_wrapper;
   const PermissionSet* permissions_to_display = nullptr;
@@ -659,6 +705,23 @@ void ExtensionInstallPrompt::ShowConfirmation() {
   if (AutoConfirmPromptIfEnabled())
     return;
 
+  if (contents_) {
+    LOG(INFO) << "[EXTENSIONS] contents_ is not empty, displaying prompt";
+    scoped_refptr<CloseDialogCallbackWrapper> wrapper = new CloseDialogCallbackWrapper(std::move(done_callback_));
+
+    if (permissions_to_display) {
+      bool ignored;
+      app_modal::JavaScriptDialogManager::GetInstance()->RunJavaScriptDialog(
+          contents_, contents_->GetMainFrame(), content::JAVASCRIPT_DIALOG_TYPE_CONFIRM,
+          prompt_->GetPermissionsAsString(), base::string16(),
+                   base::BindOnce(&CloseDialogCallbackWrapper::Run, wrapper, false),
+                   &ignored);
+    }
+  } else {
+    LOG(INFO) << "[EXTENSIONS] contents_ is empty, skipping prompt";
+  }
+
+#if 0
   if (show_dialog_callback_.is_null())
     show_dialog_callback_ = GetDefaultShowDialogCallback();
   // TODO(https://crbug.com/957713): Use OnceCallback and eliminate the need for
@@ -666,6 +729,7 @@ void ExtensionInstallPrompt::ShowConfirmation() {
   auto cb = std::move(done_callback_);
   std::move(show_dialog_callback_)
       .Run(show_params_.get(), cb, std::move(prompt_));
+#endif
 }
 
 bool ExtensionInstallPrompt::AutoConfirmPromptIfEnabled() {
diff --git a/chrome/browser/extensions/extension_install_prompt.h b/chrome/browser/extensions/extension_install_prompt.h
index dcea843a6d71..a0a5ecfb1162 100644
--- a/chrome/browser/extensions/extension_install_prompt.h
+++ b/chrome/browser/extensions/extension_install_prompt.h
@@ -19,6 +19,7 @@
 #include "base/strings/string16.h"
 #include "base/threading/thread_checker.h"
 #include "build/build_config.h"
+#include "components/app_modal/javascript_app_modal_dialog.h"
 #include "extensions/common/permissions/permission_message.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/gfx/image/image.h"
@@ -123,6 +124,7 @@ class ExtensionInstallPrompt {
     void AppendRatingStars(StarAppender appender, void* data) const;
     base::string16 GetRatingCount() const;
     base::string16 GetUserCount() const;
+    base::string16 GetPermissionsAsString() const;
     size_t GetPermissionCount() const;
     size_t GetPermissionsDetailsCount() const;
     base::string16 GetPermission(size_t index) const;
@@ -347,6 +349,8 @@ class ExtensionInstallPrompt {
   // The object responsible for doing the UI specific actions.
   std::unique_ptr<extensions::ExtensionInstallUI> install_ui_;
 
+  content::WebContents* contents_;
+
   // Parameters to show the confirmation UI.
   std::unique_ptr<ExtensionInstallPromptShowParams> show_params_;
 
diff --git a/chrome/browser/extensions/extension_install_prompt_show_params.cc b/chrome/browser/extensions/extension_install_prompt_show_params.cc
index 421bf95cad3d..ddcb8cd23c15 100644
--- a/chrome/browser/extensions/extension_install_prompt_show_params.cc
+++ b/chrome/browser/extensions/extension_install_prompt_show_params.cc
@@ -53,8 +53,6 @@ ExtensionInstallPromptShowParams::ExtensionInstallPromptShowParams(
     web_contents_destruction_observer_.reset(
         new WebContentsDestructionObserver(this));
   }
-  if (parent_window_)
-    native_window_tracker_ = NativeWindowTracker::Create(parent_window_);
 }
 
 ExtensionInstallPromptShowParams::ExtensionInstallPromptShowParams(
@@ -64,8 +62,6 @@ ExtensionInstallPromptShowParams::ExtensionInstallPromptShowParams(
     parent_web_contents_(nullptr),
     parent_web_contents_destroyed_(false),
     parent_window_(parent_window) {
-  if (parent_window_)
-    native_window_tracker_ = NativeWindowTracker::Create(parent_window_);
 }
 
 ExtensionInstallPromptShowParams::~ExtensionInstallPromptShowParams() {
diff --git a/chrome/browser/extensions/extension_uninstall_dialog.cc b/chrome/browser/extensions/extension_uninstall_dialog.cc
index e8953ab88e5b..87b2ef637722 100644
--- a/chrome/browser/extensions/extension_uninstall_dialog.cc
+++ b/chrome/browser/extensions/extension_uninstall_dialog.cc
@@ -71,8 +71,10 @@ ExtensionUninstallDialog::ExtensionUninstallDialog(
     gfx::NativeWindow parent,
     ExtensionUninstallDialog::Delegate* delegate)
     : profile_(profile), parent_(parent), delegate_(delegate) {
+#if 0
   if (parent)
     parent_window_tracker_ = NativeWindowTracker::Create(parent);
+#endif
 }
 
 ExtensionUninstallDialog::~ExtensionUninstallDialog() = default;
diff --git a/chrome/browser/extensions/global_shortcut_listener_android.cc b/chrome/browser/extensions/global_shortcut_listener_android.cc
new file mode 100644
index 000000000000..c1e8bbbfaa25
--- /dev/null
+++ b/chrome/browser/extensions/global_shortcut_listener_android.cc
@@ -0,0 +1,64 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/global_shortcut_listener_android.h"
+
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+
+namespace extensions {
+
+// static
+GlobalShortcutListener* GlobalShortcutListener::GetInstance() {
+  CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+  static GlobalShortcutListenerAndroid* instance =
+      new GlobalShortcutListenerAndroid();
+  return instance;
+}
+
+GlobalShortcutListenerAndroid::GlobalShortcutListenerAndroid()
+    : is_listening_(false) {
+  CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+
+  // TODO(implementor): Remove this.
+  LOG(ERROR) << "GlobalShortcutListenerAndroid object created";
+}
+
+GlobalShortcutListenerAndroid::~GlobalShortcutListenerAndroid() {
+  if (is_listening_)
+    StopListening();
+}
+
+void GlobalShortcutListenerAndroid::StartListening() {
+  DCHECK(!is_listening_);  // Don't start twice.
+  NOTIMPLEMENTED();
+  is_listening_ = true;
+}
+
+void GlobalShortcutListenerAndroid::StopListening() {
+  DCHECK(is_listening_);  // No point if we are not already listening.
+  NOTIMPLEMENTED();
+  is_listening_ = false;
+}
+
+bool GlobalShortcutListenerAndroid::RegisterAcceleratorImpl(
+    const ui::Accelerator& accelerator) {
+  NOTIMPLEMENTED();
+  // To implement:
+  // 1) Convert modifiers to platform specific modifiers.
+  // 2) Register for the hotkey.
+  // 3) If not successful, return false.
+  // 4) Else, return true.
+
+  return false;
+}
+
+void GlobalShortcutListenerAndroid::UnregisterAcceleratorImpl(
+    const ui::Accelerator& accelerator) {
+  NOTIMPLEMENTED();
+  // To implement: Unregister for the hotkey.
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/global_shortcut_listener_android.h b/chrome/browser/extensions/global_shortcut_listener_android.h
new file mode 100644
index 000000000000..8cfa82509fd2
--- /dev/null
+++ b/chrome/browser/extensions/global_shortcut_listener_android.h
@@ -0,0 +1,36 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
+
+#include "base/macros.h"
+#include "chrome/browser/extensions/global_shortcut_listener.h"
+
+namespace extensions {
+
+// Android-specific implementation of the GlobalShortcutListener class that
+// listens for global shortcuts. Handles basic keyboard intercepting and
+// forwards its output to the base class for processing.
+class GlobalShortcutListenerAndroid : public GlobalShortcutListener {
+ public:
+  GlobalShortcutListenerAndroid();
+  ~GlobalShortcutListenerAndroid() override;
+
+ private:
+  // GlobalShortcutListener implementation.
+  void StartListening() override;
+  void StopListening() override;
+  bool RegisterAcceleratorImpl(const ui::Accelerator& accelerator) override;
+  void UnregisterAcceleratorImpl(const ui::Accelerator& accelerator) override;
+
+  // Whether this object is listening for global shortcuts.
+  bool is_listening_;
+
+  DISALLOW_COPY_AND_ASSIGN(GlobalShortcutListenerAndroid);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
diff --git a/chrome/browser/extensions/system_display/display_info_provider_android.cc b/chrome/browser/extensions/system_display/display_info_provider_android.cc
new file mode 100644
index 000000000000..a2edbd695ed6
--- /dev/null
+++ b/chrome/browser/extensions/system_display/display_info_provider_android.cc
@@ -0,0 +1,17 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/system_display/display_info_provider_android.h"
+
+namespace extensions {
+
+DisplayInfoProviderAndroid::DisplayInfoProviderAndroid() = default;
+
+// static
+std::unique_ptr<DisplayInfoProvider> CreateChromeDisplayInfoProvider() {
+  return std::make_unique<DisplayInfoProviderAndroid>();
+}
+
+}  // namespace extensions
+
diff --git a/chrome/browser/extensions/system_display/display_info_provider_android.h b/chrome/browser/extensions/system_display/display_info_provider_android.h
new file mode 100644
index 000000000000..7cd339ce6d2e
--- /dev/null
+++ b/chrome/browser/extensions/system_display/display_info_provider_android.h
@@ -0,0 +1,24 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+
+#include "base/macros.h"
+#include "extensions/browser/api/system_display/display_info_provider.h"
+
+namespace extensions {
+
+class DisplayInfoProviderAndroid : public DisplayInfoProvider {
+ public:
+  DisplayInfoProviderAndroid();
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DisplayInfoProviderAndroid);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+
diff --git a/chrome/browser/first_run/first_run_dialog.h b/chrome/browser/first_run/first_run_dialog.h
index ac9e76fb6044..25c288c899b7 100644
--- a/chrome/browser/first_run/first_run_dialog.h
+++ b/chrome/browser/first_run/first_run_dialog.h
@@ -9,7 +9,7 @@
 #include "build/build_config.h"
 
 // Hide this function on platforms where the dialog does not exist.
-#if defined(OS_MACOSX) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if true || defined(OS_MACOSX) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 
 class Profile;
 
diff --git a/chrome/browser/first_run/upgrade_util.h b/chrome/browser/first_run/upgrade_util.h
index 859b9a096342..a1705d552cb0 100644
--- a/chrome/browser/first_run/upgrade_util.h
+++ b/chrome/browser/first_run/upgrade_util.h
@@ -10,10 +10,6 @@
 #include "base/callback_forward.h"
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID) || defined(OS_CHROMEOS)
-#error Not used on Android or ChromeOS
-#endif
-
 namespace base {
 class CommandLine;
 }
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index 3d2c833c5bcd..7795bd08d81b 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -2853,8 +2853,6 @@ const char kAndroidNightModeDescription[] =
 
 // Non-Android -----------------------------------------------------------------
 
-#else  // !defined(OS_ANDROID)
-
 const char kShowSyncPausedReasonCookiesClearedOnExitName[] =
     "Show sync paused reason is the setup of cookie settings.";
 const char kShowSyncPausedReasonCookiesClearedOnExitDescription[] =
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index ead5a211c65a..5a07bef82a42 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1669,8 +1669,6 @@ extern const char kAndroidNightModeDescription[];
 
 // Non-Android ----------------------------------------------------------------
 
-#else  // !defined(OS_ANDROID)
-
 extern const char kShowSyncPausedReasonCookiesClearedOnExitName[];
 extern const char kShowSyncPausedReasonCookiesClearedOnExitDescription[];
 
diff --git a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc
index 95c306cc0c1a..c44940a0a4ac 100644
--- a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc
+++ b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.cc
@@ -87,10 +87,12 @@ void ChromeWebViewPermissionHelperDelegate::OnPermissionResponse(
     const std::string& identifier,
     bool allow,
     const std::string& input) {
+#if 0
   if (allow) {
     ChromePluginServiceFilter::GetInstance()->AuthorizeAllPlugins(
         web_contents(), true, identifier);
   }
+#endif
 }
 
 #endif  // BUILDFLAG(ENABLE_PLUGINS)
diff --git a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h
index 40ae43bedc11..b3a8ff24c293 100644
--- a/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h
+++ b/chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h
@@ -14,7 +14,7 @@
 #include "ppapi/buildflags/buildflags.h"
 #include "third_party/blink/public/mojom/permissions/permission_status.mojom.h"
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
 #include "chrome/common/plugin.mojom.h"
 #endif
 
@@ -51,7 +51,7 @@ class ChromeWebViewPermissionHelperDelegate
       const GURL& url,
       bool allowed_by_default,
       base::OnceCallback<void(bool)> callback) override;
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
   // content::WebContentsObserver implementation.
   bool OnMessageReceived(const IPC::Message& message,
                          content::RenderFrameHost* render_frame_host) override;
diff --git a/chrome/browser/media/router/BUILD.gn b/chrome/browser/media/router/BUILD.gn
index 6ac998b85586..0c9cb12e6b30 100644
--- a/chrome/browser/media/router/BUILD.gn
+++ b/chrome/browser/media/router/BUILD.gn
@@ -209,7 +209,7 @@ static_library("test_support") {
     "test/test_helper.h",
   ]
 
-  if (enable_extensions) {
+  if (false && enable_extensions) {
     deps += [
       "discovery",
       "//chrome/common/media_router/mojom:media_router",
diff --git a/chrome/browser/media/router/discovery/BUILD.gn b/chrome/browser/media/router/discovery/BUILD.gn
index c5e3bf578869..c9358cc04d0f 100644
--- a/chrome/browser/media/router/discovery/BUILD.gn
+++ b/chrome/browser/media/router/discovery/BUILD.gn
@@ -2,8 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android)
-
 static_library("discovery") {
   inputs = [
     "$root_gen_dir/chrome/grit/generated_resources.h",
@@ -77,7 +75,7 @@ static_library("discovery") {
     sources += [ "discovery_network_list_wifi_linux.cc" ]
   }
 
-  if (is_posix) {
+  if (false && is_posix) {
     sources += [ "discovery_network_list_posix.cc" ]
   }
 
diff --git a/chrome/browser/media/router/media_router.h b/chrome/browser/media/router/media_router.h
index 07f9eed08322..226f382fd3da 100644
--- a/chrome/browser/media/router/media_router.h
+++ b/chrome/browser/media/router/media_router.h
@@ -27,7 +27,7 @@
 #include "media/base/flinging_controller.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
@@ -198,7 +198,7 @@ class MediaRouter : public KeyedService {
   virtual std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) = 0;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Binds |controller| for sending media commands to a route. The controller
   // will notify |observer| whenever there is a change to the status of the
   // media. It may invalidate bindings from previous calls to this method.
diff --git a/chrome/browser/media/router/media_router_base.cc b/chrome/browser/media/router/media_router_base.cc
index 24d66af2167a..04a945f7dc71 100644
--- a/chrome/browser/media/router/media_router_base.cc
+++ b/chrome/browser/media/router/media_router_base.cc
@@ -88,7 +88,7 @@ MediaRouterBase::GetFlingingController(const MediaRoute::Id& route_id) {
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void MediaRouterBase::GetMediaController(
     const MediaRoute::Id& route_id,
     mojo::PendingReceiver<mojom::MediaController> controller,
diff --git a/chrome/browser/media/router/media_router_base.h b/chrome/browser/media/router/media_router_base.h
index c4338a957bed..55af77f89a1e 100644
--- a/chrome/browser/media/router/media_router_base.h
+++ b/chrome/browser/media/router/media_router_base.h
@@ -19,7 +19,7 @@
 #include "chrome/common/media_router/media_route.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
@@ -42,7 +42,7 @@ class MediaRouterBase : public MediaRouter {
   std::vector<MediaRoute> GetCurrentRoutes() const override;
   std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   void GetMediaController(
       const MediaRoute::Id& route_id,
       mojo::PendingReceiver<mojom::MediaController> controller,
diff --git a/chrome/browser/media/router/media_router_feature.cc b/chrome/browser/media/router/media_router_feature.cc
index 2d478addf60e..9095d2a30aec 100644
--- a/chrome/browser/media/router/media_router_feature.cc
+++ b/chrome/browser/media/router/media_router_feature.cc
@@ -23,13 +23,13 @@
 #include "components/user_prefs/user_prefs.h"
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "components/prefs/pref_registry_simple.h"
 #endif
 
 namespace media_router {
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Controls if browser side DialMediaRouteProvider is enabled.
 const base::Feature kDialMediaRouteProvider{"DialMediaRouteProvider",
                                             base::FEATURE_ENABLED_BY_DEFAULT};
@@ -67,7 +67,7 @@ bool MediaRouterEnabled(content::BrowserContext* context) {
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void RegisterLocalStatePrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kMediaRouterCastAllowAllIPs, false,
                                 PrefRegistry::PUBLIC);
diff --git a/chrome/browser/media/router/media_router_feature.h b/chrome/browser/media/router/media_router_feature.h
index bc1d4b51e60f..1f429d03dea4 100644
--- a/chrome/browser/media/router/media_router_feature.h
+++ b/chrome/browser/media/router/media_router_feature.h
@@ -19,7 +19,7 @@ namespace media_router {
 // Returns true if Media Router is enabled for |context|.
 bool MediaRouterEnabled(content::BrowserContext* context);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 
 // TODO(crbug.com/1028753): Remove default-enabled kDialMediaRouteProvider after
 // tests stop disabling it.
diff --git a/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc b/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
index 954ce6977683..1543cc5af246 100644
--- a/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
+++ b/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
@@ -114,13 +114,6 @@ MediaCaptureDevicesDispatcher::MediaCaptureDevicesDispatcher()
 #endif
   media_access_handlers_.push_back(
       std::make_unique<DesktopCaptureAccessHandler>());
-#if defined(OS_CHROMEOS)
-  // Wrapper around TabCaptureAccessHandler used in Public Sessions.
-  media_access_handlers_.push_back(
-      std::make_unique<PublicSessionTabCaptureAccessHandler>());
-#else
-  media_access_handlers_.push_back(std::make_unique<TabCaptureAccessHandler>());
-#endif
 #endif
   media_access_handlers_.push_back(
       std::make_unique<PermissionBubbleMediaAccessHandler>());
diff --git a/chrome/browser/metrics/chrome_feature_list_creator.cc b/chrome/browser/metrics/chrome_feature_list_creator.cc
index b14b36d349ec..59e086f593e1 100644
--- a/chrome/browser/metrics/chrome_feature_list_creator.cc
+++ b/chrome/browser/metrics/chrome_feature_list_creator.cc
@@ -55,11 +55,17 @@ ChromeFeatureListCreator::ChromeFeatureListCreator() = default;
 ChromeFeatureListCreator::~ChromeFeatureListCreator() = default;
 
 void ChromeFeatureListCreator::CreateFeatureList() {
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 1";
   CreatePrefService();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 2";
   ConvertFlagsToSwitches();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 3";
   CreateMetricsServices();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 4";
   SetupMasterPrefs();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 5";
   SetupFieldTrials();
+  LOG(ERROR) << "[Kiwi] ChromeFeatureListCreator::CreateFeatureList - Step 6";
 }
 
 void ChromeFeatureListCreator::SetApplicationLocale(const std::string& locale) {
diff --git a/chrome/browser/notifications/notification_display_service_impl.cc b/chrome/browser/notifications/notification_display_service_impl.cc
index 46f516b5f2d3..c01c2778d775 100644
--- a/chrome/browser/notifications/notification_display_service_impl.cc
+++ b/chrome/browser/notifications/notification_display_service_impl.cc
@@ -261,24 +261,6 @@ void NotificationDisplayServiceImpl::Display(
 void NotificationDisplayServiceImpl::Close(
     NotificationHandler::Type notification_type,
     const std::string& notification_id) {
-  CHECK(profile_ || notification_type == NotificationHandler::Type::TRANSIENT);
-
-  if (!bridge_initialized_) {
-    actions_.push(base::BindOnce(&NotificationDisplayServiceImpl::Close,
-                                 weak_factory_.GetWeakPtr(), notification_type,
-                                 notification_id));
-    return;
-  }
-
-#if BUILDFLAG(ENABLE_NATIVE_NOTIFICATIONS)
-  NotificationPlatformBridge* bridge =
-      NotificationPlatformBridge::CanHandleType(notification_type)
-          ? bridge_
-          : message_center_bridge_.get();
-  DCHECK(bridge);
-
-  bridge->Close(profile_, notification_id);
-#endif
 }
 
 void NotificationDisplayServiceImpl::GetDisplayed(
diff --git a/chrome/browser/obsolete_system/obsolete_system_android.cc b/chrome/browser/obsolete_system/obsolete_system_android.cc
new file mode 100644
index 000000000000..10d94a577595
--- /dev/null
+++ b/chrome/browser/obsolete_system/obsolete_system_android.cc
@@ -0,0 +1,25 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/obsolete_system/obsolete_system.h"
+
+// static
+bool ObsoleteSystem::IsObsoleteNowOrSoon() {
+  return false;
+}
+
+// static
+base::string16 ObsoleteSystem::LocalizedObsoleteString() {
+  return base::string16();
+}
+
+// static
+bool ObsoleteSystem::IsEndOfTheLine() {
+  return false;
+}
+
+// static
+const char* ObsoleteSystem::GetLinkURL() {
+  return "";
+}
diff --git a/chrome/browser/permissions/attestation_permission_request.cc b/chrome/browser/permissions/attestation_permission_request.cc
index 672203370d4d..af9a7f53d997 100644
--- a/chrome/browser/permissions/attestation_permission_request.cc
+++ b/chrome/browser/permissions/attestation_permission_request.cc
@@ -26,7 +26,17 @@ class AttestationPermissionRequest : public PermissionRequest {
       : origin_(origin), callback_(std::move(callback)) {}
 
   PermissionRequest::IconId GetIconId() const override {
-    return kUsbSecurityKeyIcon;
+    return 0;
+  }
+
+  base::string16 GetTitleText() const override {
+    return l10n_util::GetStringUTF16(
+        IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
+  }
+
+  base::string16 GetMessageText() const override {
+    return l10n_util::GetStringUTF16(
+        IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
   }
 
   base::string16 GetMessageTextFragment() const override {
diff --git a/chrome/browser/platform_util.cc b/chrome/browser/platform_util.cc
index 0a12f09c6f73..3b0cc83e53a6 100644
--- a/chrome/browser/platform_util.cc
+++ b/chrome/browser/platform_util.cc
@@ -21,30 +21,6 @@ namespace {
 
 bool shell_operations_allowed = true;
 
-void VerifyAndOpenItemOnBlockingThread(const base::FilePath& path,
-                                       OpenItemType type,
-                                       const OpenOperationCallback& callback) {
-  base::File target_item(path, base::File::FLAG_OPEN | base::File::FLAG_READ);
-  if (!base::PathExists(path)) {
-    if (!callback.is_null())
-      base::PostTask(FROM_HERE, {BrowserThread::UI},
-                     base::BindOnce(callback, OPEN_FAILED_PATH_NOT_FOUND));
-    return;
-  }
-  if (base::DirectoryExists(path) != (type == OPEN_FOLDER)) {
-    if (!callback.is_null())
-      base::PostTask(FROM_HERE, {BrowserThread::UI},
-                     base::BindOnce(callback, OPEN_FAILED_INVALID_TYPE));
-    return;
-  }
-
-  if (shell_operations_allowed)
-    internal::PlatformOpenVerifiedItem(path, type);
-  if (!callback.is_null())
-    base::PostTask(FROM_HERE, {BrowserThread::UI},
-                   base::BindOnce(callback, OPEN_SUCCEEDED));
-}
-
 }  // namespace
 
 namespace internal {
@@ -55,24 +31,6 @@ void DisableShellOperationsForTesting() {
 
 }  // namespace internal
 
-void OpenItem(Profile* profile,
-              const base::FilePath& full_path,
-              OpenItemType item_type,
-              const OpenOperationCallback& callback) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  // TaskPriority::USER_BLOCKING because this is usually opened as a result of a
-  // user action (e.g. open-downloaded-file or show-item-in-folder).
-  // TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN because this doesn't need global
-  // state and can hang shutdown without this trait as it may result in an
-  // interactive dialog.
-  base::PostTask(
-      FROM_HERE,
-      {base::ThreadPool(), base::MayBlock(), base::TaskPriority::USER_BLOCKING,
-       base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
-      base::BindOnce(&VerifyAndOpenItemOnBlockingThread, full_path, item_type,
-                     callback));
-}
-
 bool IsBrowserLockedFullscreen(const Browser* browser) {
   return false;
 }
diff --git a/chrome/browser/platform_util_android.cc b/chrome/browser/platform_util_android.cc
index aae50e7dca78..b825cc8d1baf 100644
--- a/chrome/browser/platform_util_android.cc
+++ b/chrome/browser/platform_util_android.cc
@@ -55,6 +55,10 @@ void ActivateWindow(gfx::NativeWindow window) {
   NOTIMPLEMENTED();
 }
 
+gfx::NativeView GetViewForWindow(gfx::NativeWindow window) {
+  return nullptr;
+}
+
 bool IsVisible(gfx::NativeView view) {
   NOTIMPLEMENTED();
   return true;
diff --git a/chrome/browser/plugins/plugins_resource_service.cc b/chrome/browser/plugins/plugins_resource_service.cc
index 1e063a0c1aab..57723a447cb3 100644
--- a/chrome/browser/plugins/plugins_resource_service.cc
+++ b/chrome/browser/plugins/plugins_resource_service.cc
@@ -67,7 +67,7 @@ GURL GetPluginsServerURL() {
 #elif defined(OS_MACOSX)
   filename = "plugins_mac.json";
 #else
-#error Unknown platform
+  filename = "plugins_linux.json";
 #endif
 
   return GURL(kPluginsServerUrl + filename);
diff --git a/chrome/browser/policy/browser_dm_token_storage_android.cc b/chrome/browser/policy/browser_dm_token_storage_android.cc
new file mode 100644
index 000000000000..b89463561bea
--- /dev/null
+++ b/chrome/browser/policy/browser_dm_token_storage_android.cc
@@ -0,0 +1,191 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/policy/browser_dm_token_storage_android.h"
+
+#include <string>
+
+#include "base/base64url.h"
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/callback.h"
+#include "base/files/file_util.h"
+#include "base/files/important_file_writer.h"
+#include "base/hash/sha1.h"
+#include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/strings/string16.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/syslog_logging.h"
+#include "base/task/post_task.h"
+#include "base/task/task_traits.h"
+#include "base/task_runner_util.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/sequenced_task_runner_handle.h"
+#include "chrome/common/chrome_paths.h"
+
+namespace policy {
+
+namespace {
+
+const char kDmTokenBaseDir[] = FILE_PATH_LITERAL("Policy/Enrollment/");
+const char kEnrollmentTokenFilename[] =
+    FILE_PATH_LITERAL("enrollment/CloudManagementEnrollmentToken");
+// TODO(crbug.com/907589) : Remove once no longer in use.
+const char kEnrollmentTokenOldFilename[] =
+    FILE_PATH_LITERAL("enrollment/enrollment_token");
+const char kMachineIdFilename[] = FILE_PATH_LITERAL("/etc/machine-id");
+
+// Enrollment Mandatory Option.
+const char kEnrollmentOptionsFilePath[] =
+    FILE_PATH_LITERAL("enrollment/CloudManagementEnrollmentOptions");
+const char kEnrollmentMandatoryOption[] = "Mandatory";
+
+bool GetDmTokenFilePath(base::FilePath* token_file_path,
+                        const std::string& client_id,
+                        bool create_dir) {
+  if (!base::PathService::Get(chrome::DIR_USER_DATA, token_file_path))
+    return false;
+
+  *token_file_path = token_file_path->Append(kDmTokenBaseDir);
+
+  if (create_dir && !base::CreateDirectory(*token_file_path))
+    return false;
+
+  *token_file_path = token_file_path->Append(client_id);
+
+  return true;
+}
+
+bool StoreDMTokenInUserDataDir(const std::string& token,
+                               const std::string& client_id) {
+  base::FilePath token_file_path;
+  if (!GetDmTokenFilePath(&token_file_path, client_id, true)) {
+    NOTREACHED();
+    return false;
+  }
+
+  return base::ImportantFileWriter::WriteFileAtomically(token_file_path, token);
+}
+
+}  // namespace
+
+// static
+BrowserDMTokenStorage* BrowserDMTokenStorage::Get() {
+  if (storage_for_testing_)
+    return storage_for_testing_;
+
+  static base::NoDestructor<BrowserDMTokenStorageAndroid> storage;
+  return storage.get();
+}
+
+BrowserDMTokenStorageAndroid::BrowserDMTokenStorageAndroid()
+    : task_runner_(
+          base::CreateTaskRunner({base::ThreadPool(), base::MayBlock()})) {}
+
+BrowserDMTokenStorageAndroid::~BrowserDMTokenStorageAndroid() {}
+
+std::string BrowserDMTokenStorageAndroid::InitClientId() {
+  // The client ID is derived from /etc/machine-id
+  // (https://www.freedesktop.org/software/systemd/man/machine-id.html). As per
+  // guidelines, this ID must not be transmitted outside of the machine, which
+  // is why we hash it first and then encode it in base64 before transmitting
+  // it.
+  const int machine_id_size = 32;
+  std::string machine_id;
+  machine_id = ReadMachineIdFile();
+  base::StringPiece machine_id_trimmed =
+      base::TrimWhitespaceASCII(machine_id, base::TRIM_TRAILING);
+  if (machine_id_trimmed.size() != machine_id_size) {
+    SYSLOG(ERROR) << "Error: /etc/machine-id contains "
+                  << machine_id_trimmed.size() << " characters ("
+                  << machine_id_size << " were expected).";
+    return std::string();
+  }
+
+  std::string machine_id_base64;
+  base::Base64UrlEncode(base::SHA1HashString(std::string(machine_id_trimmed)),
+                        base::Base64UrlEncodePolicy::OMIT_PADDING,
+                        &machine_id_base64);
+  return machine_id_base64;
+}
+
+std::string BrowserDMTokenStorageAndroid::InitEnrollmentToken() {
+  std::string enrollment_token;
+  base::FilePath dir_policy_files_path;
+
+  if (!base::PathService::Get(chrome::DIR_POLICY_FILES,
+                              &dir_policy_files_path)) {
+    return std::string();
+  }
+
+  base::FilePath token_file_path =
+      dir_policy_files_path.Append(kEnrollmentTokenFilename);
+
+  // Read the enrollment token from the new location. If that fails, try the old
+  // location (which will be deprecated soon). If that also fails, bail as there
+  // is no token set.
+  if (!base::ReadFileToString(token_file_path, &enrollment_token)) {
+    // TODO(crbug.com/907589) : Remove once no longer in use.
+    token_file_path = dir_policy_files_path.Append(kEnrollmentTokenOldFilename);
+    if (!base::ReadFileToString(token_file_path, &enrollment_token))
+      return std::string();
+  }
+
+  return base::TrimWhitespaceASCII(enrollment_token, base::TRIM_ALL)
+      .as_string();
+}
+
+std::string BrowserDMTokenStorageAndroid::InitDMToken() {
+  base::FilePath token_file_path;
+  if (!GetDmTokenFilePath(&token_file_path, RetrieveClientId(), false))
+    return std::string();
+
+  std::string token;
+  if (!base::ReadFileToString(token_file_path, &token))
+    return std::string();
+
+  return base::TrimWhitespaceASCII(token, base::TRIM_ALL).as_string();
+}
+
+bool BrowserDMTokenStorageAndroid::InitEnrollmentErrorOption() {
+  std::string options;
+  base::FilePath dir_policy_files_path;
+
+  if (!base::PathService::Get(chrome::DIR_POLICY_FILES,
+                              &dir_policy_files_path)) {
+    return false;
+  }
+
+  base::FilePath options_file_path =
+      dir_policy_files_path.Append(kEnrollmentOptionsFilePath);
+
+  if (!base::ReadFileToString(options_file_path, &options))
+    return false;
+
+  return base::TrimWhitespaceASCII(options, base::TRIM_ALL).as_string() ==
+         kEnrollmentMandatoryOption;
+}
+
+BrowserDMTokenStorage::StoreTask BrowserDMTokenStorageAndroid::SaveDMTokenTask(
+    const std::string& token,
+    const std::string& client_id) {
+  return base::BindOnce(&StoreDMTokenInUserDataDir, token, client_id);
+}
+
+scoped_refptr<base::TaskRunner>
+BrowserDMTokenStorageAndroid::SaveDMTokenTaskRunner() {
+  return task_runner_;
+}
+
+std::string BrowserDMTokenStorageAndroid::ReadMachineIdFile() {
+  std::string machine_id;
+  if (!base::ReadFileToString(base::FilePath(kMachineIdFilename), &machine_id))
+    return std::string();
+  return machine_id;
+}
+
+}  // namespace policy
diff --git a/chrome/browser/policy/browser_dm_token_storage_android.h b/chrome/browser/policy/browser_dm_token_storage_android.h
new file mode 100644
index 000000000000..2a16d354d4bb
--- /dev/null
+++ b/chrome/browser/policy/browser_dm_token_storage_android.h
@@ -0,0 +1,58 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
+#define CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
+
+#include "chrome/browser/policy/browser_dm_token_storage.h"
+
+#include <string>
+
+#include "base/gtest_prod_util.h"
+#include "base/macros.h"
+#include "base/memory/scoped_refptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/sequence_checker.h"
+#include "base/single_thread_task_runner.h"
+
+namespace policy {
+
+// Implementation of BrowserDMTokenStorage for Android. The global singleton
+// instance can be retrieved by calling BrowserDMTokenStorage::Get().
+class BrowserDMTokenStorageAndroid : public BrowserDMTokenStorage {
+ public:
+  // Get the global singleton instance by calling BrowserDMTokenStorage::Get().
+  BrowserDMTokenStorageAndroid();
+  ~BrowserDMTokenStorageAndroid() override;
+
+ private:
+  // override BrowserDMTokenStorage
+  std::string InitClientId() override;
+  std::string InitEnrollmentToken() override;
+  std::string InitDMToken() override;
+  bool InitEnrollmentErrorOption() override;
+  StoreTask SaveDMTokenTask(const std::string& token,
+                            const std::string& client_id) override;
+  scoped_refptr<base::TaskRunner> SaveDMTokenTaskRunner() override;
+
+  // Returns the content of "/etc/machine-id". Virtual for tests.
+  virtual std::string ReadMachineIdFile();
+
+  scoped_refptr<base::TaskRunner> task_runner_;
+
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitClientId);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitEnrollmentToken);
+  // TODO(crbug.com/907589): Remove once no longer in use.
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest,
+                           InitOldEnrollmentToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitDMToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest,
+                           InitDMTokenWithoutDirectory);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, SaveDMToken);
+
+  DISALLOW_COPY_AND_ASSIGN(BrowserDMTokenStorageAndroid);
+};
+
+}  // namespace policy
+#endif  // CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
diff --git a/chrome/browser/policy/chrome_browser_policy_connector.cc b/chrome/browser/policy/chrome_browser_policy_connector.cc
index 637c861be75d..77d896d864dd 100644
--- a/chrome/browser/policy/chrome_browser_policy_connector.cc
+++ b/chrome/browser/policy/chrome_browser_policy_connector.cc
@@ -47,7 +47,7 @@
 #include "components/policy/core/browser/android/android_combined_policy_provider.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || (!defined(OS_ANDROID) && !defined(OS_CHROMEOS))
 #include "chrome/browser/policy/chrome_browser_cloud_management_controller.h"
 #include "components/policy/core/common/cloud/machine_level_user_cloud_policy_manager.h"
 #endif
diff --git a/chrome/browser/policy/configuration_policy_handler_list_factory.cc b/chrome/browser/policy/configuration_policy_handler_list_factory.cc
index 9c2fdea178f5..05b15eab5c8d 100644
--- a/chrome/browser/policy/configuration_policy_handler_list_factory.cc
+++ b/chrome/browser/policy/configuration_policy_handler_list_factory.cc
@@ -1072,7 +1072,7 @@ const PolicyToPreferenceMapEntry kSimplePolicyMap[] = {
     base::Value::Type::BOOLEAN },
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   { key::kRelaunchNotification,
     prefs::kRelaunchNotification,
     base::Value::Type::INTEGER },
diff --git a/chrome/browser/prefs/browser_prefs.cc b/chrome/browser/prefs/browser_prefs.cc
index 236422f50eba..407f094cd57f 100644
--- a/chrome/browser/prefs/browser_prefs.cc
+++ b/chrome/browser/prefs/browser_prefs.cc
@@ -217,7 +217,6 @@
 #if BUILDFLAG(ENABLE_FEED_IN_CHROME)
 #include "components/feed/core/pref_names.h"
 #endif  // BUILDFLAG(ENABLE_FEED_IN_CHROME)
-#else   // defined(OS_ANDROID)
 #include "chrome/browser/apps/app_service/app_service_proxy.h"
 #include "chrome/browser/enterprise_reporting/prefs.h"
 #include "chrome/browser/gcm/gcm_product_util.h"
@@ -350,12 +349,12 @@
 #include "components/os_crypt/os_crypt.h"
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || \
+#if true || defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 #include "chrome/browser/browser_switcher/browser_switcher_prefs.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 #include "chrome/browser/ui/startup/default_browser_prompt.h"
 #endif
 
@@ -363,7 +362,7 @@
 #include "chrome/browser/ui/browser_view_prefs.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/media/unified_autoplay_config.h"
 #include "components/ntp_tiles/custom_links_manager_impl.h"
 #endif
@@ -448,7 +447,7 @@ const char kContentSuggestionsNotificationsEnabled[] =
 
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Deprecated 5/2019
 const char kSignInPromoShowOnFirstRunAllowed[] =
     "sync_promo.show_on_first_run_allowed";
@@ -470,7 +469,7 @@ const char kHasSeenWin10PromoPage[] = "browser.has_seen_win10_promo_page";
 // Deprecated 7/2019
 const char kSignedInTime[] = "signin.signedin_time";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Deprecated 7/2019
 const char kNtpActivateHideShortcutsFieldTrial[] =
     "ntp.activate_hide_shortcuts_field_trial";
@@ -571,7 +570,7 @@ void RegisterProfilePrefsForMigration(
   registry->RegisterBooleanPref(kContentSuggestionsNotificationsEnabled, true);
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterBooleanPref(kSignInPromoShowOnFirstRunAllowed, true);
   registry->RegisterBooleanPref(kSignInPromoShowNTPBubble, false);
 #endif  // !defined(OS_ANDROID)
@@ -665,11 +664,11 @@ void RegisterLocalState(PrefRegistrySimple* registry) {
 
 #if defined(OS_ANDROID)
   ::android::RegisterPrefs(registry);
-#else
+
   media_router::RegisterLocalStatePrefs(registry);
   // The native GCM is used on Android instead.
-  gcm::GCMChannelStatusSyncer::RegisterPrefs(registry);
-  gcm::RegisterPrefs(registry);
+//  gcm::GCMChannelStatusSyncer::RegisterPrefs(registry);
+//  gcm::RegisterPrefs(registry);
   metrics::TabStatsTracker::RegisterPrefs(registry);
   RegisterBrowserPrefs(registry);
   StartupBrowserCreator::RegisterLocalStatePrefs(registry);
@@ -770,7 +769,7 @@ void RegisterLocalState(PrefRegistrySimple* registry) {
 
   // Obsolete. See MigrateObsoleteBrowserPrefs().
   registry->RegisterIntegerPref(metrics::prefs::kStabilityExecutionPhase, 0);
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterBooleanPref(kNtpActivateHideShortcutsFieldTrial, false);
 #endif  // !defined(OS_ANDROID)
   registry->RegisterInt64Pref(kLastStartupTimestamp, 0);
@@ -785,6 +784,7 @@ void RegisterLocalState(PrefRegistrySimple* registry) {
 // Register prefs applicable to all profiles.
 void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
                           const std::string& locale) {
+  LOG(ERROR) << "[Kiwi] prefs/browser_prefs.cc::RegisterProfilePrefs - Step 1";
   TRACE_EVENT0("browser", "chrome::RegisterProfilePrefs");
   // User prefs. Please keep this list alphabetized.
   AccessibilityLabelsService::RegisterProfilePrefs(registry);
@@ -902,15 +902,18 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
 #if BUILDFLAG(ENABLE_FEED_IN_CHROME)
   feed::RegisterProfilePrefs(registry);
 #endif  // BUILDFLAG(ENABLE_FEED_IN_CHROME)
-#else
   apps::AppServiceProxy::RegisterProfilePrefs(registry);
   AppShortcutManager::RegisterProfilePrefs(registry);
+#if 0
   DeviceIDFetcher::RegisterProfilePrefs(registry);
+#endif
   DevToolsWindow::RegisterProfilePrefs(registry);
   extensions::CommandService::RegisterProfilePrefs(registry);
   extensions::TabsCaptureVisibleTabFunction::RegisterProfilePrefs(registry);
   NewTabUI::RegisterProfilePrefs(registry);
+#if 0
   PepperFlashSettingsManager::RegisterProfilePrefs(registry);
+#endif
   PinnedTabCodec::RegisterProfilePrefs(registry);
   signin::RegisterProfilePrefs(registry);
 #endif
@@ -927,22 +930,22 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
-  browser_sync::ForeignSessionHandler::RegisterProfilePrefs(registry);
-  ChromeAuthenticatorRequestDelegate::RegisterProfilePrefs(registry);
+#if true || !defined(OS_ANDROID)
+//  browser_sync::ForeignSessionHandler::RegisterProfilePrefs(registry);
+//  ChromeAuthenticatorRequestDelegate::RegisterProfilePrefs(registry);
   first_run::RegisterProfilePrefs(registry);
   HatsService::RegisterProfilePrefs(registry);
   InstantService::RegisterProfilePrefs(registry);
   PromoService::RegisterProfilePrefs(registry);
   SearchSuggestService::RegisterProfilePrefs(registry);
-  gcm::GCMChannelStatusSyncer::RegisterProfilePrefs(registry);
-  gcm::RegisterProfilePrefs(registry);
+//  gcm::GCMChannelStatusSyncer::RegisterProfilePrefs(registry);
+//  gcm::RegisterProfilePrefs(registry);
   media_router::RegisterProfilePrefs(registry);
   ntp_tiles::CustomLinksManagerImpl::RegisterProfilePrefs(registry);
   StartupBrowserCreator::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   default_apps::RegisterProfilePrefs(registry);
 #endif
 
@@ -1016,7 +1019,7 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
   RegisterChromeLauncherUserPrefs(registry);
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   HistoryUI::RegisterProfilePrefs(registry);
   settings::SettingsUI::RegisterProfilePrefs(registry);
 #endif
@@ -1030,11 +1033,11 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
   NotificationChannelsProviderAndroid::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   UnifiedAutoplayConfig::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_CHROMEOS) && BUILDFLAG(ENABLE_EXTENSIONS)
+#if true || !defined(OS_CHROMEOS) && BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::enterprise_reporting::RegisterProfilePrefs(registry);
 #endif
 
@@ -1043,6 +1046,7 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
 #endif
 
   RegisterProfilePrefsForMigration(registry);
+  LOG(ERROR) << "[Kiwi] prefs/browser_prefs.cc::RegisterProfilePrefs - Step 2";
 }
 
 void RegisterUserProfilePrefs(user_prefs::PrefRegistrySyncable* registry) {
@@ -1098,7 +1102,7 @@ void MigrateObsoleteBrowserPrefs(Profile* profile, PrefService* local_state) {
   local_state->ClearPref(kHasSeenWin10PromoPage);
 #endif  // defined(OS_WIN)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Added 7/2019.
   local_state->ClearPref(kNtpActivateHideShortcutsFieldTrial);
 #endif  // !defined(OS_ANDROID)
@@ -1196,7 +1200,7 @@ void MigrateObsoleteProfilePrefs(Profile* profile) {
   profile_prefs->ClearPref(kContentSuggestionsNotificationsEnabled);
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Deprecated 5/2019
   profile_prefs->ClearPref(kSignInPromoShowOnFirstRunAllowed);
   profile_prefs->ClearPref(kSignInPromoShowNTPBubble);
diff --git a/chrome/browser/prefs/chrome_pref_service_factory.cc b/chrome/browser/prefs/chrome_pref_service_factory.cc
index ce49583f5c3e..f7db89898433 100644
--- a/chrome/browser/prefs/chrome_pref_service_factory.cc
+++ b/chrome/browser/prefs/chrome_pref_service_factory.cc
@@ -124,7 +124,7 @@ const prefs::TrackedPreferenceMetadata kTrackedPrefs[] = {
      PrefTrackingStrategy::ATOMIC, ValueType::PERSONAL},
     {7, prefs::kSearchProviderOverrides, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     {11, prefs::kPinnedTabs, EnforcementLevel::ENFORCE_ON_LOAD,
      PrefTrackingStrategy::ATOMIC, ValueType::IMPERSONAL},
 #endif
diff --git a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
index c136190f2bb9..8f9189c0c962 100644
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -98,7 +98,7 @@
 #include "chrome/browser/android/explore_sites/explore_sites_service_factory.h"
 #include "chrome/browser/android/search_permissions/search_permissions_service.h"
 #include "chrome/browser/media/android/cdm/media_drm_origin_id_manager_factory.h"
-#else
+
 #include "chrome/browser/apps/app_service/app_service_proxy_factory.h"
 #include "chrome/browser/feedback/feedback_uploader_factory_chrome.h"
 #include "chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.h"
@@ -188,109 +188,174 @@ ChromeBrowserMainExtraPartsProfiles::~ChromeBrowserMainExtraPartsProfiles() {}
 // FooServiceFactory here will scale or is desirable long term.
 //
 // static
+
+// Special Android
+// When we are on Android, we need to initialize the first pass only the minimum to be able to init the profile the first time
 void ChromeBrowserMainExtraPartsProfiles::
-    EnsureBrowserContextKeyedServiceFactoriesBuilt() {
+    EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init) {
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 1";
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 2";
   apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 3";
   extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 4";
   extensions::ExtensionManagementFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 5";
   chrome_extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 6";
   chrome_apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 7";
   chrome_apps::api::EnsureAPIBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 8";
+  }
 #endif
 
 #if defined(OS_CHROMEOS)
   chromeos::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 9";
   app_list::AppListSyncableServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 10";
 
 #if !defined(OS_ANDROID)
   apps::AppServiceProxyFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 11";
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 12";
   AboutSigninInternalsFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 13";
   AccountConsistencyModeManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 14";
   AccountInvestigatorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 15";
   AccountReconcilorFactory::GetInstance();
   AdaptiveQuietNotificationPermissionUiEnabler::Factory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 16";
+  if (full_init)
   AutocompleteClassifierFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 17";
   autofill::PersonalDataManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 18";
 #if BUILDFLAG(ENABLE_BACKGROUND_CONTENTS)
   BackgroundContentsServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 19";
   BookmarkModelFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 20";
   BookmarkUndoServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 21";
   BrowsingDataHistoryObserverService::Factory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 22";
   browser_sync::UserEventServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 23";
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   CaptivePortalServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 24";
   CertificateReportingServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 25";
+  if (full_init)
   ChromeBrowsingDataRemoverDelegateFactory::GetInstance();
   ChromeSigninClientFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 28";
   ClientHintsFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 29";
 #if BUILDFLAG(ENABLE_PRINT_PREVIEW) && !defined(OS_CHROMEOS)
   CloudPrintProxyServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 30";
   ConsentAuditorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 31";
   ContentSuggestionsServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 32";
   CookieSettingsFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 33";
   NotifierStateTrackerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 34";
   dom_distiller::DomDistillerServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 35";
   DownloadCoreServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 36";
   DownloadServiceFactory::GetInstance();
 #if defined(OS_ANDROID)
   explore_sites::ExploreSitesServiceFactory::GetInstance();
 #endif
   FaviconServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 41";
+  if (full_init)
   HistoryUiFaviconRequestHandlerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 42";
 #if BUILDFLAG(ENABLE_LEGACY_DESKTOP_IN_PRODUCT_HELP)
   feature_engagement::BookmarkTrackerFactory::GetInstance();
   feature_engagement::IncognitoWindowTrackerFactory::GetInstance();
   feature_engagement::NewTabTrackerFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 43";
   feature_engagement::TrackerFactory::GetInstance();
 #if !defined(OS_ANDROID)
   feedback::FeedbackUploaderFactoryChrome::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 44";
   FindBarStateFactory::GetInstance();
   GAIAInfoUpdateServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 45";
 #if !defined(OS_ANDROID)
   GlobalErrorServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 46";
   GoogleSearchDomainMixingMetricsEmitterFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47";
   HistoryServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-1";
   HostContentSettingsMapFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-2";
   IdentityManagerFactory::EnsureFactoryAndDependeeFactoriesBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-3";
   InMemoryURLIndexFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-4";
   invalidation::DeprecatedProfileInvalidationProviderFactory::GetInstance();
-#if !defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-5";
+#if true || !defined(OS_ANDROID)
   InstantServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-6";
 #if BUILDFLAG(ENABLE_SERVICE_DISCOVERY)
   cloud_print::PrivetNotificationServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 47-7";
   RendererUpdaterFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 48";
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
+  if (full_init)
   SupervisedUserServiceFactory::GetInstance();
 #endif
   LanguageModelManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 48-4";
 #if !defined(OS_ANDROID)
   LoginUIServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 49";
   if (MediaEngagementService::IsEnabled())
     MediaEngagementServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 50";
   media_router::MediaRouterFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 51";
 #if !defined(OS_ANDROID)
   media_router::MediaRouterUIServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 52";
 #if defined(OS_ANDROID)
   MediaDrmOriginIdManagerFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 53";
 #if !defined(OS_ANDROID)
   MediaGalleriesPreferencesFactory::GetInstance();
 #endif
   if (base::FeatureList::IsEnabled(media::kUseMediaHistoryStore))
     media_history::MediaHistoryKeyedServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 54";
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
   metrics::DesktopProfileSessionDurationsServiceFactory::GetInstance();
@@ -300,10 +365,11 @@ void ChromeBrowserMainExtraPartsProfiles::
   NTPResourceCacheFactory::GetInstance();
 #endif
   PasswordStoreFactory::GetInstance();
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   PinnedTabServiceFactory::GetInstance();
   ThemeServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 55";
 #if BUILDFLAG(ENABLE_PLUGINS)
   PluginPrefsFactory::GetInstance();
 #endif
@@ -311,34 +377,59 @@ void ChromeBrowserMainExtraPartsProfiles::
 #if !defined(OS_CHROMEOS)
   policy::UserPolicySigninServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58";
   policy::UserCloudPolicyInvalidatorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-1";
+  if (full_init)
   predictors::AutocompleteActionPredictorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-2";
+  if (full_init)
   predictors::PredictorDatabaseFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-3";
+  if (full_init)
   predictors::LoadingPredictorFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-4";
+  if (full_init)
   prerender::PrerenderLinkManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-5";
+  if (full_init)
   prerender::PrerenderManagerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-6";
+  if (full_init)
   prerender::PrerenderMessageFilter::EnsureShutdownNotifierFactoryBuilt();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-7";
   ProfileSyncServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 58-8";
   ProtocolHandlerRegistryFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 59";
 #if !defined(OS_ANDROID)
   resource_coordinator::LocalSiteCharacteristicsDataStoreFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 59-1";
 #if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::AdvancedProtectionStatusManagerFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 60";
 #if defined(OS_ANDROID)
   SearchPermissionsService::Factory::GetInstance();
 #endif
   send_tab_to_self::SendTabToSelfClientServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 61";
 #if BUILDFLAG(ENABLE_SESSION_SERVICE)
   SessionServiceFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62";
+  if (full_init)
   SharingServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-1";
   ShortcutsBackendFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-2";
   SigninProfileAttributesUpdaterFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-3";
 
   if (SiteEngagementService::IsEnabled())
     SiteEngagementServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 62-4";
 
 #if BUILDFLAG(ENABLE_SPELLCHECK)
   SpellcheckServiceFactory::GetInstance();
@@ -347,25 +438,40 @@ void ChromeBrowserMainExtraPartsProfiles::
   StorageNotificationServiceFactory::GetInstance();
 #endif
   suggestions::SuggestionsServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 63";
   TabRestoreServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-1";
   TemplateURLFetcherFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-2";
   TemplateURLServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-3";
   TopSitesFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 64-4";
   translate::TranslateRankerFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 65";
 #if defined(OS_WIN)
   TriggeredProfileResetterFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 65-1";
   UnifiedConsentServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 65-2";
   UrlLanguageHistogramFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 66";
 #if !defined(OS_ANDROID)
   UsbChooserContextFactory::GetInstance();
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 67";
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
   web_app::WebAppProviderFactory::GetInstance();
   web_app::WebAppMetricsFactory::GetInstance();
+  }
 #endif
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 68";
   WebDataServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 69";
   webrtc_event_logging::WebRtcEventLogManagerKeyedServiceFactory::GetInstance();
+  LOG(ERROR) << "[Kiwi] ChromeBrowserMainExtraPartsProfiles::EnsureBrowserContextKeyedServiceFactoriesBuilt - Step 70";
 }
 
 void ChromeBrowserMainExtraPartsProfiles::PreProfileInit() {
diff --git a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
index 8b366bcf4331..584ac76e307e 100644
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
@@ -23,7 +23,7 @@ class ChromeBrowserMainExtraPartsProfiles : public ChromeBrowserMainExtraParts {
   // Instantiates all chrome KeyedService factories, which is
   // especially important for services that should be created at profile
   // creation time as compared to lazily on first access.
-  static void EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  static void EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init = true);
 
   // Overridden from ChromeBrowserMainExtraParts:
   void PreProfileInit() override;
diff --git a/chrome/browser/profiles/off_the_record_profile_impl.cc b/chrome/browser/profiles/off_the_record_profile_impl.cc
index 9d71bfd22580..284868293675 100644
--- a/chrome/browser/profiles/off_the_record_profile_impl.cc
+++ b/chrome/browser/profiles/off_the_record_profile_impl.cc
@@ -76,7 +76,6 @@
 
 #if defined(OS_ANDROID)
 #include "components/prefs/scoped_user_pref_update.h"
-#else  // !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_otr_delegate.h"
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/browser/host_zoom_map.h"
@@ -110,7 +109,7 @@
 
 using content::BrowserThread;
 using content::DownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 using content::HostZoomMap;
 #endif
 
@@ -162,7 +161,7 @@ void OffTheRecordProfileImpl::Init() {
         IncognitoModePrefs::GetAvailability(profile_->GetPrefs()) !=
             IncognitoModePrefs::DISABLED);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   TrackZoomLevelsFromParent();
 #endif
 
@@ -236,7 +235,7 @@ void OffTheRecordProfileImpl::InitIoData() {
   io_data_.reset(new OffTheRecordProfileIOData::Handle(this));
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void OffTheRecordProfileImpl::TrackZoomLevelsFromParent() {
   DCHECK(!profile_->IsIncognitoProfile());
 
@@ -290,7 +289,7 @@ base::Time OffTheRecordProfileImpl::GetCreationTime() const {
   return start_time_;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 OffTheRecordProfileImpl::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
@@ -635,7 +634,7 @@ Profile* Profile::CreateOffTheRecordProfile() {
   return profile;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void OffTheRecordProfileImpl::OnParentZoomLevelChanged(
     const HostZoomMap::ZoomLevelChange& change) {
   HostZoomMap* host_zoom_map = HostZoomMap::GetDefaultForBrowserContext(this);
diff --git a/chrome/browser/profiles/off_the_record_profile_impl.h b/chrome/browser/profiles/off_the_record_profile_impl.h
index f805b608cac2..c4ebe3a2753e 100644
--- a/chrome/browser/profiles/off_the_record_profile_impl.h
+++ b/chrome/browser/profiles/off_the_record_profile_impl.h
@@ -17,7 +17,7 @@
 #include "components/domain_reliability/clear_mode.h"
 #include "content/public/browser/content_browser_client.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -93,7 +93,7 @@ class OffTheRecordProfileImpl : public Profile {
   base::FilePath GetPath() override;
   base::FilePath GetPath() const override;
   base::Time GetCreationTime() const override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
@@ -129,12 +129,12 @@ class OffTheRecordProfileImpl : public Profile {
  private:
   void InitIoData();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Allows a profile to track changes in zoom levels in its parent profile.
   void TrackZoomLevelsFromParent();
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Callback function for tracking parent's zoom level changes.
   void OnParentZoomLevelChanged(
       const content::HostZoomMap::ZoomLevelChange& change);
@@ -146,7 +146,7 @@ class OffTheRecordProfileImpl : public Profile {
 
   std::unique_ptr<sync_preferences::PrefServiceSyncable> prefs_;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::HostZoomMap::Subscription> track_zoom_subscription_;
   std::unique_ptr<ChromeZoomLevelPrefs::DefaultZoomLevelSubscription>
       parent_default_zoom_level_subscription_;
diff --git a/chrome/browser/profiles/profile.cc b/chrome/browser/profiles/profile.cc
index 2b1140fdd27e..4a5625924812 100644
--- a/chrome/browser/profiles/profile.cc
+++ b/chrome/browser/profiles/profile.cc
@@ -39,7 +39,7 @@
 #include "chromeos/constants/chromeos_switches.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/first_run/first_run.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -129,7 +129,7 @@ TestingProfile* Profile::AsTestingProfile() {
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 ChromeZoomLevelPrefs* Profile::GetZoomLevelPrefs() {
   return nullptr;
 }
diff --git a/chrome/browser/profiles/profile.h b/chrome/browser/profiles/profile.h
index 458c4acb0851..0d59f20ff6ae 100644
--- a/chrome/browser/profiles/profile.h
+++ b/chrome/browser/profiles/profile.h
@@ -21,7 +21,7 @@
 #include "services/network/public/mojom/network_context.mojom-forward.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 class ChromeZoomLevelPrefs;
 #endif
 
@@ -218,7 +218,7 @@ class Profile : public content::BrowserContext {
   virtual PrefService* GetPrefs() = 0;
   virtual const PrefService* GetPrefs() const = 0;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Retrieves a pointer to the PrefService that manages the default zoom
   // level and the per-host zoom levels for this user profile.
   // TODO(wjmaclean): Remove this when HostZoomMap migrates to StoragePartition.
@@ -425,7 +425,7 @@ class Profile : public content::BrowserContext {
   // correctly assigned to its owner.
   Profile* CreateOffTheRecordProfile();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Convenience method to retrieve the default zoom level for the default
   // storage partition.
   double GetDefaultZoomLevelForProfile();
diff --git a/chrome/browser/profiles/profile_impl.cc b/chrome/browser/profiles/profile_impl.cc
index fc6e53edf708..3023d9885d20 100644
--- a/chrome/browser/profiles/profile_impl.cc
+++ b/chrome/browser/profiles/profile_impl.cc
@@ -186,7 +186,6 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/profile_key_startup_accessor.h"
-#else
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/common/page_zoom.h"
 #endif
@@ -366,12 +365,14 @@ const char ProfileImpl::kPrefExitTypeNormal[] = "Normal";
 // static
 void ProfileImpl::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 1";
   registry->RegisterBooleanPref(prefs::kSavingBrowserHistoryDisabled, false);
   registry->RegisterBooleanPref(prefs::kAllowDeletingBrowserHistory, true);
   registry->RegisterBooleanPref(prefs::kForceGoogleSafeSearch, false);
   registry->RegisterIntegerPref(prefs::kForceYouTubeRestrict,
                                 safe_search_util::YOUTUBE_RESTRICT_OFF);
   registry->RegisterStringPref(prefs::kAllowedDomainsForApps, std::string());
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 2";
 
   registry->RegisterIntegerPref(prefs::kProfileAvatarIndex, -1);
   // Whether a profile is using an avatar without having explicitely chosen it
@@ -392,6 +393,7 @@ void ProfileImpl::RegisterProfilePrefs(
                                home_page_flags);
   registry->RegisterStringPref(prefs::kNewTabPageLocationOverride,
                                std::string());
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 3";
 
 #if BUILDFLAG(ENABLE_PRINTING)
   registry->RegisterBooleanPref(prefs::kPrintingEnabled, true);
@@ -406,9 +408,10 @@ void ProfileImpl::RegisterProfilePrefs(
       prefs::kOobeMarketingOptInScreenFinished, false,
       user_prefs::PrefRegistrySyncable::SYNCABLE_OS_PREF);
 #endif  // defined(OS_CHROMEOS)
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterBooleanPref(prefs::kShowCastIconInToolbar, false);
 #endif  // !defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ProfileImpl::RegisterProfilePrefs - Step 4";
 }
 
 ProfileImpl::ProfileImpl(
@@ -807,7 +810,7 @@ Profile::ProfileType ProfileImpl::GetProfileType() const {
   return REGULAR_PROFILE;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 ProfileImpl::CreateZoomLevelDelegate(const base::FilePath& partition_path) {
   return std::make_unique<ChromeZoomLevelPrefs>(
@@ -1062,7 +1065,7 @@ const PrefService* ProfileImpl::GetPrefs() const {
   return prefs_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 ChromeZoomLevelPrefs* ProfileImpl::GetZoomLevelPrefs() {
   return static_cast<ChromeZoomLevelPrefs*>(
       GetDefaultStoragePartition(this)->GetZoomLevelDelegate());
diff --git a/chrome/browser/profiles/profile_impl.h b/chrome/browser/profiles/profile_impl.h
index 7c835593998b..051b36eed26b 100644
--- a/chrome/browser/profiles/profile_impl.h
+++ b/chrome/browser/profiles/profile_impl.h
@@ -27,7 +27,7 @@
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/identity/public/mojom/identity_service.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -76,7 +76,7 @@ class ProfileImpl : public Profile {
   static void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry);
 
   // content::BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif
@@ -133,7 +133,7 @@ class ProfileImpl : public Profile {
   ExtensionSpecialStoragePolicy* GetExtensionSpecialStoragePolicy() override;
   PrefService* GetPrefs() override;
   const PrefService* GetPrefs() const override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   ChromeZoomLevelPrefs* GetZoomLevelPrefs() override;
 #endif
   PrefService* GetOffTheRecordPrefs() override;
diff --git a/chrome/browser/profiles/profile_manager.cc b/chrome/browser/profiles/profile_manager.cc
index c5ab679fb529..1dd39be9cce1 100644
--- a/chrome/browser/profiles/profile_manager.cc
+++ b/chrome/browser/profiles/profile_manager.cc
@@ -123,7 +123,7 @@
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/metrics/android_profile_session_durations_service_factory.h"
 #include "chrome/browser/ntp_snippets/content_suggestions_service_factory.h"
-#else
+
 #include "chrome/browser/first_run/first_run.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
@@ -235,7 +235,7 @@ void ProfileSizeTask(const base::FilePath& path, int enabled_app_count) {
     UMA_HISTOGRAM_COUNTS_10000("Profile.AppCount", enabled_app_count);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Schedule a profile for deletion if it isn't already scheduled.
 // Returns whether the profile has been newly scheduled.
 bool ScheduleProfileDirectoryForDeletion(const base::FilePath& path) {
@@ -803,7 +803,7 @@ ProfileShortcutManager* ProfileManager::profile_shortcut_manager() {
   return profile_shortcut_manager_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileManager::MaybeScheduleProfileForDeletion(
     const base::FilePath& profile_dir,
     ProfileLoadedCallback callback,
@@ -1408,7 +1408,7 @@ Profile* ProfileManager::CreateAndInitializeProfile(
   return profile_ptr;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileManager::EnsureActiveProfileExistsBeforeDeletion(
     ProfileLoadedCallback callback,
     const base::FilePath& profile_dir) {
diff --git a/chrome/browser/profiles/profile_manager.h b/chrome/browser/profiles/profile_manager.h
index 7d02af7f8f60..87c16b05395a 100644
--- a/chrome/browser/profiles/profile_manager.h
+++ b/chrome/browser/profiles/profile_manager.h
@@ -199,7 +199,7 @@ class ProfileManager : public content::NotificationObserver,
   // profile specfic desktop shortcuts.
   ProfileShortcutManager* profile_shortcut_manager();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Less strict version of ScheduleProfileForDeletion(), silently exits if
   // profile is either scheduling or marked for deletion.
   void MaybeScheduleProfileForDeletion(
@@ -315,7 +315,7 @@ class ProfileManager : public content::NotificationObserver,
   // null if creation fails.
   Profile* CreateAndInitializeProfile(const base::FilePath& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Continues the scheduled profile deletion after closing all the profile's
   // browsers tabs. Creates a new profile if the profile to be deleted is the
   // last non-supervised profile. In the Mac, loads the next non-supervised
@@ -367,7 +367,7 @@ class ProfileManager : public content::NotificationObserver,
 
   void SaveActiveProfiles();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   void OnBrowserOpened(Browser* browser);
   void OnBrowserClosed(Browser* browser);
 
diff --git a/chrome/browser/profiles/profile_metrics.cc b/chrome/browser/profiles/profile_metrics.cc
index 353f18928bc9..a77117a0e0dd 100644
--- a/chrome/browser/profiles/profile_metrics.cc
+++ b/chrome/browser/profiles/profile_metrics.cc
@@ -25,7 +25,7 @@
 #include "components/signin/core/browser/signin_header_helper.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #endif
 
@@ -33,7 +33,7 @@ namespace {
 
 const int kMaximumDaysOfDisuse = 4 * 7;  // Should be integral number of weeks.
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 size_t number_of_profile_switches_ = 0;
 #endif
 
@@ -47,7 +47,7 @@ enum ProfileOpenState {
   PROFILE_UNOPENED
 };
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 ProfileOpenState GetProfileOpenState(
     ProfileManager* manager,
     const base::FilePath& path) {
@@ -463,7 +463,7 @@ void ProfileMetrics::LogProfileOpenMethod(ProfileOpen metric) {
                             NUM_PROFILE_OPEN_METRICS);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void ProfileMetrics::LogProfileSwitch(
     ProfileOpen metric,
     ProfileManager* manager,
diff --git a/chrome/browser/profiles/profile_metrics.h b/chrome/browser/profiles/profile_metrics.h
index fed2dca9615e..a47547328988 100644
--- a/chrome/browser/profiles/profile_metrics.h
+++ b/chrome/browser/profiles/profile_metrics.h
@@ -190,7 +190,7 @@ class ProfileMetrics {
   static void LogProfileAvatarSelection(size_t icon_index);
   static void LogProfileDeleteUser(ProfileDelete metric);
   static void LogProfileOpenMethod(ProfileOpen metric);
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   static void LogProfileSwitch(ProfileOpen metric,
                                ProfileManager* manager,
                                const base::FilePath& profile_path);
diff --git a/chrome/browser/profiles/profile_window.cc b/chrome/browser/profiles/profile_window.cc
index 4f453ac671bd..651d4d8fe8ec 100644
--- a/chrome/browser/profiles/profile_window.cc
+++ b/chrome/browser/profiles/profile_window.cc
@@ -54,7 +54,7 @@
 #include "extensions/browser/extension_system.h"
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_list.h"
 #include "chrome/browser/ui/browser_list_observer.h"
@@ -253,7 +253,7 @@ void OpenBrowserWindowForProfile(ProfileManager::CreateCallback callback,
                                             is_first_run, true);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 
 void LoadProfileAsync(const base::FilePath& path,
                       ProfileManager::CreateCallback callback) {
diff --git a/chrome/browser/profiles/profile_window.h b/chrome/browser/profiles/profile_window.h
index 00014301cdb5..e98d510b4c73 100644
--- a/chrome/browser/profiles/profile_window.h
+++ b/chrome/browser/profiles/profile_window.h
@@ -15,10 +15,6 @@
 #include "chrome/browser/ui/profile_chooser_constants.h"
 #include "chrome/browser/ui/startup/startup_types.h"
 
-#if defined(OS_ANDROID)
-#error "Not used on Android"
-#endif
-
 class Profile;
 
 namespace base { class FilePath; }
diff --git a/chrome/browser/profiles/profiles_state.cc b/chrome/browser/profiles/profiles_state.cc
index 2e6a1b274dde..c480c93a5691 100644
--- a/chrome/browser/profiles/profiles_state.cc
+++ b/chrome/browser/profiles/profiles_state.cc
@@ -27,7 +27,7 @@
 #include "content/public/browser/browsing_data_remover.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -82,7 +82,7 @@ void SetLastUsedProfile(const std::string& profile_dir) {
   local_state->SetString(prefs::kProfileLastUsed, profile_dir);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 base::string16 GetAvatarNameForProfile(const base::FilePath& profile_path) {
   if (profile_path == ProfileManager::GetGuestProfilePath()) {
     return l10n_util::GetStringUTF16(IDS_GUEST_PROFILE_NAME);
diff --git a/chrome/browser/profiles/profiles_state.h b/chrome/browser/profiles/profiles_state.h
index 6d3e919daea1..90e33a7cf123 100644
--- a/chrome/browser/profiles/profiles_state.h
+++ b/chrome/browser/profiles/profiles_state.h
@@ -43,7 +43,7 @@ void RegisterPrefs(PrefRegistrySimple* registry);
 // System Profile directory, which is an invalid last used profile.
 void SetLastUsedProfile(const std::string& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Returns the display name of the specified on-the-record profile (or guest),
 // specified by |profile_path|, used in the avatar button or user manager. If
 // |profile_path| is the guest path, it will return IDS_GUEST_PROFILE_NAME. If
diff --git a/chrome/browser/renderer_context_menu/render_view_context_menu.cc b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
index 491e36bcdfba..2a3df2d0119d 100644
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.cc
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
@@ -157,7 +157,7 @@
 #include "ui/gfx/text_elider.h"
 #include "ui/strings/grit/ui_strings.h"
 
-#if BUILDFLAG(USE_RENDERER_SPELLCHECKER)
+#if true || BUILDFLAG(USE_RENDERER_SPELLCHECKER)
 #include "chrome/browser/renderer_context_menu/spelling_options_submenu_observer.h"
 #endif
 
@@ -1746,16 +1746,6 @@ void RenderViewContextMenu::AppendLanguageSettings() {
 #if defined(OS_MACOSX)
   menu_model_.AddItemWithStringId(IDC_CONTENT_CONTEXT_LANGUAGE_SETTINGS,
                                   IDS_CONTENT_CONTEXT_LANGUAGE_SETTINGS);
-#else
-  if (!spelling_options_submenu_observer_) {
-    const int kLanguageRadioGroup = 1;
-    spelling_options_submenu_observer_ =
-        std::make_unique<SpellingOptionsSubMenuObserver>(this, this,
-                                                         kLanguageRadioGroup);
-  }
-
-  spelling_options_submenu_observer_->InitMenu(params_);
-  observers_.AddObserver(spelling_options_submenu_observer_.get());
 #endif
 }
 
diff --git a/chrome/browser/renderer_context_menu/render_view_context_menu.h b/chrome/browser/renderer_context_menu/render_view_context_menu.h
index d5195d4b0f6c..2044bfc6f2ec 100644
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.h
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.h
@@ -33,6 +33,8 @@
 #include "chrome/browser/extensions/menu_manager.h"
 #endif
 
+#include "chrome/browser/renderer_context_menu/spelling_options_submenu_observer.h"
+
 class AccessibilityLabelsMenuObserver;
 class ClickToCallContextMenuObserver;
 class PrintPreviewContextMenuObserver;
diff --git a/chrome/browser/resource_coordinator/resource_coordinator_parts.cc b/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
index 577b26d47bfa..a4cd9e009950 100644
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
@@ -9,12 +9,12 @@
 namespace resource_coordinator {
 
 ResourceCoordinatorParts::ResourceCoordinatorParts()
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     : tab_manager_(&tab_load_tracker_),
       tab_lifecycle_unit_source_(tab_manager_.usage_clock())
 #endif
 {
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   tab_lifecycle_unit_source_.AddObserver(&tab_manager_);
 #endif
 }
diff --git a/chrome/browser/resource_coordinator/resource_coordinator_parts.h b/chrome/browser/resource_coordinator/resource_coordinator_parts.h
index 788e4bd6f9a2..5229f60a7f63 100644
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.h
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.h
@@ -10,7 +10,7 @@
 #include "chrome/browser/resource_coordinator/tab_load_tracker.h"
 #include "chrome/browser/resource_coordinator/tab_memory_metrics_reporter.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/resource_coordinator/tab_lifecycle_unit_source.h"
 #include "chrome/browser/resource_coordinator/tab_manager.h"
 #endif
@@ -39,19 +39,11 @@ class ResourceCoordinatorParts {
   TabLoadTracker* tab_load_tracker() { return &tab_load_tracker_; }
 
   TabManager* tab_manager() {
-#if defined(OS_ANDROID)
-    return nullptr;
-#else
     return &tab_manager_;
-#endif  // defined(OS_ANDROID)
   }
 
   TabLifecycleUnitSource* tab_lifecycle_unit_source() {
-#if defined(OS_ANDROID)
-    return nullptr;
-#else
     return &tab_lifecycle_unit_source_;
-#endif  // defined(OS_ANDROID)
   }
 
  private:
@@ -62,7 +54,7 @@ class ResourceCoordinatorParts {
   // Created on demand the first time it's being accessed.
   std::unique_ptr<TabMemoryMetricsReporter> tab_memory_metrics_reporter_;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Any change to this #ifdef must be reflected as well in
   // chrome/browser/resource_coordinator/tab_manager_browsertest.cc
   //
diff --git a/chrome/browser/resource_coordinator/tab_helper.cc b/chrome/browser/resource_coordinator/tab_helper.cc
index e3e1822e974e..58ce5d97699b 100644
--- a/chrome/browser/resource_coordinator/tab_helper.cc
+++ b/chrome/browser/resource_coordinator/tab_helper.cc
@@ -25,7 +25,7 @@
 #include "content/public/browser/render_process_host.h"
 #include "services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/resource_coordinator/local_site_characteristics_webcontents_observer.h"
 #include "chrome/browser/resource_coordinator/tab_manager.h"
 #endif
@@ -43,7 +43,7 @@ ResourceCoordinatorTabHelper::ResourceCoordinatorTabHelper(
         TabLoadTracker::Get());
   }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   local_site_characteristics_wc_observer_ =
       std::make_unique<LocalSiteCharacteristicsWebContentsObserver>(
           web_contents);
diff --git a/chrome/browser/resource_coordinator/tab_helper.h b/chrome/browser/resource_coordinator/tab_helper.h
index ada74f4c0539..21af0b72fa74 100644
--- a/chrome/browser/resource_coordinator/tab_helper.h
+++ b/chrome/browser/resource_coordinator/tab_helper.h
@@ -53,7 +53,7 @@ class ResourceCoordinatorTabHelper
   ukm::SourceId ukm_source_id() const { return ukm_source_id_; }
   void SetUkmSourceIdForTest(ukm::SourceId id) { ukm_source_id_ = id; }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   LocalSiteCharacteristicsWebContentsObserver*
   local_site_characteristics_wc_observer() {
     return local_site_characteristics_wc_observer_.get();
@@ -68,7 +68,7 @@ class ResourceCoordinatorTabHelper
 
   friend class content::WebContentsUserData<ResourceCoordinatorTabHelper>;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<LocalSiteCharacteristicsWebContentsObserver>
       local_site_characteristics_wc_observer_;
 #endif
diff --git a/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc b/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc
index b0788d433142..5e4a9e980b67 100644
--- a/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc
+++ b/chrome/browser/resource_coordinator/tab_manager_web_contents_data.cc
@@ -41,6 +41,9 @@ void TabManager::WebContentsData::DidStartNavigation(
 void TabManager::WebContentsData::DidFinishNavigation(
     content::NavigationHandle* navigation_handle) {
   SetIsInSessionRestore(false);
+  LOG(ERROR) << "[Kiwi] TabManager::WebContentsData::DidFinishNavigation A: " << g_browser_process;
+  LOG(ERROR) << "[Kiwi] TabManager::WebContentsData::DidFinishNavigation B: " << g_browser_process->GetTabManager();
+  LOG(ERROR) << "[Kiwi] TabManager::WebContentsData::DidFinishNavigation C: " << navigation_handle;
   g_browser_process->GetTabManager()->OnDidFinishNavigation(navigation_handle);
 }
 
diff --git a/chrome/browser/resources/BUILD.gn b/chrome/browser/resources/BUILD.gn
index dee22c328366..765056543fd9 100644
--- a/chrome/browser/resources/BUILD.gn
+++ b/chrome/browser/resources/BUILD.gn
@@ -17,7 +17,7 @@ if (closure_compile) {
       "interventions_internals:closure_compile",
       "reset_password:closure_compile",
     ]
-    if (is_linux || is_win || is_mac) {
+    if (true || is_linux || is_win || is_mac) {
       deps += [
         "bluetooth_internals:closure_compile",
         "bookmarks:closure_compile",
@@ -69,7 +69,7 @@ if (closure_compile) {
   }
 }
 
-if (!is_android) {
+if (true || !is_android) {
   grit("bookmarks_resources") {
     # The .grd contains references to generated files.
     source_is_generated = true
@@ -288,7 +288,7 @@ if (is_chromeos) {
   }
 }
 
-if (!is_android && !is_chromeos) {
+if (true || (!is_android && !is_chromeos)) {
   grit("welcome_resources") {
     source = "welcome/welcome_resources.grd"
 
diff --git a/chrome/browser/resources/md_extensions/extensions.html b/chrome/browser/resources/md_extensions/extensions.html
new file mode 100644
index 000000000000..94f99121fcb7
--- /dev/null
+++ b/chrome/browser/resources/md_extensions/extensions.html
@@ -0,0 +1,47 @@
+<!doctype html>
+<html dir="$i18n{textdirection}" lang="$i18n{language}"
+    class="loading $i18n{loadTimeClasses}">
+<head>
+  <meta charset="utf8">
+  <title>$i18n{title}</title>
+  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
+<if expr="not optimize_webui">
+  <base href="chrome://extensions">
+</if>
+  <style>
+    html {
+      /* --md-background-color in disguise. Not using the var for increased
+       * performance. */
+      background-color: rgb(248, 249, 250);
+
+      /* Remove 300ms delay for 'click' event, when using touch interface. */
+      touch-action: manipulation;
+    }
+
+    .loading {
+      /* --google-blue-700 in disguise. Replaced when manager.html loads. */
+      border-top: 56px solid rgb(51, 103, 214);
+    }
+
+    /* Note: .in-dev-mode is applied by i18n{loadTimeClasses}. */
+    .loading.in-dev-mode {
+      border-top-width: 96px;
+    }
+
+    html,
+    body {
+      height: 100%;
+      line-height: 154%;
+      margin: 0;
+      overflow: hidden;
+      width: 100%;
+    }
+  </style>
+</head>
+<body>
+  <extensions-manager></extensions-manager>
+  <link rel="stylesheet" href="chrome://resources/css/md_colors.css">
+  <link rel="stylesheet" href="chrome://resources/css/text_defaults_md.css">
+  <link rel="import" href="chrome://extensions/manager.html">
+</body>
+</html>
diff --git a/chrome/browser/resources/unpack_pak.py b/chrome/browser/resources/unpack_pak.py
index d0c6ef693325..3689508027c0 100755
--- a/chrome/browser/resources/unpack_pak.py
+++ b/chrome/browser/resources/unpack_pak.py
@@ -50,6 +50,10 @@ def Unpack(pak_path, out_path):
       res = re.match('^#define (\S*).* (\d+)\)?$', line)
       if res:
         resource_ids[int(res.group(2))] = res.group(1)
+      else:
+        res = re.match('#define ([^ ]+) ([^ ]+) (\d+)', line)
+        if res:
+          resource_ids[int(res.group(3))] = res.group(1)
   assert resource_ids
 
   # Associate numerical string IDs to files.
diff --git a/chrome/browser/search/instant_service.h b/chrome/browser/search/instant_service.h
index 4a4ba44043ad..cace1b724b4b 100644
--- a/chrome/browser/search/instant_service.h
+++ b/chrome/browser/search/instant_service.h
@@ -33,10 +33,6 @@
 #include "ui/native_theme/native_theme_observer.h"
 #include "url/gurl.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class InstantIOContext;
 class InstantServiceObserver;
 class Profile;
diff --git a/chrome/browser/search/instant_service_factory.h b/chrome/browser/search/instant_service_factory.h
index 2db314b90617..4d3e053d532f 100644
--- a/chrome/browser/search/instant_service_factory.h
+++ b/chrome/browser/search/instant_service_factory.h
@@ -10,10 +10,6 @@
 #include "build/build_config.h"
 #include "components/keyed_service/content/browser_context_keyed_service_factory.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class InstantService;
 class Profile;
 
diff --git a/chrome/browser/search/instant_service_observer.h b/chrome/browser/search/instant_service_observer.h
index 29b80c5cc853..0575e64c191e 100644
--- a/chrome/browser/search/instant_service_observer.h
+++ b/chrome/browser/search/instant_service_observer.h
@@ -9,10 +9,6 @@
 
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 struct InstantMostVisitedInfo;
 struct NtpTheme;
 
diff --git a/chrome/browser/search/local_ntp_source.h b/chrome/browser/search/local_ntp_source.h
index 0d299a5f2600..7644cfddac4a 100644
--- a/chrome/browser/search/local_ntp_source.h
+++ b/chrome/browser/search/local_ntp_source.h
@@ -26,10 +26,6 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 struct OneGoogleBarData;
 struct PromoData;
 class Profile;
diff --git a/chrome/browser/search/most_visited_iframe_source.h b/chrome/browser/search/most_visited_iframe_source.h
index c0ecdacffab8..8c88fab79fc2 100644
--- a/chrome/browser/search/most_visited_iframe_source.h
+++ b/chrome/browser/search/most_visited_iframe_source.h
@@ -9,10 +9,6 @@
 #include "build/build_config.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 // Serves HTML for displaying suggestions using iframes, e.g.
 // chrome-search://most-visited/single.html
 class MostVisitedIframeSource : public content::URLDataSource {
diff --git a/chrome/browser/sharing/click_to_call/feature.cc b/chrome/browser/sharing/click_to_call/feature.cc
index 9921fd492667..06e572476c1f 100644
--- a/chrome/browser/sharing/click_to_call/feature.cc
+++ b/chrome/browser/sharing/click_to_call/feature.cc
@@ -9,7 +9,7 @@ const base::Feature kClickToCallReceiver{"ClickToCallReceiver",
                                          base::FEATURE_ENABLED_BY_DEFAULT};
 #endif  // defined(OS_ANDROID)
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 const base::Feature kClickToCallUI{"ClickToCallUI",
                                    base::FEATURE_ENABLED_BY_DEFAULT};
 
diff --git a/chrome/browser/sharing/click_to_call/feature.h b/chrome/browser/sharing/click_to_call/feature.h
index ca367376f6ac..a5c1ad98a16a 100644
--- a/chrome/browser/sharing/click_to_call/feature.h
+++ b/chrome/browser/sharing/click_to_call/feature.h
@@ -14,7 +14,7 @@
 extern const base::Feature kClickToCallReceiver;
 #endif  // defined(OS_ANDROID)
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 // Feature to allow click to call gets processed on desktop.
 extern const base::Feature kClickToCallUI;
 
diff --git a/chrome/browser/sharing/shared_clipboard/feature_flags.cc b/chrome/browser/sharing/shared_clipboard/feature_flags.cc
index 2fdf694812a7..4f278c961ca8 100644
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.cc
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.cc
@@ -11,7 +11,7 @@ const base::Feature kSharedClipboardUI{"SharedClipboardUI",
                                        base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 const base::Feature kRemoteCopyReceiver{"RemoteCopyReceiver",
                                         base::FEATURE_DISABLED_BY_DEFAULT};
 
diff --git a/chrome/browser/sharing/shared_clipboard/feature_flags.h b/chrome/browser/sharing/shared_clipboard/feature_flags.h
index d26791db7a26..d9dffda9c33a 100644
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.h
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.h
@@ -18,7 +18,7 @@ extern const base::Feature kSharedClipboardReceiver;
 extern const base::Feature kSharedClipboardUI;
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 // Feature to enable handling remote copy messages.
 extern const base::Feature kRemoteCopyReceiver;
 
diff --git a/chrome/browser/signin/account_consistency_mode_manager.cc b/chrome/browser/signin/account_consistency_mode_manager.cc
index 75bd8332ec58..430a1cca5093 100644
--- a/chrome/browser/signin/account_consistency_mode_manager.cc
+++ b/chrome/browser/signin/account_consistency_mode_manager.cc
@@ -33,7 +33,9 @@ namespace {
 // Preference indicating that the Dice migraton has happened.
 const char kDiceMigrationCompletePref[] = "signin.DiceMigrationComplete";
 
+#if 0
 const char kDiceMigrationStatusHistogram[] = "Signin.DiceMigrationStatus";
+#endif
 
 // Used for UMA histogram kDiceMigrationStatusHistogram.
 // Do not remove or re-order values.
@@ -47,6 +49,7 @@ enum class DiceMigrationStatus {
   kDiceMigrationStatusCount
 };
 
+#if 0
 DiceMigrationStatus GetDiceMigrationStatus(
     AccountConsistencyMethod account_consistency) {
   switch (account_consistency) {
@@ -60,6 +63,7 @@ DiceMigrationStatus GetDiceMigrationStatus(
   }
 }
 #endif
+#endif
 
 }  // namespace
 
@@ -93,7 +97,7 @@ AccountConsistencyModeManager::AccountConsistencyModeManager(Profile* profile)
 
   account_consistency_ = ComputeAccountConsistencyMethod(profile_);
 
-#if BUILDFLAG(ENABLE_DICE_SUPPORT)
+#if false && BUILDFLAG(ENABLE_DICE_SUPPORT)
   // New profiles don't need Dice migration. Old profiles may need it if they
   // were created before Dice.
   if (profile_->IsNewProfile())
diff --git a/chrome/browser/signin/chrome_signin_helper.cc b/chrome/browser/signin/chrome_signin_helper.cc
index f73fca57478f..73917f70e8d7 100644
--- a/chrome/browser/signin/chrome_signin_helper.cc
+++ b/chrome/browser/signin/chrome_signin_helper.cc
@@ -48,7 +48,7 @@
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/signin/signin_utils.h"
 #include "ui/android/view_android.h"
-#else
+
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_window.h"
diff --git a/chrome/browser/startup_data.cc b/chrome/browser/startup_data.cc
index ba8b5a110c2b..6217f5c91593 100644
--- a/chrome/browser/startup_data.cc
+++ b/chrome/browser/startup_data.cc
@@ -87,12 +87,18 @@ void StartupData::RecordCoreSystemProfile() {
 
 #if defined(OS_ANDROID)
 void StartupData::CreateProfilePrefService() {
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 1";
   key_ = std::make_unique<ProfileKey>(GetProfilePath());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 2";
   PreProfilePrefServiceInit();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 3";
   CreateServicesInternal();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 4";
   key_->SetPrefs(prefs_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 5";
 
   ProfileKeyStartupAccessor::GetInstance()->SetProfileKey(key_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateProfilePrefService - Step 6";
 }
 
 bool StartupData::HasBuiltProfilePrefService() {
@@ -138,12 +144,16 @@ StartupData::TakeProtoDatabaseProvider() {
 }
 
 void StartupData::PreProfilePrefServiceInit() {
+  LOG(ERROR) << "[Kiwi] StartupData::PreProfilePrefServiceInit - Step 1";
   pref_registry_ = base::MakeRefCounted<user_prefs::PrefRegistrySyncable>();
+  LOG(ERROR) << "[Kiwi] StartupData::PreProfilePrefServiceInit - Step 2";
   ChromeBrowserMainExtraPartsProfiles::
-      EnsureBrowserContextKeyedServiceFactoriesBuilt();
+      EnsureBrowserContextKeyedServiceFactoriesBuilt(false);
+  LOG(ERROR) << "[Kiwi] StartupData::PreProfilePrefServiceInit - Step 3";
 }
 
 void StartupData::CreateServicesInternal() {
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 1";
   const base::FilePath& path = key_->GetPath();
   if (!base::PathExists(path)) {
     // TODO(rogerta): http://crbug/160553 - Bad things happen if we can't
@@ -153,25 +163,32 @@ void StartupData::CreateServicesInternal() {
       return;
 
     CreateProfileReadme(path);
+    LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 2";
   }
 
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 3";
   scoped_refptr<base::SequencedTaskRunner> io_task_runner =
       base::CreateSequencedTaskRunner(
           {base::ThreadPool(), base::TaskShutdownBehavior::BLOCK_SHUTDOWN,
            base::MayBlock()});
 
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 4";
   policy::ChromeBrowserPolicyConnector* browser_policy_connector =
       chrome_feature_list_creator_->browser_policy_connector();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 5";
   std::unique_ptr<policy::SchemaRegistry> schema_registry =
       std::make_unique<policy::SchemaRegistry>();
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 6";
   schema_registry_service_ = BuildSchemaRegistryService(
       std::move(schema_registry), browser_policy_connector->GetChromeSchema(),
       browser_policy_connector->GetSchemaRegistry());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 7";
 
   user_cloud_policy_manager_ = CreateUserCloudPolicyManager(
       path, schema_registry_service_->registry(),
       true /* force_immediate_policy_load */, io_task_runner);
 
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 8";
   profile_policy_connector_ = policy::CreateAndInitProfilePolicyConnector(
       schema_registry_service_->registry(),
       static_cast<policy::ChromeBrowserPolicyConnector*>(
@@ -179,26 +196,32 @@ void StartupData::CreateServicesInternal() {
       user_cloud_policy_manager_.get(),
       user_cloud_policy_manager_->core()->store(),
       true /* force_immediate_policy_load*/, nullptr /* user */);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 9";
 
   // StoragePartitionImplMap uses profile directory as default storage
   // partition, see StoragePartitionImplMap::GetStoragePartitionPath().
   proto_db_provider_ =
       std::make_unique<leveldb_proto::ProtoDatabaseProvider>(path);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 10";
   key_->SetProtoDatabaseProvider(proto_db_provider_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 11";
 
   RegisterProfilePrefs(false /* is_signin_profile */,
                        chrome_feature_list_creator_->actual_locale(),
                        pref_registry_.get());
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 12";
 
   mojo::PendingRemote<prefs::mojom::TrackedPreferenceValidationDelegate>
       pref_validation_delegate;
   // The preference tracking and protection is not required on Android.
   DCHECK(!ProfilePrefStoreManager::kPlatformSupportsPreferenceTracking);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 14";
 
   prefs_ = CreatePrefService(
       pref_registry_, nullptr /* extension_pref_store */,
       profile_policy_connector_->policy_service(), browser_policy_connector,
       std::move(pref_validation_delegate), io_task_runner, key_.get(), path,
       false /* async_prefs*/);
+  LOG(ERROR) << "[Kiwi] StartupData::CreateServicesInternal - Step 15";
 }
 #endif
diff --git a/chrome/browser/supervised_user/supervised_user_service.cc b/chrome/browser/supervised_user/supervised_user_service.cc
index e778b7059361..a057785007bc 100644
--- a/chrome/browser/supervised_user/supervised_user_service.cc
+++ b/chrome/browser/supervised_user/supervised_user_service.cc
@@ -660,6 +660,8 @@ void SupervisedUserService::OnBlacklistLoaded() {
 }
 
 void SupervisedUserService::UpdateBlacklist() {
+  if (true)
+    return;
   bool use_blacklist = supervised_users::IsSafeSitesBlacklistEnabled(profile_);
   url_filter_.SetBlacklist(use_blacklist ? &blacklist_ : nullptr);
   for (SupervisedUserServiceObserver& observer : observer_list_)
diff --git a/chrome/browser/sync/profile_sync_service_factory.cc b/chrome/browser/sync/profile_sync_service_factory.cc
index bed5a18c962d..22dab3738847 100644
--- a/chrome/browser/sync/profile_sync_service_factory.cc
+++ b/chrome/browser/sync/profile_sync_service_factory.cc
@@ -136,47 +136,76 @@ ProfileSyncServiceFactory::ProfileSyncServiceFactory()
   // when it is shut down.  Specify those dependencies here to build the proper
   // destruction order. Note that some of the dependencies are listed here but
   // actually plumbed in ChromeSyncClient, which this factory constructs.
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 1";
   DependsOn(AboutSigninInternalsFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 2";
   DependsOn(AccountPasswordStoreFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 3";
   DependsOn(autofill::PersonalDataManagerFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 4";
   DependsOn(BookmarkModelFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 5";
   DependsOn(BookmarkSyncServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 6";
   DependsOn(BookmarkUndoServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 7";
   DependsOn(browser_sync::UserEventServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 8";
   DependsOn(ConsentAuditorFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 9";
   DependsOn(DeviceInfoSyncServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 10";
   DependsOn(FaviconServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 11";
   DependsOn(gcm::GCMProfileServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 12";
   DependsOn(HistoryServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 13";
   DependsOn(IdentityManagerFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 14";
   DependsOn(invalidation::DeprecatedProfileInvalidationProviderFactory::
                 GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 15";
   DependsOn(invalidation::ProfileInvalidationProviderFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 16";
   DependsOn(ModelTypeStoreServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 17";
   DependsOn(PasswordStoreFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 18";
   DependsOn(SecurityEventRecorderFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 19";
   DependsOn(SendTabToSelfSyncServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 20";
   DependsOn(SpellcheckServiceFactory::GetInstance());
-#if BUILDFLAG(ENABLE_SUPERVISED_USERS)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 21";
+#if false && BUILDFLAG(ENABLE_SUPERVISED_USERS)
   DependsOn(SupervisedUserServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 22";
   DependsOn(SupervisedUserSettingsServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 23";
 #endif  // BUILDFLAG(ENABLE_SUPERVISED_USERS)
   DependsOn(SessionSyncServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 24";
   DependsOn(TemplateURLServiceFactory::GetInstance());
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 25";
 #if !defined(OS_ANDROID)
   DependsOn(ThemeServiceFactory::GetInstance());
 #endif  // !defined(OS_ANDROID)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 26";
   DependsOn(WebDataServiceFactory::GetInstance());
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 27";
+#if false && BUILDFLAG(ENABLE_EXTENSIONS)
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
   DependsOn(extensions::StorageFrontend::GetFactoryInstance());
   DependsOn(web_app::WebAppProviderFactory::GetInstance());
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 28";
 #if defined(OS_CHROMEOS)
   DependsOn(chromeos::SyncedPrintersManagerFactory::GetInstance());
   DependsOn(WifiConfigurationSyncServiceFactory::GetInstance());
 #endif  // defined(OS_CHROMEOS)
+  LOG(ERROR) << "[Kiwi] ProfileSyncServiceFactory::ProfileSyncServiceFactory - Step 29";
 }
 
 ProfileSyncServiceFactory::~ProfileSyncServiceFactory() = default;
diff --git a/chrome/browser/ui/BUILD.gn b/chrome/browser/ui/BUILD.gn
index 7932e2421de6..5f5c103fe632 100644
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -587,7 +587,7 @@ jumbo_static_library("ui") {
   allow_circular_includes_from +=
       [ "//chrome/browser/ui/webui/bluetooth_internals" ]
 
-  if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+  if (true || is_win || is_mac || is_desktop_linux || is_chromeos) {
     deps += [ "//chrome/browser/ui/webui/discards:mojo_bindings" ]
   }
 
@@ -804,7 +804,9 @@ jumbo_static_library("ui") {
       "//services/device/public/mojom:usb",
       "//ui/android",
     ]
-  } else {
+  }
+  if (true)
+  {
     # !is_android
     sources += [
       "apps/app_info_dialog.h",
@@ -1016,6 +1018,8 @@ jumbo_static_library("ui") {
       "media_router/ui_media_sink.cc",
       "media_router/ui_media_sink.h",
       "native_window_tracker.h",
+      "native_window_tracker_android.cc",
+      "native_window_tracker_android.h",
       "omnibox/alternate_nav_infobar_delegate.cc",
       "omnibox/alternate_nav_infobar_delegate.h",
       "omnibox/chrome_omnibox_client.cc",
@@ -2049,7 +2053,7 @@ jumbo_static_library("ui") {
     }
   }
 
-  if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+  if (is_win || is_mac || is_desktop_linux || is_chromeos || true) {
     sources += [
       "autofill/payments/webauthn_dialog_controller.h",
       "autofill/payments/webauthn_dialog_controller_impl.cc",
@@ -2098,13 +2102,17 @@ jumbo_static_library("ui") {
     deps += [ "//ui/webui" ]
   }
 
-  if (is_win || is_mac || is_desktop_linux) {
+  if (is_win || is_mac || is_desktop_linux || is_android) {
     sources += [
       "avatar_button_error_controller.cc",
       "avatar_button_error_controller.h",
       "avatar_button_error_controller_delegate.h",
       "bookmarks/bookmark_bubble_sign_in_delegate.cc",
       "bookmarks/bookmark_bubble_sign_in_delegate.h",
+#      "signin_view_controller.cc",
+#      "signin_view_controller.h",
+#      "signin_view_controller_delegate.cc",
+#      "signin_view_controller_delegate.h",
       "startup/default_browser_infobar_delegate.cc",
       "startup/default_browser_infobar_delegate.h",
       "startup/default_browser_prompt.cc",
@@ -2114,8 +2122,6 @@ jumbo_static_library("ui") {
       "sync/one_click_signin_links_delegate_impl.h",
       "user_manager.cc",
       "user_manager.h",
-      "views/external_protocol_dialog.cc",
-      "views/external_protocol_dialog.h",
       "views/profiles/badged_profile_photo.cc",
       "views/profiles/badged_profile_photo.h",
       "views/profiles/profile_menu_view.cc",
@@ -2500,6 +2506,11 @@ jumbo_static_library("ui") {
     }
   }
 
+  sources += [
+    "views/chrome_views_delegate_android.cc",
+    "views/frame/native_browser_frame_factory_android.cc",
+  ]
+
   if (is_desktop_linux) {
     sources += [
       "views/apps/chrome_app_window_client_views_linux.cc",
@@ -2602,8 +2613,9 @@ jumbo_static_library("ui") {
       sources += [ "views/tabs/window_finder_ozone.cc" ]
     }
   }
+  sources += [ "views/tabs/window_finder_android.cc" ]
 
-  if (toolkit_views) {
+  if (true || toolkit_views) {
     sources += [
       "autofill/payments/local_card_migration_bubble.h",
       "autofill/payments/local_card_migration_bubble_controller_impl.cc",
@@ -2667,10 +2679,6 @@ jumbo_static_library("ui") {
       "views/autofill/autofill_bubble_handler_impl.h",
       "views/autofill/autofill_popup_base_view.cc",
       "views/autofill/autofill_popup_base_view.h",
-      "views/autofill/autofill_popup_view_native_views.cc",
-      "views/autofill/autofill_popup_view_native_views.h",
-      "views/autofill/payments/card_unmask_prompt_views.cc",
-      "views/autofill/payments/card_unmask_prompt_views.h",
       "views/autofill/payments/dialog_view_ids.h",
       "views/autofill/payments/local_card_migration_bubble_views.cc",
       "views/autofill/payments/local_card_migration_bubble_views.h",
@@ -2776,6 +2784,7 @@ jumbo_static_library("ui") {
       "views/download/download_started_animation_views.cc",
       "views/dropdown_bar_host.cc",
       "views/dropdown_bar_host.h",
+      "views/dropdown_bar_host_android.cc",
       "views/dropdown_bar_host_delegate.h",
       "views/elevation_icon_setter.cc",
       "views/elevation_icon_setter.h",
@@ -2906,8 +2915,6 @@ jumbo_static_library("ui") {
       "views/importer/import_lock_dialog_view.h",
       "views/infobars/alternate_nav_infobar_view.cc",
       "views/infobars/alternate_nav_infobar_view.h",
-      "views/infobars/confirm_infobar.cc",
-      "views/infobars/confirm_infobar.h",
       "views/infobars/infobar_container_view.cc",
       "views/infobars/infobar_container_view.h",
       "views/infobars/infobar_view.cc",
@@ -2963,12 +2970,8 @@ jumbo_static_library("ui") {
       "views/media_router/cast_dialog_view.h",
       "views/media_router/cast_toolbar_button.cc",
       "views/media_router/cast_toolbar_button.h",
-      "views/media_router/cloud_services_dialog_view.cc",
-      "views/media_router/cloud_services_dialog_view.h",
       "views/media_router/media_remoting_dialog_view.cc",
       "views/media_router/media_remoting_dialog_view.h",
-      "views/media_router/media_router_dialog_controller_views.cc",
-      "views/media_router/media_router_dialog_controller_views.h",
       "views/media_router/media_router_views_ui.cc",
       "views/media_router/media_router_views_ui.h",
       "views/media_router/presentation_receiver_window_factory.cc",
@@ -3010,8 +3013,6 @@ jumbo_static_library("ui") {
       "views/overlay/back_to_tab_image_button.h",
       "views/overlay/close_image_button.cc",
       "views/overlay/close_image_button.h",
-      "views/overlay/overlay_window_views.cc",
-      "views/overlay/overlay_window_views.h",
       "views/overlay/playback_image_button.cc",
       "views/overlay/playback_image_button.h",
       "views/overlay/resize_handle_button.cc",
@@ -3042,8 +3043,6 @@ jumbo_static_library("ui") {
       "views/page_info/permission_selector_row.cc",
       "views/page_info/permission_selector_row.h",
       "views/page_info/permission_selector_row_observer.h",
-      "views/page_info/safety_tip_page_info_bubble_view.cc",
-      "views/page_info/safety_tip_page_info_bubble_view.h",
       "views/passwords/account_chooser_dialog_view.cc",
       "views/passwords/account_chooser_dialog_view.h",
       "views/passwords/auto_signin_first_run_dialog_view.cc",
@@ -3058,8 +3057,6 @@ jumbo_static_library("ui") {
       "views/passwords/password_auto_sign_in_view.h",
       "views/passwords/password_bubble_view_base.cc",
       "views/passwords/password_bubble_view_base.h",
-      "views/passwords/password_generation_popup_view_views.cc",
-      "views/passwords/password_generation_popup_view_views.h",
       "views/passwords/password_items_view.cc",
       "views/passwords/password_items_view.h",
       "views/passwords/password_pending_view.cc",
@@ -3154,8 +3151,6 @@ jumbo_static_library("ui") {
       "views/sharing/sharing_dialog_view.h",
       "views/sharing/sharing_icon_view.cc",
       "views/sharing/sharing_icon_view.h",
-      "views/simple_message_box_views.cc",
-      "views/simple_message_box_views.h",
       "views/status_bubble_views.cc",
       "views/status_bubble_views.h",
       "views/subtle_notification_view.cc",
@@ -3369,8 +3364,6 @@ jumbo_static_library("ui") {
       sources += [
         "views/create_application_shortcut_view.cc",
         "views/create_application_shortcut_view.h",
-        "views/ssl_client_certificate_selector.cc",
-        "views/ssl_client_certificate_selector.h",
       ]
     }
 
@@ -3458,6 +3451,14 @@ jumbo_static_library("ui") {
     }
   }
 
+  sources += [
+      "views/accelerator_utils_android.cc",
+      "window_sizer/window_sizer_android.cc",
+      "views/frame/browser_non_client_frame_view_factory_views.cc",
+      "views/frame/desktop_browser_frame_android.cc",
+      "views/frame/desktop_browser_frame_android.h",
+  ]
+
   if (use_aura) {
     sources += [
       "aura/accessibility/automation_manager_aura.cc",
diff --git a/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc b/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
index ed43c8eff770..48c291866e75 100644
--- a/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
@@ -63,7 +63,7 @@ std::vector<GURL> GetURLsToOpen(
   return urls;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 bool ShouldOpenAll(gfx::NativeWindow parent,
                    const std::vector<const BookmarkNode*>& nodes) {
   size_t child_count = GetURLsToOpen(nodes).size();
@@ -89,7 +89,7 @@ int ChildURLCountTotal(const BookmarkNode* node) {
                          count_children);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Returns in |urls|, the url and title pairs for each open tab in browser.
 void GetURLsForOpenTabs(Browser* browser,
                         std::vector<std::pair<GURL, base::string16>>* urls) {
@@ -104,7 +104,7 @@ void GetURLsForOpenTabs(Browser* browser,
 
 }  // namespace
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void OpenAll(gfx::NativeWindow parent,
              content::PageNavigator* navigator,
              const std::vector<const BookmarkNode*>& nodes,
@@ -188,9 +188,6 @@ void ShowBookmarkAllTabsDialog(Browser* browser) {
       BookmarkEditor::EditDetails::AddFolder(parent, parent->children().size());
   GetURLsForOpenTabs(browser, &(details.urls));
   DCHECK(!details.urls.empty());
-
-  BookmarkEditor::Show(browser->window()->GetNativeWindow(), profile, details,
-                       BookmarkEditor::SHOW_TREE);
 }
 
 bool HasBookmarkURLs(const std::vector<const BookmarkNode*>& selection) {
diff --git a/chrome/browser/ui/browser.cc b/chrome/browser/ui/browser.cc
index d262a424f49b..d07206288837 100644
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -280,6 +280,7 @@ const int kUIUpdateCoalescingTimeMS = 200;
 
 BrowserWindow* CreateBrowserWindow(std::unique_ptr<Browser> browser,
                                    bool user_gesture) {
+  LOG(ERROR) << "[Kiwi] BrowserWindow* CreateBrowserWindow";
   return BrowserWindow::CreateBrowserWindow(std::move(browser), user_gesture);
 }
 
@@ -1946,6 +1947,7 @@ void Browser::RequestPpapiBrokerPermission(
     return;
   }
 
+#if 0
   TabSpecificContentSettings* tab_content_settings =
       TabSpecificContentSettings::FromWebContents(web_contents);
 
@@ -1977,7 +1979,8 @@ void Browser::RequestPpapiBrokerPermission(
                          ? base::UserMetricsAction("PPAPI.BrokerSettingAllow")
                          : base::UserMetricsAction("PPAPI.BrokerSettingDeny"));
   tab_content_settings->SetPepperBrokerAllowed(allowed);
-  std::move(callback).Run(allowed);
+#endif
+  std::move(callback).Run(false);
   return;
 }
 
@@ -2587,6 +2590,7 @@ void Browser::SetAsDelegate(WebContents* web_contents, bool set_delegate) {
   web_contents->SetDelegate(delegate);
 
   // ...and all the helpers.
+#if 0
   WebContentsModalDialogManager::FromWebContents(web_contents)
       ->SetDelegate(delegate);
   translate::ContentTranslateDriver* content_translate_driver =
@@ -2600,6 +2604,7 @@ void Browser::SetAsDelegate(WebContents* web_contents, bool set_delegate) {
     content_translate_driver->RemoveObserver(this);
     BookmarkTabHelper::FromWebContents(web_contents)->RemoveObserver(this);
   }
+#endif
 }
 
 void Browser::CloseFrame() {
diff --git a/chrome/browser/ui/browser.h b/chrome/browser/ui/browser.h
index 73a31f7274ac..4b4eb4199fa8 100644
--- a/chrome/browser/ui/browser.h
+++ b/chrome/browser/ui/browser.h
@@ -55,9 +55,11 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
+#if 0
 #if defined(OS_ANDROID)
 #error This file should only be included on desktop.
 #endif
+#endif
 
 class BackgroundContents;
 class BrowserContentSettingBubbleModelDelegate;
diff --git a/chrome/browser/ui/browser_command_controller.cc b/chrome/browser/ui/browser_command_controller.cc
index 8991faab0782..6fb6726aa91a 100644
--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -645,19 +645,15 @@ bool BrowserCommandController::ExecuteCommandWithDisposition(
                                               false /* force_shortcut_app */);
       break;
     case IDC_DEV_TOOLS:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Show());
       break;
     case IDC_DEV_TOOLS_CONSOLE:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::ShowConsolePanel());
       break;
     case IDC_DEV_TOOLS_DEVICES:
       InspectUI::InspectDevices(browser_);
       break;
     case IDC_DEV_TOOLS_INSPECT:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Inspect());
       break;
     case IDC_DEV_TOOLS_TOGGLE:
-      ToggleDevToolsWindow(browser_, DevToolsToggleAction::Toggle());
       break;
     case IDC_TASK_MANAGER:
       OpenTaskManager(browser_);
diff --git a/chrome/browser/ui/browser_commands.cc b/chrome/browser/ui/browser_commands.cc
index c4cc789e6a83..298295e21ede 100644
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -1235,7 +1235,6 @@ void ToggleDevToolsWindow(Browser* browser, DevToolsToggleAction action) {
     base::RecordAction(UserMetricsAction("DevTools_ToggleConsole"));
   else
     base::RecordAction(UserMetricsAction("DevTools_ToggleWindow"));
-  DevToolsWindow::ToggleDevToolsWindow(browser, action);
 }
 
 bool CanOpenTaskManager() {
diff --git a/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc b/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
index 9643d436d7d8..a84c1fab5bf7 100644
--- a/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
+++ b/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
@@ -49,7 +49,7 @@ void BrowserContentSettingBubbleModelDelegate::ShowLearnMorePage(
   GURL learn_more_url;
   switch (type) {
     case ContentSettingsType::PLUGINS:
-      learn_more_url = GURL(chrome::kBlockedPluginLearnMoreURL);
+      learn_more_url = GURL("https://www.kiwibrowser.com/");
       break;
     case ContentSettingsType::ADS:
       learn_more_url = GURL(subresource_filter::kLearnMoreLink);
diff --git a/chrome/browser/ui/browser_instant_controller.h b/chrome/browser/ui/browser_instant_controller.h
index 4d105455ff24..e97cb9d82162 100644
--- a/chrome/browser/ui/browser_instant_controller.h
+++ b/chrome/browser/ui/browser_instant_controller.h
@@ -13,10 +13,6 @@
 #include "chrome/browser/search/search_engine_base_url_tracker.h"
 #include "chrome/browser/ui/search/instant_controller.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class Browser;
 class Profile;
 
diff --git a/chrome/browser/ui/browser_list.cc b/chrome/browser/ui/browser_list.cc
index 781607118c13..6a9ca0f060e6 100644
--- a/chrome/browser/ui/browser_list.cc
+++ b/chrome/browser/ui/browser_list.cc
@@ -129,13 +129,14 @@ void BrowserList::RemoveBrowser(Browser* browser) {
     // shutdown, because Browser::WindowClosing() already makes sure that the
     // SessionService is created and notified.
     browser_shutdown::NotifyAppTerminating();
-    chrome::OnAppExiting();
   }
 }
 
 // static
 void BrowserList::AddObserver(BrowserListObserver* observer) {
+  LOG(ERROR) << "[Kiwi] BrowserList::AddObserver - Step 1";
   observers_.Get().AddObserver(observer);
+  LOG(ERROR) << "[Kiwi] BrowserList::AddObserver - Step 2";
 }
 
 // static
diff --git a/chrome/browser/ui/browser_navigator_params.cc b/chrome/browser/ui/browser_navigator_params.cc
index 2b5a3bf75d22..be0ef232eb1a 100644
--- a/chrome/browser/ui/browser_navigator_params.cc
+++ b/chrome/browser/ui/browser_navigator_params.cc
@@ -13,7 +13,7 @@
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/web_contents.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -24,7 +24,7 @@ using content::WebContents;
 #if defined(OS_ANDROID)
 NavigateParams::NavigateParams(std::unique_ptr<WebContents> contents_to_insert)
     : contents_to_insert(std::move(contents_to_insert)) {}
-#else
+
 NavigateParams::NavigateParams(Browser* a_browser,
                                const GURL& a_url,
                                ui::PageTransition a_transition)
diff --git a/chrome/browser/ui/browser_navigator_params.h b/chrome/browser/ui/browser_navigator_params.h
index d3acc5cb0aeb..1c92ffd0d083 100644
--- a/chrome/browser/ui/browser_navigator_params.h
+++ b/chrome/browser/ui/browser_navigator_params.h
@@ -25,7 +25,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/ui/tabs/tab_group_id.h"
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
 #endif
@@ -66,7 +66,7 @@ struct NavigateParams {
 #if defined(OS_ANDROID)
   explicit NavigateParams(
       std::unique_ptr<content::WebContents> contents_to_insert);
-#else
+
   NavigateParams(Browser* browser,
                  const GURL& a_url,
                  ui::PageTransition a_transition);
@@ -211,7 +211,7 @@ struct NavigateParams {
   };
   PathBehavior path_behavior = RESPECT;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // [in]  Specifies a Browser object where the navigation could occur or the
   //       tab could be added. Navigate() is not obliged to use this Browser if
   //       it is not compatible with the operation being performed. This can be
diff --git a/chrome/browser/ui/browser_otr_state.cc b/chrome/browser/ui/browser_otr_state.cc
index 4c79c00b25a3..233af8247614 100644
--- a/chrome/browser/ui/browser_otr_state.cc
+++ b/chrome/browser/ui/browser_otr_state.cc
@@ -8,8 +8,4 @@
 
 namespace chrome {
 
-bool IsIncognitoSessionActive() {
-  return BrowserList::IsIncognitoSessionActive();
-}
-
 }  // namespace chrome
diff --git a/chrome/browser/ui/browser_ui_prefs.cc b/chrome/browser/ui/browser_ui_prefs.cc
index fa9ec80a9755..214dba85c0e8 100644
--- a/chrome/browser/ui/browser_ui_prefs.cc
+++ b/chrome/browser/ui/browser_ui_prefs.cc
@@ -40,7 +40,7 @@ uint32_t GetHomeButtonAndHomePageIsNewTabPageFlags() {
 void RegisterBrowserPrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kAllowFileSelectionDialogs, true);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   registry->RegisterIntegerPref(prefs::kRelaunchNotification, 0);
   registry->RegisterIntegerPref(
       prefs::kRelaunchNotificationPeriod,
diff --git a/chrome/browser/ui/browser_window.h b/chrome/browser/ui/browser_window.h
index 8b1bbcde9a7a..e527178396a3 100644
--- a/chrome/browser/ui/browser_window.h
+++ b/chrome/browser/ui/browser_window.h
@@ -31,10 +31,6 @@
 #include "ui/gfx/native_widget_types.h"
 #include "url/origin.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Browser;
 class SharingDialog;
 class DownloadShelf;
diff --git a/chrome/browser/ui/chrome_pages.cc b/chrome/browser/ui/chrome_pages.cc
index 25469b494ae5..0b0e25a37961 100644
--- a/chrome/browser/ui/chrome_pages.cc
+++ b/chrome/browser/ui/chrome_pages.cc
@@ -68,7 +68,7 @@
 #include "chrome/browser/ui/signin_view_controller.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/signin/identity_manager_factory.h"
 #include "components/signin/public/base/signin_pref_names.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
@@ -506,7 +506,7 @@ GURL GetOSSettingsUrl(const std::string& sub_page) {
 }
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || (!defined(OS_ANDROID) && !defined(OS_CHROMEOS))
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point) {
   Profile* original_profile = browser->profile()->GetOriginalProfile();
diff --git a/chrome/browser/ui/chrome_pages.h b/chrome/browser/ui/chrome_pages.h
index 24779d2549fa..1fad252cb1f4 100644
--- a/chrome/browser/ui/chrome_pages.h
+++ b/chrome/browser/ui/chrome_pages.h
@@ -13,7 +13,7 @@
 #include "components/content_settings/core/common/content_settings_types.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/signin/signin_promo.h"
 #endif
 
@@ -135,7 +135,7 @@ void ShowEnterpriseManagementPageInTabbedBrowser(Browser* browser);
 GURL GetOSSettingsUrl(const std::string& sub_page);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if true || (!defined(OS_ANDROID) && !defined(OS_CHROMEOS))
 // Initiates signin in a new browser tab.
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point);
diff --git a/chrome/browser/ui/content_settings/content_setting_bubble_model.cc b/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
index 5f600f81d7bb..820f3e7b932d 100644
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
@@ -691,10 +691,13 @@ ContentSettingPluginBubbleModel::ContentSettingPluginBubbleModel(
   const GURL& url = web_contents->GetURL();
   bool managed_by_user =
       GetSettingManagedByUser(url, content_type(), GetProfile(), nullptr);
+#if 0
   HostContentSettingsMap* map =
       HostContentSettingsMapFactory::GetForProfile(GetProfile());
   ContentSetting setting = PluginUtils::GetFlashPluginContentSetting(
       map, url::Origin::Create(url), url, nullptr);
+#endif
+  ContentSetting setting = CONTENT_SETTING_BLOCK;
 
   // If the setting is not managed by the user, hide the "Manage" button.
   if (!managed_by_user)
diff --git a/chrome/browser/ui/content_settings/content_setting_bubble_model.h b/chrome/browser/ui/content_settings/content_setting_bubble_model.h
index 83f24dfcc1ea..8ab6d5fa5072 100644
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.h
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.h
@@ -505,7 +505,7 @@ class ContentSettingSingleRadioGroup : public ContentSettingSimpleBubbleModel {
   DISALLOW_COPY_AND_ASSIGN(ContentSettingSingleRadioGroup);
 };
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // The model for the blocked Framebust bubble.
 class ContentSettingFramebustBlockBubbleModel
     : public ContentSettingSingleRadioGroup,
diff --git a/chrome/browser/ui/fast_unload_controller.cc b/chrome/browser/ui/fast_unload_controller.cc
new file mode 100644
index 000000000000..fe6f07d69351
--- /dev/null
+++ b/chrome/browser/ui/fast_unload_controller.cc
@@ -0,0 +1,487 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/fast_unload_controller.h"
+
+#include "base/location.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/single_thread_task_runner.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "chrome/browser/chrome_notification_types.h"
+#include "chrome/browser/devtools/devtools_window.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_tabstrip.h"
+#include "chrome/browser/ui/tab_contents/core_tab_helper.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/browser/ui/tabs/tab_strip_model_delegate.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/browser/notification_source.h"
+#include "content/public/browser/notification_types.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/web_contents.h"
+#include "extensions/buildflags/buildflags.h"
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/constants.h"
+#endif  // (ENABLE_EXTENSIONS)
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, public:
+
+FastUnloadController::FastUnloadController(Browser* browser)
+    : browser_(browser),
+      tab_needing_before_unload_ack_(NULL),
+      is_attempting_to_close_browser_(false),
+      weak_factory_(this) {
+  browser_->tab_strip_model()->AddObserver(this);
+}
+
+FastUnloadController::~FastUnloadController() {
+  browser_->tab_strip_model()->RemoveObserver(this);
+  web_contents_waiting_for_deletion_.clear();
+}
+
+bool FastUnloadController::CanCloseContents(content::WebContents* contents) {
+  // Don't try to close the tab when the whole browser is being closed, since
+  // that avoids the fast shutdown path where we just kill all the renderers.
+  return !is_attempting_to_close_browser_ ||
+      is_calling_before_unload_handlers();
+}
+
+bool FastUnloadController::ShouldRunUnloadEventsHelper(
+    content::WebContents* contents) {
+  // If |contents| is being inspected, devtools needs to intercept beforeunload
+  // events.
+  return false;
+}
+
+bool FastUnloadController::RunUnloadEventsHelper(
+    content::WebContents* contents) {
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+  // Don't run for extensions that are disabled or uninstalled; the tabs will
+  // be killed if they make any network requests, and the extension shouldn't
+  // be doing any work if it's removed.
+  GURL url = contents->GetLastCommittedURL();
+  if (url.SchemeIs(extensions::kExtensionScheme) &&
+      !extensions::ExtensionRegistry::Get(browser_->profile())
+           ->enabled_extensions()
+           .GetExtensionOrAppByURL(url)) {
+    return false;
+  }
+#endif  // (ENABLE_EXTENSIONS)
+
+  // Special case for when we quit an application. The Devtools window can
+  // close if it's beforeunload event has already fired which will happen due
+  // to the interception of it's content's beforeunload.
+
+  // If there's a devtools window attached to |contents|,
+  // we would like devtools to call its own beforeunload handlers first,
+  // and then call beforeunload handlers for |contents|.
+  // See DevToolsWindow::InterceptPageBeforeUnload for details.
+  // If the WebContents is not connected yet, then there's no unload
+  // handler we can fire even if the WebContents has an unload listener.
+  // One case where we hit this is in a tab that has an infinite loop
+  // before load.
+  if (contents->NeedToFireBeforeUnload()) {
+    // If the page has unload listeners, then we tell the renderer to fire
+    // them. Once they have fired, we'll get a message back saying whether
+    // to proceed closing the page or not, which sends us back to this method
+    // with the NeedToFireBeforeUnload bit cleared.
+    contents->DispatchBeforeUnload();
+    return true;
+  }
+  return false;
+}
+
+bool FastUnloadController::BeforeUnloadFiredForContents(
+    content::WebContents* contents,
+    bool proceed) {
+
+  if (!is_attempting_to_close_browser_) {
+    if (!proceed) {
+      contents->SetClosedByUserGesture(false);
+    } else {
+      // No more dialogs are possible, so remove the tab and finish
+      // running unload listeners asynchrounously.
+      browser_->tab_strip_model()->delegate()->CreateHistoricalTab(contents);
+      DetachWebContents(contents);
+    }
+    return proceed;
+  }
+
+  if (!proceed) {
+    CancelWindowClose();
+    contents->SetClosedByUserGesture(false);
+    return false;
+  }
+
+  if (tab_needing_before_unload_ack_ == contents) {
+    // Now that beforeunload has fired, queue the tab to fire unload.
+    tab_needing_before_unload_ack_ = NULL;
+    tabs_needing_unload_.insert(contents);
+    ProcessPendingTabs(false);
+    // We want to handle firing the unload event ourselves since we want to
+    // fire all the beforeunload events before attempting to fire the unload
+    // events should the user cancel closing the browser.
+    return false;
+  }
+
+  return true;
+}
+
+bool FastUnloadController::ShouldCloseWindow() {
+  if (HasCompletedUnloadProcessing())
+    return true;
+
+  // Special case for when we quit an application. The Devtools window can
+  // close if it's beforeunload event has already fired which will happen due
+  // to the interception of it's content's beforeunload.
+
+  // The behavior followed here varies based on the current phase of the
+  // operation and whether a batched shutdown is in progress.
+  //
+  // If there are tabs with outstanding beforeunload handlers:
+  // 1. If a batched shutdown is in progress: return false.
+  //    This is to prevent interference with batched shutdown already in
+  //    progress.
+  // 2. Otherwise: start sending beforeunload events and return false.
+  //
+  // Otherwise, If there are no tabs with outstanding beforeunload handlers:
+  // 3. If a batched shutdown is in progress: start sending unload events and
+  //    return false.
+  // 4. Otherwise: return true.
+  is_attempting_to_close_browser_ = true;
+  // Cases 1 and 4.
+  bool need_beforeunload_fired = TabsNeedBeforeUnloadFired();
+  if (need_beforeunload_fired == is_calling_before_unload_handlers())
+    return !need_beforeunload_fired;
+
+  // Cases 2 and 3.
+  on_close_confirmed_.Reset();
+  ProcessPendingTabs(false);
+  return false;
+}
+
+bool FastUnloadController::TryToCloseWindow(
+    bool skip_beforeunload,
+    const base::Callback<void(bool)>& on_close_confirmed) {
+  // The devtools browser gets its beforeunload events as the results of
+  // intercepting events from the inspected tab, so don't send them here as
+  // well.
+  if (browser_->is_devtools() || !TabsNeedBeforeUnloadFired())
+    return false;
+
+  on_close_confirmed_ = on_close_confirmed;
+  is_attempting_to_close_browser_ = true;
+  ProcessPendingTabs(skip_beforeunload);
+  return !skip_beforeunload;
+}
+
+void FastUnloadController::ResetTryToCloseWindow() {
+  if (!is_calling_before_unload_handlers())
+    return;
+  CancelWindowClose();
+}
+
+bool FastUnloadController::TabsNeedBeforeUnloadFired() {
+  if (!tabs_needing_before_unload_.empty() ||
+      tab_needing_before_unload_ack_ != NULL)
+    return true;
+
+  if (!is_calling_before_unload_handlers() && !tabs_needing_unload_.empty())
+    return false;
+
+  return !tabs_needing_before_unload_.empty();
+}
+
+bool FastUnloadController::HasCompletedUnloadProcessing() const {
+  return is_attempting_to_close_browser_ &&
+      tabs_needing_before_unload_.empty() &&
+      tab_needing_before_unload_ack_ == NULL &&
+      tabs_needing_unload_.empty() &&
+      tabs_needing_unload_ack_.empty();
+}
+
+void FastUnloadController::CancelTabNeedingBeforeUnloadAck() {
+  if (tab_needing_before_unload_ack_ != NULL) {
+    CoreTabHelper* core_tab_helper =
+        CoreTabHelper::FromWebContents(tab_needing_before_unload_ack_);
+    core_tab_helper->OnCloseCanceled();
+    tab_needing_before_unload_ack_ = NULL;
+  }
+}
+
+void FastUnloadController::CancelWindowClose() {
+  // Closing of window can be canceled from a beforeunload handler.
+  DCHECK(is_attempting_to_close_browser_);
+  tabs_needing_before_unload_.clear();
+  CancelTabNeedingBeforeUnloadAck();
+  for (WebContentsSet::iterator it = tabs_needing_unload_.begin();
+       it != tabs_needing_unload_.end(); it++) {
+    content::WebContents* contents = *it;
+
+    CoreTabHelper* core_tab_helper = CoreTabHelper::FromWebContents(contents);
+    core_tab_helper->OnCloseCanceled();
+  }
+  tabs_needing_unload_.clear();
+
+  // No need to clear tabs_needing_unload_ack_. Those tabs are already detached.
+
+  if (is_calling_before_unload_handlers()) {
+    base::Callback<void(bool)> on_close_confirmed = on_close_confirmed_;
+    on_close_confirmed_.Reset();
+    on_close_confirmed.Run(false);
+  }
+
+  is_attempting_to_close_browser_ = false;
+
+  content::NotificationService::current()->Notify(
+      chrome::NOTIFICATION_BROWSER_CLOSE_CANCELLED,
+      content::Source<Browser>(browser_),
+      content::NotificationService::NoDetails());
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, content::WebContentsDelegate implementation:
+
+bool FastUnloadController::ShouldSuppressDialogs(content::WebContents* source) {
+  return true;
+}
+
+void FastUnloadController::CloseContents(content::WebContents* source) {
+  auto it = web_contents_waiting_for_deletion_.find(source);
+  DCHECK(it != web_contents_waiting_for_deletion_.end());
+  web_contents_waiting_for_deletion_.erase(it);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, content::NotificationObserver implementation:
+
+void FastUnloadController::Observe(
+      int type,
+      const content::NotificationSource& source,
+      const content::NotificationDetails& details) {
+  DCHECK_EQ(content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED, type);
+
+  registrar_.Remove(this, content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+                    source);
+  ClearUnloadState(content::Source<content::WebContents>(source).ptr());
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, TabStripModelObserver implementation:
+
+void FastUnloadController::TabInsertedAt(TabStripModel* tab_strip_model,
+                                         content::WebContents* contents,
+                                         int index,
+                                         bool foreground) {
+  TabAttachedImpl(contents);
+}
+
+void FastUnloadController::TabDetachedAt(content::WebContents* contents,
+                                         int index,
+                                         bool was_active) {
+  TabDetachedImpl(contents);
+}
+
+void FastUnloadController::TabReplacedAt(TabStripModel* tab_strip_model,
+                                         content::WebContents* old_contents,
+                                         content::WebContents* new_contents,
+                                         int index) {
+  TabDetachedImpl(old_contents);
+  TabAttachedImpl(new_contents);
+}
+
+void FastUnloadController::TabStripEmpty() {
+  // Set is_attempting_to_close_browser_ here, so that extensions, etc, do not
+  // attempt to add tabs to the browser before it closes.
+  is_attempting_to_close_browser_ = true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// FastUnloadController, private:
+
+void FastUnloadController::TabAttachedImpl(content::WebContents* contents) {
+  // If the tab crashes in the beforeunload or unload handler, it won't be
+  // able to ack. But we know we can close it.
+  registrar_.Add(
+      this,
+      content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+      content::Source<content::WebContents>(contents));
+}
+
+void FastUnloadController::TabDetachedImpl(content::WebContents* contents) {
+  if (tabs_needing_unload_ack_.find(contents) !=
+      tabs_needing_unload_ack_.end()) {
+    // Tab needs unload to complete.
+    // It will send |NOTIFICATION_WEB_CONTENTS_DISCONNECTED| when done.
+    return;
+  }
+
+  // If WEB_CONTENTS_DISCONNECTED was received then the notification may have
+  // already been unregistered.
+  const content::NotificationSource& source =
+      content::Source<content::WebContents>(contents);
+  if (registrar_.IsRegistered(this,
+                              content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+                              source)) {
+    registrar_.Remove(this,
+                      content::NOTIFICATION_WEB_CONTENTS_DISCONNECTED,
+                      source);
+  }
+
+  if (is_attempting_to_close_browser_)
+    ClearUnloadState(contents);
+}
+
+bool FastUnloadController::DetachWebContents(content::WebContents* contents) {
+  int index = browser_->tab_strip_model()->GetIndexOfWebContents(contents);
+  if (index != TabStripModel::kNoTab &&
+      contents->NeedToFireBeforeUnload()) {
+    tabs_needing_unload_ack_.insert(contents);
+    web_contents_waiting_for_deletion_[contents] =
+        browser_->tab_strip_model()->DetachWebContentsAt(index);
+    contents->SetDelegate(this);
+    CoreTabHelper* core_tab_helper = CoreTabHelper::FromWebContents(contents);
+    core_tab_helper->OnUnloadDetachedStarted();
+    return true;
+  }
+  return false;
+}
+
+void FastUnloadController::ProcessPendingTabs(bool skip_beforeunload) {
+  if (!is_attempting_to_close_browser_) {
+    // Because we might invoke this after a delay it's possible for the value of
+    // is_attempting_to_close_browser_ to have changed since we scheduled the
+    // task.
+    return;
+  }
+
+  if (tab_needing_before_unload_ack_ != NULL) {
+    if (skip_beforeunload) {
+      // Cancel and skip the ongoing before unload event.
+      tabs_needing_before_unload_.insert(tab_needing_before_unload_ack_);
+      CancelTabNeedingBeforeUnloadAck();
+    } else {
+      // Wait for |BeforeUnloadFiredForContents| before proceeding.
+      return;
+    }
+  }
+
+  // Process a beforeunload handler.
+  if (!tabs_needing_before_unload_.empty()) {
+    if (skip_beforeunload) {
+      tabs_needing_unload_.insert(tabs_needing_before_unload_.begin(),
+                                  tabs_needing_before_unload_.end());
+      tabs_needing_before_unload_.clear();
+    } else {
+      WebContentsSet::iterator it = tabs_needing_before_unload_.begin();
+      content::WebContents* contents = *it;
+      tabs_needing_before_unload_.erase(it);
+      // Null check render_view_host here as this gets called on a PostTask and
+      // the tab's render_view_host may have been nulled out.
+      if (contents->GetRenderViewHost()) {
+        tab_needing_before_unload_ack_ = contents;
+
+        CoreTabHelper* core_tab_helper =
+            CoreTabHelper::FromWebContents(contents);
+        core_tab_helper->OnCloseStarted();
+
+        // If there's a devtools window attached to |contents|,
+        // we would like devtools to call its own beforeunload handlers first,
+        // and then call beforeunload handlers for |contents|.
+        // See DevToolsWindow::InterceptPageBeforeUnload for details.
+      } else {
+        ProcessPendingTabs(skip_beforeunload);
+      }
+      return;
+    }
+  }
+
+  if (is_calling_before_unload_handlers()) {
+    base::OnceCallback<void(bool)> on_close_confirmed = on_close_confirmed_;
+    // Reset |on_close_confirmed_| in case the callback tests
+    // |is_calling_before_unload_handlers()|, we want to return that calling
+    // is complete.
+    if (tabs_needing_unload_.empty())
+      on_close_confirmed_.Reset();
+    if (!skip_beforeunload)
+      std::move(on_close_confirmed).Run(true);
+    return;
+  }
+
+  // Process all the unload handlers. (The beforeunload handlers have finished.)
+  if (!tabs_needing_unload_.empty()) {
+    browser_->OnWindowClosing();
+
+    // Run unload handlers detached since no more interaction is possible.
+    WebContentsSet::iterator it = tabs_needing_unload_.begin();
+    while (it != tabs_needing_unload_.end()) {
+      WebContentsSet::iterator current = it++;
+      content::WebContents* contents = *current;
+      tabs_needing_unload_.erase(current);
+      // Null check render_view_host here as this gets called on a PostTask
+      // and the tab's render_view_host may have been nulled out.
+      if (contents->GetRenderViewHost()) {
+        CoreTabHelper* core_tab_helper =
+            CoreTabHelper::FromWebContents(contents);
+        core_tab_helper->OnUnloadStarted();
+        DetachWebContents(contents);
+        contents->ClosePage();
+      }
+    }
+
+    // Get the browser hidden.
+    if (browser_->tab_strip_model()->empty()) {
+      browser_->TabStripEmpty();
+    } else {
+      browser_->tab_strip_model()->CloseAllTabs();  // tabs not needing unload
+    }
+    return;
+  }
+
+  if (HasCompletedUnloadProcessing()) {
+    browser_->OnWindowClosing();
+
+    // Get the browser closed.
+    if (browser_->tab_strip_model()->empty()) {
+      browser_->TabStripEmpty();
+    } else {
+      // There may be tabs if the last tab needing beforeunload crashed.
+      browser_->tab_strip_model()->CloseAllTabs();
+    }
+    return;
+  }
+}
+
+void FastUnloadController::ClearUnloadState(content::WebContents* contents) {
+  if (tabs_needing_unload_ack_.erase(contents) > 0) {
+    if (HasCompletedUnloadProcessing())
+      PostTaskForProcessPendingTabs();
+    return;
+  }
+
+  if (!is_attempting_to_close_browser_)
+    return;
+
+  if (tab_needing_before_unload_ack_ == contents) {
+    tab_needing_before_unload_ack_ = NULL;
+    PostTaskForProcessPendingTabs();
+    return;
+  }
+
+  if (tabs_needing_before_unload_.erase(contents) > 0 ||
+      tabs_needing_unload_.erase(contents) > 0) {
+    if (tab_needing_before_unload_ack_ == NULL)
+      PostTaskForProcessPendingTabs();
+  }
+}
+
+void FastUnloadController::PostTaskForProcessPendingTabs() {
+  base::ThreadTaskRunnerHandle::Get()->PostTask(
+      FROM_HERE, base::BindOnce(&FastUnloadController::ProcessPendingTabs,
+                                weak_factory_.GetWeakPtr(), false));
+}
diff --git a/chrome/browser/ui/native_window_tracker_android.cc b/chrome/browser/ui/native_window_tracker_android.cc
new file mode 100644
index 000000000000..53bf4cc03b65
--- /dev/null
+++ b/chrome/browser/ui/native_window_tracker_android.cc
@@ -0,0 +1,26 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/native_window_tracker_android.h"
+
+#include "ui/android/window_android.h"
+
+NativeWindowTrackerAndroid::NativeWindowTrackerAndroid(
+    gfx::NativeWindow window)
+    : window_(window) {
+}
+
+NativeWindowTrackerAndroid::~NativeWindowTrackerAndroid() {
+}
+
+bool NativeWindowTrackerAndroid::WasNativeWindowClosed() const {
+  return window_ == nullptr;
+}
+
+// static
+std::unique_ptr<NativeWindowTracker> NativeWindowTracker::Create(
+    gfx::NativeWindow window) {
+  return std::unique_ptr<NativeWindowTracker>(
+      new NativeWindowTrackerAndroid(window));
+}
diff --git a/chrome/browser/ui/native_window_tracker_android.h b/chrome/browser/ui/native_window_tracker_android.h
new file mode 100644
index 000000000000..6f472b86e736
--- /dev/null
+++ b/chrome/browser/ui/native_window_tracker_android.h
@@ -0,0 +1,26 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
+#define CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
+
+#include "base/macros.h"
+#include "chrome/browser/ui/native_window_tracker.h"
+#include "ui/android/window_android.h"
+
+class NativeWindowTrackerAndroid : public NativeWindowTracker {
+ public:
+  explicit NativeWindowTrackerAndroid(gfx::NativeWindow window);
+  ~NativeWindowTrackerAndroid() override;
+
+  bool WasNativeWindowClosed() const override;
+
+ private:
+
+  gfx::NativeWindow window_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowTrackerAndroid);
+};
+
+#endif  // CHROME_BROWSER_UI_AURA_NATIVE_WINDOW_TRACKER_AURA_H_
diff --git a/chrome/browser/ui/page_info/page_info_ui.cc b/chrome/browser/ui/page_info/page_info_ui.cc
index 99b7d6745b86..ad8cdb233f53 100644
--- a/chrome/browser/ui/page_info/page_info_ui.cc
+++ b/chrome/browser/ui/page_info/page_info_ui.cc
@@ -31,7 +31,7 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/android_theme_resources.h"
-#else
+
 #include "chrome/app/vector_icons/vector_icons.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/common/pref_names.h"
@@ -50,7 +50,7 @@ namespace {
 
 const int kInvalidResourceID = -1;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // The icon size is actually 16, but the vector icons being used generally all
 // have additional internal padding. Account for this difference by asking for
 // the vectors in 18x18dip sizes.
@@ -110,7 +110,7 @@ static_assert(base::size(kPermissionButtonTextIDDefaultSetting) ==
                   CONTENT_SETTING_NUM_SETTINGS,
               "kPermissionButtonTextIDDefaultSetting array size is incorrect");
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // The resource IDs for the strings that are displayed on the sound permission
 // button if the sound permission setting is managed by the user.
 const int kSoundPermissionButtonTextIDUserManaged[] = {
@@ -176,7 +176,7 @@ base::span<const PermissionsUIInfo> GetContentSettingsUIInfo() {
          ? IDS_PAGE_INFO_TYPE_SENSORS
          : IDS_PAGE_INFO_TYPE_MOTION_SENSORS},
     {ContentSettingsType::USB_GUARD, IDS_PAGE_INFO_TYPE_USB},
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     {ContentSettingsType::SERIAL_GUARD, IDS_PAGE_INFO_TYPE_SERIAL},
 #endif
     {ContentSettingsType::NATIVE_FILE_SYSTEM_WRITE_GUARD,
@@ -552,7 +552,7 @@ int PageInfoUI::GetConnectionIconID(PageInfo::SiteConnectionStatus status) {
   }
   return resource_id;
 }
-#else  // !defined(OS_ANDROID)
+
 // static
 const gfx::ImageSkia PageInfoUI::GetPermissionIcon(const PermissionInfo& info,
                                                    SkColor related_text_color) {
diff --git a/chrome/browser/ui/page_info/page_info_ui.h b/chrome/browser/ui/page_info/page_info_ui.h
index 90619d7736dc..183d62110adc 100644
--- a/chrome/browser/ui/page_info/page_info_ui.h
+++ b/chrome/browser/ui/page_info/page_info_ui.h
@@ -18,7 +18,7 @@
 #include "components/safe_browsing/buildflags.h"
 #include "ui/gfx/native_widget_types.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "ui/gfx/image/image_skia.h"
 #endif
 
@@ -204,7 +204,7 @@ class PageInfoUI {
 
   // Returns the connection icon ID for the given connection |status|.
   static int GetConnectionIconID(PageInfo::SiteConnectionStatus status);
-#else  // !defined(OS_ANDROID)
+
   // Returns icons for the given PermissionInfo |info|. If |info|'s current
   // setting is CONTENT_SETTING_DEFAULT, it will return the icon for |info|'s
   // default setting.
diff --git a/chrome/browser/ui/passwords/settings/password_manager_presenter.cc b/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
index 3fcc92f5c0dd..265ba5bfe1b9 100644
--- a/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
+++ b/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
@@ -44,7 +44,7 @@
 #include "components/undo/undo_operation.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "chrome/browser/extensions/api/passwords_private/passwords_private_utils.h"
 #endif
 
@@ -339,7 +339,7 @@ void PasswordManagerPresenter::UndoRemoveSavedPasswordOrException() {
   undo_manager_.Undo();
 }
 
-#if !defined(OS_ANDROID)  // This is never called on Android.
+#if true || !defined(OS_ANDROID)  // This is never called on Android.
 void PasswordManagerPresenter::RequestShowPassword(
     const std::string& sort_key,
     base::OnceCallback<void(base::Optional<base::string16>)> callback) const {
diff --git a/chrome/browser/ui/screen_capture_notification_ui_stub.cc b/chrome/browser/ui/screen_capture_notification_ui_stub.cc
index ec35cb8a5495..9496c8da1fdf 100644
--- a/chrome/browser/ui/screen_capture_notification_ui_stub.cc
+++ b/chrome/browser/ui/screen_capture_notification_ui_stub.cc
@@ -20,8 +20,10 @@ class ScreenCaptureNotificationUIStub : public ScreenCaptureNotificationUI {
 };
 
 // static
+#if 0
 std::unique_ptr<ScreenCaptureNotificationUI>
 ScreenCaptureNotificationUI::Create(const base::string16& title) {
   return std::unique_ptr<ScreenCaptureNotificationUI>(
       new ScreenCaptureNotificationUIStub());
 }
+#endif
diff --git a/chrome/browser/ui/search/instant_controller.h b/chrome/browser/ui/search/instant_controller.h
index aabfb16b471f..2ddd79ecd51e 100644
--- a/chrome/browser/ui/search/instant_controller.h
+++ b/chrome/browser/ui/search/instant_controller.h
@@ -12,10 +12,6 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/tabs/tab_strip_model_observer.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class Profile;
 class TabStripModel;
 
diff --git a/chrome/browser/ui/search/ntp_user_data_logger.h b/chrome/browser/ui/search/ntp_user_data_logger.h
index a61a8d44e33b..401c6e4eea3c 100644
--- a/chrome/browser/ui/search/ntp_user_data_logger.h
+++ b/chrome/browser/ui/search/ntp_user_data_logger.h
@@ -21,10 +21,6 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 namespace content {
 class WebContents;
 }
diff --git a/chrome/browser/ui/search/search_ipc_router.h b/chrome/browser/ui/search/search_ipc_router.h
index 7e52d7ed777e..76931eb8d43d 100644
--- a/chrome/browser/ui/search/search_ipc_router.h
+++ b/chrome/browser/ui/search/search_ipc_router.h
@@ -21,10 +21,6 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "mojo/public/cpp/bindings/associated_receiver.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 class GURL;
 
 namespace content {
diff --git a/chrome/browser/ui/search/search_ipc_router_policy_impl.h b/chrome/browser/ui/search/search_ipc_router_policy_impl.h
index 286ddedb454f..19b95b52f927 100644
--- a/chrome/browser/ui/search/search_ipc_router_policy_impl.h
+++ b/chrome/browser/ui/search/search_ipc_router_policy_impl.h
@@ -9,10 +9,6 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/search/search_ipc_router.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 namespace content {
 class WebContents;
 }
diff --git a/chrome/browser/ui/search/search_tab_helper.h b/chrome/browser/ui/search/search_tab_helper.h
index b1c4f5242ecb..dcdf914b24d4 100644
--- a/chrome/browser/ui/search/search_tab_helper.h
+++ b/chrome/browser/ui/search/search_tab_helper.h
@@ -28,10 +28,6 @@
 #include "content/public/browser/web_contents_user_data.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
-#if defined(OS_ANDROID)
-#error "Instant is only used on desktop";
-#endif
-
 namespace content {
 class WebContents;
 struct LoadCommittedDetails;
diff --git a/chrome/browser/ui/signin_view_controller.h b/chrome/browser/ui/signin_view_controller.h
index f0ea2007c7de..1efd17a759f1 100644
--- a/chrome/browser/ui/signin_view_controller.h
+++ b/chrome/browser/ui/signin_view_controller.h
@@ -13,9 +13,11 @@
 #include "components/signin/public/base/signin_buildflags.h"
 #include "url/gurl.h"
 
+#if 0
 #if defined(OS_ANDROID)
 #error This file should only be included on desktop.
 #endif
+#endif
 
 class Browser;
 class SigninViewControllerDelegate;
diff --git a/chrome/browser/ui/tab_helpers.cc b/chrome/browser/ui/tab_helpers.cc
index 0d9d59805199..b488b422816b 100644
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -350,8 +350,10 @@ void TabHelpers::AttachTabHelpers(WebContents* web_contents) {
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::TabHelper::CreateForWebContents(web_contents);
+#if 0
   if (web_app::AreWebAppsEnabled(profile))
     web_app::WebAppTabHelper::CreateForWebContents(web_contents);
+#endif
   if (SiteEngagementService::IsEnabled())
     web_app::WebAppMetrics::Get(profile);
 #endif
diff --git a/chrome/browser/ui/tabs/tab_strip_model.cc b/chrome/browser/ui/tabs/tab_strip_model.cc
index 13143a53a18f..e27fd000f84c 100644
--- a/chrome/browser/ui/tabs/tab_strip_model.cc
+++ b/chrome/browser/ui/tabs/tab_strip_model.cc
@@ -972,11 +972,15 @@ void TabStripModel::CloseSelectedTabs() {
 }
 
 void TabStripModel::SelectNextTab(UserGestureDetails detail) {
+#if 0
   SelectRelativeTab(true, detail);
+#endif
 }
 
 void TabStripModel::SelectPreviousTab(UserGestureDetails detail) {
+#if 0
   SelectRelativeTab(false, detail);
+#endif
 }
 
 void TabStripModel::SelectLastTab(UserGestureDetails detail) {
diff --git a/chrome/browser/ui/tabs/tab_strip_model.h b/chrome/browser/ui/tabs/tab_strip_model.h
index f7282146e44d..92ba717b1f92 100644
--- a/chrome/browser/ui/tabs/tab_strip_model.h
+++ b/chrome/browser/ui/tabs/tab_strip_model.h
@@ -31,10 +31,6 @@
 #include "ui/base/models/list_selection_model.h"
 #include "ui/base/page_transition_types.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Profile;
 class TabGroupModel;
 class TabStripModelDelegate;
diff --git a/chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc b/chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc
new file mode 100644
index 000000000000..1cbc2ce23f9b
--- /dev/null
+++ b/chrome/browser/ui/toolbar/component_toolbar_actions_factory.cc
@@ -0,0 +1,59 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/toolbar/component_toolbar_actions_factory.h"
+
+#include "base/command_line.h"
+#include "base/lazy_instance.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/media/router/media_router_feature.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/toolbar/media_router_action.h"
+#include "chrome/browser/ui/toolbar/media_router_action_controller.h"
+#include "chrome/browser/ui/toolbar/toolbar_action_view_controller.h"
+#include "chrome/browser/ui/toolbar/toolbar_actions_bar.h"
+#include "extensions/browser/extension_registry.h"
+
+// static
+const char ComponentToolbarActionsFactory::kMediaRouterActionId[] =
+    "media_router_action";
+
+ComponentToolbarActionsFactory::ComponentToolbarActionsFactory(
+    Profile* profile) {
+}
+
+ComponentToolbarActionsFactory::~ComponentToolbarActionsFactory() {}
+
+std::set<std::string> ComponentToolbarActionsFactory::GetInitialComponentIds() {
+  // TODO(takumif): Instead of keeping track of |initial_ids_|, simplify by
+  // checking here whether MediaRouterAction should be visible.
+  return initial_ids_;
+}
+
+void ComponentToolbarActionsFactory::OnAddComponentActionBeforeInit(
+    const std::string& action_id) {
+  initial_ids_.insert(action_id);
+}
+
+void ComponentToolbarActionsFactory::OnRemoveComponentActionBeforeInit(
+    const std::string& action_id) {
+  initial_ids_.erase(action_id);
+}
+
+std::unique_ptr<ToolbarActionViewController>
+ComponentToolbarActionsFactory::GetComponentToolbarActionForId(
+    const std::string& action_id,
+    Browser* browser,
+    ToolbarActionsBar* bar) {
+  // Add component toolbar actions here.
+  // This current design means that the ComponentToolbarActionsFactory is aware
+  // of all actions. Since we should *not* have an excessive amount of these
+  // (since each will have an action in the toolbar or overflow menu), this
+  // should be okay. If this changes, we should rethink this design to have,
+  // e.g., RegisterChromeAction().
+
+  NOTREACHED();
+  return std::unique_ptr<ToolbarActionViewController>();
+}
diff --git a/chrome/browser/ui/unload_controller.cc b/chrome/browser/ui/unload_controller.cc
index 0f394a918479..7f0568f3612c 100644
--- a/chrome/browser/ui/unload_controller.cc
+++ b/chrome/browser/ui/unload_controller.cc
@@ -50,7 +50,7 @@ bool UnloadController::ShouldRunUnloadEventsHelper(
     content::WebContents* contents) {
   // If |contents| is being inspected, devtools needs to intercept beforeunload
   // events.
-  return DevToolsWindow::GetInstanceForInspectedWebContents(contents) != NULL;
+  return false;
 }
 
 bool UnloadController::RunUnloadEventsHelper(content::WebContents* contents) {
@@ -67,20 +67,6 @@ bool UnloadController::RunUnloadEventsHelper(content::WebContents* contents) {
   }
 #endif  // (ENABLE_EXTENSIONS)
 
-  // Special case for when we quit an application. The devtools window can
-  // close if it's beforeunload event has already fired which will happen due
-  // to the interception of it's content's beforeunload.
-  if (browser_->is_type_devtools() &&
-      DevToolsWindow::HasFiredBeforeUnloadEventForDevToolsBrowser(browser_))
-    return false;
-
-  // If there's a devtools window attached to |contents|,
-  // we would like devtools to call its own beforeunload handlers first,
-  // and then call beforeunload handlers for |contents|.
-  // See DevToolsWindow::InterceptPageBeforeUnload for details.
-  if (DevToolsWindow::InterceptPageBeforeUnload(contents)) {
-    return true;
-  }
   // If the WebContents is not connected yet, then there's no unload
   // handler we can fire even if the WebContents has an unload listener.
   // One case where we hit this is in a tab that has an infinite loop
@@ -98,9 +84,6 @@ bool UnloadController::RunUnloadEventsHelper(content::WebContents* contents) {
 
 bool UnloadController::BeforeUnloadFired(content::WebContents* contents,
                                          bool proceed) {
-  if (!proceed)
-    DevToolsWindow::OnPageCloseCanceled(contents);
-
   if (!is_attempting_to_close_browser_) {
     if (!proceed)
       contents->SetClosedByUserGesture(false);
@@ -131,14 +114,6 @@ bool UnloadController::ShouldCloseWindow() {
   if (HasCompletedUnloadProcessing())
     return true;
 
-  // Special case for when we quit an application. The devtools window can
-  // close if it's beforeunload event has already fired which will happen due
-  // to the interception of it's content's beforeunload.
-  if (browser_->is_type_devtools() &&
-      DevToolsWindow::HasFiredBeforeUnloadEventForDevToolsBrowser(browser_)) {
-    return true;
-  }
-
   // The behavior followed here varies based on the current phase of the
   // operation and whether a batched shutdown is in progress.
   //
@@ -188,6 +163,7 @@ void UnloadController::ResetTryToCloseWindow() {
 }
 
 bool UnloadController::TabsNeedBeforeUnloadFired() {
+#if 0
   if (tabs_needing_before_unload_fired_.empty()) {
     for (int i = 0; i < browser_->tab_strip_model()->count(); ++i) {
       content::WebContents* contents =
@@ -201,6 +177,7 @@ bool UnloadController::TabsNeedBeforeUnloadFired() {
       }
     }
   }
+#endif
   return !tabs_needing_before_unload_fired_.empty();
 }
 
@@ -210,10 +187,6 @@ void UnloadController::CancelWindowClose() {
   // case some of this code might not have an effect, but it's still useful to,
   // for example, call the notification(s).
   tabs_needing_before_unload_fired_.clear();
-  for (auto it = tabs_needing_unload_fired_.begin();
-       it != tabs_needing_unload_fired_.end(); ++it) {
-    DevToolsWindow::OnPageCloseCanceled(*it);
-  }
   tabs_needing_unload_fired_.clear();
   if (is_calling_before_unload_handlers()) {
     base::Callback<void(bool)> on_close_confirmed = on_close_confirmed_;
@@ -328,8 +301,6 @@ void UnloadController::ProcessPendingTabs(bool skip_beforeunload) {
       // we would like devtools to call its own beforeunload handlers first,
       // and then call beforeunload handlers for |web_contents|.
       // See DevToolsWindow::InterceptPageBeforeUnload for details.
-      if (!DevToolsWindow::InterceptPageBeforeUnload(web_contents))
-        web_contents->DispatchBeforeUnload(false /* auto_cancel */);
     } else {
       ClearUnloadState(web_contents, true);
     }
diff --git a/chrome/browser/ui/views/BUILD.gn b/chrome/browser/ui/views/BUILD.gn
index 0241896ec54b..9005f7be2b1d 100644
--- a/chrome/browser/ui/views/BUILD.gn
+++ b/chrome/browser/ui/views/BUILD.gn
@@ -5,8 +5,6 @@
 import("//build/config/ui.gni")
 import("//ui/views/features.gni")
 
-assert(toolkit_views)
-
 component("views") {
   output_name = "browser_ui_views"
   sources = [
diff --git a/chrome/browser/ui/views/accelerator_utils_android.cc b/chrome/browser/ui/views/accelerator_utils_android.cc
new file mode 100644
index 000000000000..534e7c9dec47
--- /dev/null
+++ b/chrome/browser/ui/views/accelerator_utils_android.cc
@@ -0,0 +1,30 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+
+#include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/views/accelerator_table.h"
+#include "ui/base/accelerators/accelerator.h"
+
+#if defined(OS_CHROMEOS)
+#include "ash/public/cpp/accelerators.h"
+#endif
+
+namespace chrome {
+
+bool IsChromeAccelerator(const ui::Accelerator& accelerator, Profile* profile) {
+  return false;
+}
+
+ui::Accelerator GetPrimaryChromeAcceleratorForBookmarkPage() {
+  return ui::Accelerator();
+}
+
+ui::Accelerator GetPrimaryChromeAcceleratorForBookmarkTab() {
+  return ui::Accelerator();
+}
+
+}  // namespace chrome
diff --git a/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc b/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc
index 703e4565b62c..22f79d6d0a8e 100644
--- a/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc
+++ b/chrome/browser/ui/views/autofill/autofill_popup_view_native_views.cc
@@ -378,7 +378,9 @@ void AutofillPopupItemView::OnMouseReleased(const ui::MouseEvent& event) {
 }
 
 void AutofillPopupItemView::CreateContent() {
+#if 0
   AutofillPopupController* controller = popup_view()->controller();
+#endif
 
   auto* layout_manager = SetLayoutManager(std::make_unique<views::BoxLayout>(
       views::BoxLayout::Orientation::kHorizontal,
@@ -387,8 +389,7 @@ void AutofillPopupItemView::CreateContent() {
   layout_manager->set_cross_axis_alignment(
       views::BoxLayout::CrossAxisAlignment::kCenter);
 
-  const gfx::ImageSkia icon =
-      controller->layout_model().GetIconImage(line_number());
+  const gfx::ImageSkia icon = gfx::ImageSkia();
 
   if (!icon.isNull()) {
     AddIcon(icon);
@@ -624,7 +625,9 @@ void AutofillPopupFooterView::CreateContent() {
       /*right=*/0,
       /*color=*/popup_view()->GetSeparatorColor()));
 
+#if 0
   AutofillPopupController* controller = popup_view()->controller();
+#endif
 
   views::BoxLayout* layout_manager =
       SetLayoutManager(std::make_unique<views::BoxLayout>(
@@ -634,8 +637,7 @@ void AutofillPopupFooterView::CreateContent() {
   layout_manager->set_cross_axis_alignment(
       views::BoxLayout::CrossAxisAlignment::kStretch);
 
-  const gfx::ImageSkia icon =
-      controller->layout_model().GetIconImage(line_number());
+  const gfx::ImageSkia icon = gfx::ImageSkia();
 
   // A FooterView shows an icon, if any, on the trailing (right in LTR) side,
   // but the Show Account Cards context is an anomaly. Its icon is on the
diff --git a/chrome/browser/ui/views/browser_dialogs_views.cc b/chrome/browser/ui/views/browser_dialogs_views.cc
index e2943e51ac96..83a90a262853 100644
--- a/chrome/browser/ui/views/browser_dialogs_views.cc
+++ b/chrome/browser/ui/views/browser_dialogs_views.cc
@@ -15,17 +15,6 @@
 #include "chrome/browser/ui/views/bookmarks/bookmark_editor_view.h"
 #include "chrome/browser/ui/views/task_manager_view.h"
 
-// This file provides definitions of desktop browser dialog-creation methods for
-// all toolkit-views platforms.
-// static
-std::unique_ptr<LoginHandler> LoginHandler::Create(
-    const net::AuthChallengeInfo& auth_info,
-    content::WebContents* web_contents,
-    LoginAuthRequiredCallback auth_required_callback) {
-  return chrome::CreateLoginHandlerViews(auth_info, web_contents,
-                                         std::move(auth_required_callback));
-}
-
 // static
 void BookmarkEditor::Show(gfx::NativeWindow parent_window,
                           Profile* profile,
diff --git a/chrome/browser/ui/views/chrome_views_delegate_android.cc b/chrome/browser/ui/views/chrome_views_delegate_android.cc
new file mode 100644
index 000000000000..1321275ee1cd
--- /dev/null
+++ b/chrome/browser/ui/views/chrome_views_delegate_android.cc
@@ -0,0 +1,15 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/chrome_views_delegate.h"
+
+#include "base/feature_list.h"
+#include "chrome/common/chrome_features.h"
+
+views::NativeWidget* ChromeViewsDelegate::CreateNativeWidget(
+    views::Widget::InitParams* params,
+    views::internal::NativeWidgetDelegate* delegate) {
+  // By returning null Widget creates the default NativeWidget implementation.
+  return nullptr;
+}
diff --git a/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc b/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
index 303a9fa508f4..5e585b890730 100644
--- a/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
+++ b/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
@@ -170,7 +170,7 @@ void DesktopMediaListView::OnSourceAdded(size_t index) {
   source_view->SetName(source.name);
   source_view->SetGroup(kDesktopMediaSourceViewGroupId);
   if (source.id.type == DesktopMediaID::TYPE_WINDOW) {
-    gfx::ImageSkia icon_image = GetWindowIcon(source.id);
+    gfx::ImageSkia icon_image = gfx::ImageSkia();
 #if defined(OS_CHROMEOS)
     // Empty icons are used to represent default icon for aura windows. By
     // detecting this, we load the default icon from resource.
diff --git a/chrome/browser/ui/views/download/download_item_view.cc b/chrome/browser/ui/views/download/download_item_view.cc
index 0d89919158aa..42c2579138b9 100644
--- a/chrome/browser/ui/views/download/download_item_view.cc
+++ b/chrome/browser/ui/views/download/download_item_view.cc
@@ -1445,7 +1445,9 @@ base::string16 DownloadItemView::ElidedFilename() {
 }
 
 void DownloadItemView::OpenDownloadDuringAsyncScanning() {
+#if 0
   model_->CompleteSafeBrowsingScan();
+#endif
   should_open_while_scanning_ = true;
 }
 
diff --git a/chrome/browser/ui/views/dropdown_bar_host_android.cc b/chrome/browser/ui/views/dropdown_bar_host_android.cc
new file mode 100644
index 000000000000..5e918e7e6dae
--- /dev/null
+++ b/chrome/browser/ui/views/dropdown_bar_host_android.cc
@@ -0,0 +1,10 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/dropdown_bar_host.h"
+
+#include "ui/views/widget/widget.h"
+
+void DropdownBarHost::SetHostViewNative(views::View* host_view) {
+}
diff --git a/chrome/browser/ui/views/find_bar_host.cc b/chrome/browser/ui/views/find_bar_host.cc
index e316230ab965..eba3fa4d0c19 100644
--- a/chrome/browser/ui/views/find_bar_host.cc
+++ b/chrome/browser/ui/views/find_bar_host.cc
@@ -67,10 +67,6 @@ bool FindBarHost::MaybeForwardKeyEventToWebpage(
   // Make sure we don't have a text field element interfering with keyboard
   // input. Otherwise Up and Down arrow key strokes get eaten. "Nom Nom Nom".
   contents->ClearFocusedElement();
-  NativeWebKeyboardEvent event(key_event);
-  contents->GetRenderViewHost()
-      ->GetWidget()
-      ->ForwardKeyboardEventWithLatencyInfo(event, *key_event.latency());
   return true;
 }
 
diff --git a/chrome/browser/ui/views/frame/browser_frame.cc b/chrome/browser/ui/views/frame/browser_frame.cc
index 0d7f5b0320d9..a4dbec8a0685 100644
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -32,6 +32,7 @@
 #include "ui/events/event_handler.h"
 #include "ui/gfx/font_list.h"
 #include "ui/native_theme/native_theme_dark_aura.h"
+#include "ui/native_theme/native_theme_android.h"
 #include "ui/views/controls/menu/menu_runner.h"
 #include "ui/views/widget/native_widget.h"
 
diff --git a/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc b/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
index e7812b668701..11dcb80dd51e 100644
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
@@ -61,7 +61,6 @@ BrowserNonClientFrameView* CreateBrowserNonClientFrameView(
 #endif
   OpaqueBrowserFrameView* view =
       CreateOpaqueBrowserFrameView(frame, browser_view);
-  view->InitViews();
   return view;
 }
 
diff --git a/chrome/browser/ui/views/frame/browser_root_view.cc b/chrome/browser/ui/views/frame/browser_root_view.cc
index 000ce05d8712..831e5039f629 100644
--- a/chrome/browser/ui/views/frame/browser_root_view.cc
+++ b/chrome/browser/ui/views/frame/browser_root_view.cc
@@ -67,10 +67,14 @@ void OnFindURLMimeType(const GURL& url,
   // to do disk access.
   content::WebPluginInfo plugin;
   std::move(callback).Run(
-      url, mime_type.empty() || blink::IsSupportedMimeType(mime_type) ||
+      url, mime_type.empty() || blink::IsSupportedMimeType(mime_type)
+#if 0
+ ||
                content::PluginService::GetInstance()->GetPluginInfo(
                    process_id, routing_id, url, url::Origin(), mime_type, false,
-                   nullptr, &plugin, nullptr));
+                   nullptr, &plugin, nullptr)
+#endif
+);
 }
 
 bool GetURLForDrop(const ui::DropTargetEvent& event, GURL* url) {
diff --git a/chrome/browser/ui/views/frame/browser_view.cc b/chrome/browser/ui/views/frame/browser_view.cc
index c4b714aaf52f..e59904a292a1 100644
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -851,6 +851,7 @@ void BrowserView::OnActiveTabChanged(content::WebContents* old_contents,
                                      content::WebContents* new_contents,
                                      int index,
                                      int reason) {
+#if 0
   DCHECK(new_contents);
   TRACE_EVENT0("ui", "BrowserView::OnActiveTabChanged");
 
@@ -955,10 +956,12 @@ void BrowserView::OnActiveTabChanged(content::WebContents* old_contents,
   UpdateTitleBar();
 
   TranslateBubbleView::CloseCurrentBubble();
+#endif
 }
 
 void BrowserView::OnTabDetached(content::WebContents* contents,
                                 bool was_active) {
+#if 0
   if (was_active) {
     // We need to reset the current tab contents to null before it gets
     // freed. This is because the focus manager performs some operations
@@ -969,6 +972,7 @@ void BrowserView::OnTabDetached(content::WebContents* contents,
     app_banner_manager_observer_.RemoveAll();
     UpdateDevToolsForContents(nullptr, true);
   }
+#endif
 }
 
 void BrowserView::OnTabRestored(int command_id) {
@@ -1098,11 +1102,14 @@ void BrowserView::OnExclusiveAccessUserInput() {
 }
 
 bool BrowserView::ShouldHideUIForFullscreen() const {
+#if 0
   // Immersive mode needs UI for the slide-down top panel.
   if (immersive_mode_controller_->IsEnabled())
+#endif
     return false;
-
+#if 0
   return frame_->GetFrameView()->ShouldHideTopUIForFullscreen();
+#endif
 }
 
 bool BrowserView::IsFullscreen() const {
@@ -1178,28 +1185,36 @@ void BrowserView::SetFocusToLocationBar(bool select_all) {
 }
 
 void BrowserView::UpdateReloadStopState(bool is_loading, bool force) {
+#if 0
   if (toolbar_button_provider_->GetReloadButton()) {
     toolbar_button_provider_->GetReloadButton()->ChangeMode(
         is_loading ? ReloadButton::Mode::kStop : ReloadButton::Mode::kReload,
         force);
   }
+#endif
 }
 
 void BrowserView::UpdateToolbar(content::WebContents* contents) {
+#if 0
   // We may end up here during destruction.
   if (toolbar_)
     toolbar_->Update(contents);
+#endif
 }
 
 void BrowserView::UpdateCustomTabBarVisibility(bool visible, bool animate) {
+#if 0
   if (toolbar_)
     toolbar_->UpdateCustomTabBarVisibility(visible, animate);
+#endif
 }
 
 void BrowserView::ResetToolbarTabState(content::WebContents* contents) {
+#if 0
   // We may end up here during destruction.
   if (toolbar_)
     toolbar_->ResetTabState(contents);
+#endif
 }
 
 void BrowserView::FocusToolbar() {
@@ -1225,8 +1240,10 @@ ToolbarActionsBar* BrowserView::GetToolbarActionsBar() {
 }
 
 ExtensionsContainer* BrowserView::GetExtensionsContainer() {
+#if 0
   if (toolbar_ && toolbar_->extensions_container())
     return toolbar_->extensions_container();
+#endif
   return GetToolbarActionsBar();
 }
 
@@ -1281,6 +1298,7 @@ void BrowserView::FocusBookmarksToolbar() {
 }
 
 void BrowserView::FocusInactivePopupForAccessibility() {
+#if 0
   if (GetLocationBarView()->ActivateFirstInactiveBubbleForAccessibility())
     return;
 
@@ -1293,6 +1311,7 @@ void BrowserView::FocusInactivePopupForAccessibility() {
 
   if (!infobar_container_->children().empty())
     infobar_container_->SetPaneFocusAndFocusDefault();
+#endif
 }
 
 void BrowserView::FocusAppMenu() {
diff --git a/chrome/browser/ui/views/frame/browser_window_factory.cc b/chrome/browser/ui/views/frame/browser_window_factory.cc
index 8d53cc96cced..7cbee4f26480 100644
--- a/chrome/browser/ui/views/frame/browser_window_factory.cc
+++ b/chrome/browser/ui/views/frame/browser_window_factory.cc
@@ -20,18 +20,8 @@
 BrowserWindow* BrowserWindow::CreateBrowserWindow(
     std::unique_ptr<Browser> browser,
     bool user_gesture) {
-  // Create the view and the frame. The frame will attach itself via the view
-  // so we don't need to do anything with the pointer.
   BrowserView* view = new BrowserView(std::move(browser));
   (new BrowserFrame(view))->InitBrowserFrame();
-  view->GetWidget()->non_client_view()->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_PRODUCT_NAME));
 
-#if defined(USE_AURA)
-  // For now, all browser windows are true. This only works when USE_AURA
-  // because it requires gfx::NativeWindow to be an aura::Window*.
-  view->GetWidget()->GetNativeWindow()->SetProperty(
-      aura::client::kCreatedByUserGesture, user_gesture);
-#endif
   return view;
 }
diff --git a/chrome/browser/ui/views/frame/desktop_browser_frame_android.cc b/chrome/browser/ui/views/frame/desktop_browser_frame_android.cc
new file mode 100644
index 000000000000..6ac899f85811
--- /dev/null
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_android.cc
@@ -0,0 +1,75 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/desktop_browser_frame_android.h"
+
+#include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/ui/views/frame/browser_desktop_window_tree_host.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "ui/base/hit_test.h"
+#include "ui/base/models/simple_menu_model.h"
+#include "ui/gfx/font.h"
+#include "ui/views/view.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/visibility_controller.h"
+
+using aura::Window;
+
+///////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAura, public:
+
+DesktopBrowserFrameAndroid::DesktopBrowserFrameAndroid(
+    BrowserFrame* browser_frame,
+    BrowserView* browser_view)
+    : browser_view_(browser_view),
+      browser_frame_(browser_frame) {
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid, protected:
+
+DesktopBrowserFrameAndroid::~DesktopBrowserFrameAndroid() {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid, NativeBrowserFrame implementation:
+
+views::Widget::InitParams DesktopBrowserFrameAndroid::GetWidgetParams() {
+  views::Widget::InitParams params;
+  return params;
+}
+
+bool DesktopBrowserFrameAndroid::UseCustomFrame() const {
+  return true;
+}
+
+bool DesktopBrowserFrameAndroid::UsesNativeSystemMenu() const {
+  return true;
+}
+
+int DesktopBrowserFrameAndroid::GetMinimizeButtonOffset() const {
+  return 0;
+}
+
+bool DesktopBrowserFrameAndroid::ShouldSaveWindowPlacement() const {
+  // The placement can always be stored.
+  return true;
+}
+
+void DesktopBrowserFrameAndroid::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+  *show_state = ui::SHOW_STATE_NORMAL;
+}
+
+content::KeyboardEventProcessingResult
+DesktopBrowserFrameAndroid::PreHandleKeyboardEvent(
+    const content::NativeWebKeyboardEvent& event) {
+  return content::KeyboardEventProcessingResult::NOT_HANDLED;
+}
+
+bool DesktopBrowserFrameAndroid::HandleKeyboardEvent(
+    const content::NativeWebKeyboardEvent& event) {
+  return false;
+}
diff --git a/chrome/browser/ui/views/frame/desktop_browser_frame_android.h b/chrome/browser/ui/views/frame/desktop_browser_frame_android.h
new file mode 100644
index 000000000000..13391d720c91
--- /dev/null
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_android.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
+#define CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
+
+#include <memory>
+
+#include "base/macros.h"
+#include "chrome/browser/ui/views/frame/native_browser_frame.h"
+#include "ui/views/context_menu_controller.h"
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+
+class BrowserDesktopWindowTreeHost;
+class BrowserFrame;
+class BrowserView;
+
+namespace wm {
+class VisibilityController;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopBrowserFrameAndroid
+//
+//  DesktopBrowserFrameAndroid is a DesktopNativeWidgetAndroid subclass that provides
+//  the window frame for the Chrome browser window.
+//
+class DesktopBrowserFrameAndroid : public NativeBrowserFrame {
+ public:
+  DesktopBrowserFrameAndroid(BrowserFrame* browser_frame,
+                          BrowserView* browser_view);
+
+  BrowserView* browser_view() const { return browser_view_; }
+  BrowserFrame* browser_frame() const { return browser_frame_; }
+
+ protected:
+  ~DesktopBrowserFrameAndroid() override;
+
+  // Overridden from NativeBrowserFrame:
+  views::Widget::InitParams GetWidgetParams() override;
+  bool UseCustomFrame() const override;
+  bool UsesNativeSystemMenu() const override;
+  int GetMinimizeButtonOffset() const override;
+  bool ShouldSaveWindowPlacement() const override;
+  void GetWindowPlacement(gfx::Rect* bounds,
+                          ui::WindowShowState* show_state) const override;
+  content::KeyboardEventProcessingResult PreHandleKeyboardEvent(
+      const content::NativeWebKeyboardEvent& event) override;
+  bool HandleKeyboardEvent(
+      const content::NativeWebKeyboardEvent& event) override;
+
+ private:
+  // The BrowserView is our ClientView. This is a pointer to it.
+  BrowserView* browser_view_;
+  BrowserFrame* browser_frame_;
+
+  std::unique_ptr<wm::VisibilityController> visibility_controller_;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopBrowserFrameAndroid);
+};
+
+#endif  // CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_Android_H_
diff --git a/chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc b/chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc
new file mode 100644
index 000000000000..49b06a643ce4
--- /dev/null
+++ b/chrome/browser/ui/views/frame/native_browser_frame_factory_android.cc
@@ -0,0 +1,13 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/native_browser_frame_factory.h"
+
+#include "chrome/browser/ui/views/frame/desktop_browser_frame_android.h"
+
+NativeBrowserFrame* NativeBrowserFrameFactory::Create(
+    BrowserFrame* browser_frame,
+    BrowserView* browser_view) {
+  return new DesktopBrowserFrameAndroid(browser_frame, browser_view);
+}
diff --git a/chrome/browser/ui/views/javascript_dialog_views.cc b/chrome/browser/ui/views/javascript_dialog_views.cc
index 1ebb4979655b..bdb3a4ce529d 100644
--- a/chrome/browser/ui/views/javascript_dialog_views.cc
+++ b/chrome/browser/ui/views/javascript_dialog_views.cc
@@ -17,6 +17,7 @@
 JavaScriptDialogViews::~JavaScriptDialogViews() = default;
 
 // static
+#if 0
 base::WeakPtr<JavaScriptDialog> JavaScriptDialog::CreateNewDialog(
     content::WebContents* parent_web_contents,
     content::WebContents* alerting_web_contents,
@@ -32,6 +33,7 @@ base::WeakPtr<JavaScriptDialog> JavaScriptDialog::CreateNewDialog(
               std::move(dialog_force_closed_callback)))
       ->weak_factory_.GetWeakPtr();
 }
+#endif
 
 void JavaScriptDialogViews::CloseDialogWithoutCallback() {
   dialog_callback_.Reset();
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.cc b/chrome/browser/ui/views/location_bar/location_bar_view.cc
index 30a283abaa3f..6d11e88fdd06 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -362,11 +362,15 @@ void LocationBarView::SelectAll() {
 // LocationBarView, public LocationBar implementation:
 
 void LocationBarView::FocusLocation(bool is_user_initiated) {
+#if 0
   omnibox_view_->SetFocus(is_user_initiated);
+#endif
 }
 
 void LocationBarView::Revert() {
+#if 0
   omnibox_view_->RevertAll();
+#endif
 }
 
 OmniboxView* LocationBarView::GetOmniboxView() {
@@ -377,7 +381,7 @@ OmniboxView* LocationBarView::GetOmniboxView() {
 // LocationBarView, public views::View implementation:
 
 bool LocationBarView::HasFocus() const {
-  return omnibox_view_ && omnibox_view_->model()->has_focus();
+  return false;
 }
 
 void LocationBarView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
@@ -386,9 +390,12 @@ void LocationBarView::GetAccessibleNodeData(ui::AXNodeData* node_data) {
 
 gfx::Size LocationBarView::GetMinimumSize() const {
   const int height = GetLayoutConstant(LOCATION_BAR_HEIGHT);
+#if 0
   if (!IsInitialized())
+#endif
     return gfx::Size(0, height);
 
+#if 0
   const int inset_width = GetInsets().width();
   const int padding = GetLayoutConstant(LOCATION_BAR_ELEMENT_PADDING);
   const int leading_width = GetMinimumLeadingWidth();
@@ -435,13 +442,17 @@ gfx::Size LocationBarView::CalculatePreferredSize() const {
     width += trailing_width + padding;
 
   return gfx::Size(width, height);
+#endif
 }
 
 void LocationBarView::OnKeywordFaviconFetched(const gfx::Image& icon) {
+#if 0
   selected_keyword_view_->SetImage(icon.AsImageSkia());
+#endif
 }
 
 void LocationBarView::Layout() {
+#if 0
   if (!IsInitialized())
     return;
 
@@ -609,9 +620,11 @@ void LocationBarView::Layout() {
   }
   omnibox_view_->SetBoundsRect(location_bounds);
   View::Layout();
+#endif
 }
 
 void LocationBarView::OnThemeChanged() {
+#if 0
   // ToolbarView::Init() adds |this| to the view hierarchy before initializing,
   // which will trigger an early theme change.
   if (!IsInitialized())
@@ -630,14 +643,18 @@ void LocationBarView::OnThemeChanged() {
   location_icon_view_->Update(/*suppress_animations=*/false);
   RefreshClearAllButtonIcon();
   SchedulePaint();
+#endif
 }
 
 void LocationBarView::ChildPreferredSizeChanged(views::View* child) {
+#if 0
   Layout();
   SchedulePaint();
+#endif
 }
 
 void LocationBarView::Update(const WebContents* contents) {
+#if 0
   RefreshContentSettingViews();
 
   RefreshPageActionIconViews();
@@ -655,15 +672,17 @@ void LocationBarView::Update(const WebContents* contents) {
     send_tab_to_self_icon->SetVisible(false);
 
   OnChanged();  // NOTE: Calls Layout().
+#endif
 }
 
 void LocationBarView::ResetTabState(WebContents* contents) {
+#if 0
   omnibox_view_->ResetTabState(contents);
+#endif
 }
 
 bool LocationBarView::ActivateFirstInactiveBubbleForAccessibility() {
-  return page_action_icon_container_
-      ->ActivateFirstInactiveBubbleForAccessibility();
+  return false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/chrome/browser/ui/views/location_bar/location_bar_view.h b/chrome/browser/ui/views/location_bar/location_bar_view.h
index 8bd423986232..d3157a54726b 100644
--- a/chrome/browser/ui/views/location_bar/location_bar_view.h
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.h
@@ -175,7 +175,9 @@ class LocationBarView : public LocationBar,
   bool HasFocus() const override;
   void GetAccessibleNodeData(ui::AXNodeData* node_data) override;
   gfx::Size GetMinimumSize() const override;
+#if 0
   gfx::Size CalculatePreferredSize() const override;
+#endif
   void Layout() override;
   void OnThemeChanged() override;
   void ChildPreferredSizeChanged(views::View* child) override;
diff --git a/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc b/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc
index 5c4e950e1fec..6db7e49b618c 100644
--- a/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc
+++ b/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc
@@ -174,7 +174,7 @@ void OmniboxPopupContentsView::OpenMatch(
 gfx::Image OmniboxPopupContentsView::GetMatchIcon(
     const AutocompleteMatch& match,
     SkColor vector_icon_color) const {
-  return model_->GetMatchIcon(match, vector_icon_color);
+  return gfx::Image();
 }
 
 void OmniboxPopupContentsView::SetSelectedLine(size_t index) {
diff --git a/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc b/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
index efb8151b6873..10a6ca709e08 100644
--- a/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
+++ b/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
@@ -70,6 +70,7 @@ void PermissionPromptBubbleView::AddPermissionRequestLine(
                          DISTANCE_SUBSECTION_HORIZONTAL_INDENT)),
       provider->GetDistanceMetric(views::DISTANCE_RELATED_LABEL_HORIZONTAL)));
 
+#if 0
   auto* icon =
       line_container->AddChildView(std::make_unique<views::ImageView>());
   const gfx::VectorIcon& vector_id = request->GetIconId();
@@ -78,6 +79,7 @@ void PermissionPromptBubbleView::AddPermissionRequestLine(
   constexpr int kPermissionIconSize = 18;
   icon->SetImage(
       gfx::CreateVectorIcon(vector_id, kPermissionIconSize, icon_color));
+#endif
 
   auto* label = line_container->AddChildView(
       std::make_unique<views::Label>(request->GetMessageTextFragment()));
diff --git a/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc b/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc
index c085aa1e4bdd..9e3fe4847ea9 100644
--- a/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc
+++ b/chrome/browser/ui/views/permission_bubble/permission_prompt_impl.cc
@@ -15,6 +15,7 @@
 #include "ui/views/bubble/bubble_frame_view.h"
 
 // static
+#if 0
 std::unique_ptr<PermissionPrompt> PermissionPrompt::Create(
     content::WebContents* web_contents,
     Delegate* delegate) {
@@ -27,6 +28,7 @@ std::unique_ptr<PermissionPrompt> PermissionPrompt::Create(
   return std::make_unique<PermissionPromptImpl>(browser, web_contents,
                                                 delegate);
 }
+#endif
 
 PermissionPromptImpl::PermissionPromptImpl(Browser* browser,
                                            content::WebContents* web_contents,
diff --git a/chrome/browser/ui/views/profiles/avatar_button.cc b/chrome/browser/ui/views/profiles/avatar_button.cc
new file mode 100644
index 000000000000..dad990804bbd
--- /dev/null
+++ b/chrome/browser/ui/views/profiles/avatar_button.cc
@@ -0,0 +1,559 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/profiles/avatar_button.h"
+
+#include <memory>
+#include <utility>
+
+#include "build/build_config.h"
+#include "chrome/app/vector_icons/vector_icons.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/profiles/profiles_state.h"
+#include "chrome/browser/signin/account_consistency_mode_manager.h"
+#include "chrome/browser/signin/signin_manager_factory.h"
+#include "chrome/browser/themes/theme_properties.h"
+#include "chrome/browser/themes/theme_service.h"
+#include "chrome/browser/themes/theme_service_factory.h"
+#include "chrome/browser/ui/views/frame/avatar_button_manager.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/browser/ui/views/profiles/profile_chooser_view.h"
+#include "chrome/grit/generated_resources.h"
+#include "chrome/grit/theme_resources.h"
+#include "components/keyed_service/content/browser_context_keyed_service_shutdown_notifier_factory.h"
+#include "components/signin/core/browser/signin_manager.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "ui/base/theme_provider.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/color_palette.h"
+#include "ui/gfx/color_utils.h"
+#include "ui/gfx/paint_vector_icon.h"
+#include "ui/views/animation/flood_fill_ink_drop_ripple.h"
+#include "ui/views/animation/ink_drop_impl.h"
+#include "ui/views/animation/ink_drop_mask.h"
+#include "ui/views/controls/button/label_button_border.h"
+
+#if defined(OS_WIN)
+#include "base/win/windows_version.h"
+#include "chrome/browser/ui/views/frame/minimize_button_metrics_win.h"
+#endif
+
+#if BUILDFLAG(ENABLE_NATIVE_WINDOW_NAV_BUTTONS)
+#include "chrome/browser/ui/views/nav_button_provider.h"
+#endif
+
+namespace {
+
+#if 0
+constexpr int kGenericAvatarIconSize = 16;
+#endif
+
+// TODO(emx): Calculate width based on caption button [http://crbug.com/716365]
+constexpr int kCondensibleButtonMinWidth = 46;
+// TODO(emx): Should this be calculated based on average character width?
+constexpr int kCondensibleButtonMaxWidth = 98;
+
+#if defined(OS_WIN)
+constexpr gfx::Insets kBorderInsets(2, 8, 4, 8);
+
+std::unique_ptr<views::Border> CreateThemedBorder(
+    const int normal_image_set[],
+    const int hot_image_set[],
+    const int pushed_image_set[]) {
+  std::unique_ptr<views::LabelButtonAssetBorder> border(
+      new views::LabelButtonAssetBorder(views::Button::STYLE_TEXTBUTTON));
+
+  border->SetPainter(false, views::Button::STATE_NORMAL,
+                     views::Painter::CreateImageGridPainter(normal_image_set));
+  border->SetPainter(false, views::Button::STATE_HOVERED,
+                     views::Painter::CreateImageGridPainter(hot_image_set));
+  border->SetPainter(false, views::Button::STATE_PRESSED,
+                     views::Painter::CreateImageGridPainter(pushed_image_set));
+
+  border->set_insets(kBorderInsets);
+
+  return std::move(border);
+}
+#endif
+
+#if defined(OS_MACOSX)
+constexpr int kMacButtonHeight = 24;
+#endif
+
+// This class draws the border (and background) of the avatar button for
+// "themed" browser windows, i.e. OpaqueBrowserFrameView. Currently it's only
+// used on Linux as the shape specifically matches the Linux caption buttons.
+// TODO(estade): make this look nice on Windows and use it there as well.
+class AvatarButtonThemedBorder : public views::Border {
+ public:
+  AvatarButtonThemedBorder() {}
+  ~AvatarButtonThemedBorder() override {}
+
+  void Paint(const views::View& view, gfx::Canvas* canvas) override {
+    // Fill the color/background image from the theme.
+    cc::PaintFlags fill_flags;
+    fill_flags.setAntiAlias(true);
+    const ui::ThemeProvider* theme = view.GetThemeProvider();
+    fill_flags.setColor(
+        theme->GetColor(ThemeProperties::COLOR_BUTTON_BACKGROUND));
+    SkPath fill_path;
+    gfx::Rect fill_bounds = view.GetLocalBounds();
+    // The fill should overlap the inner stroke but not the outer stroke. But we
+    // don't inset the top because as it stands, the asset-based window controls
+    // fill one pixel higher due to how the background masking works out. Not
+    // matching that is very noticeable. TODO(estade): when the window
+    // controls use this same code, inset all sides equally.
+    fill_bounds.Inset(gfx::Insets(0, kStrokeWidth, kStrokeWidth, kStrokeWidth));
+    fill_path.addRoundRect(gfx::RectToSkRect(fill_bounds), kCornerRadius,
+                           kCornerRadius);
+    canvas->DrawPath(fill_path, fill_flags);
+    fill_flags.setColor(SK_ColorBLACK);
+    canvas->DrawImageInPath(
+        *theme->GetImageSkiaNamed(IDR_THEME_WINDOW_CONTROL_BACKGROUND), 0, 0,
+        fill_path, fill_flags);
+
+    // Paint an outer dark stroke.
+    cc::PaintFlags stroke_flags;
+    stroke_flags.setStyle(cc::PaintFlags::kStroke_Style);
+    // The colors are chosen to match the assets we use for Linux.
+    stroke_flags.setColor(SkColorSetA(SK_ColorBLACK, 0x2B));
+    stroke_flags.setStrokeWidth(kStrokeWidth);
+    stroke_flags.setAntiAlias(true);
+    gfx::RectF stroke_bounds(view.GetLocalBounds());
+    stroke_bounds.Inset(gfx::InsetsF(0.5f));
+    canvas->DrawRoundRect(stroke_bounds, kCornerRadius, stroke_flags);
+
+    // There's a second, light stroke that matches the fill bounds.
+    stroke_bounds.Inset(gfx::InsetsF(kStrokeWidth));
+    stroke_flags.setColor(SkColorSetA(SK_ColorWHITE, 0x3F));
+    canvas->DrawRoundRect(stroke_bounds, kCornerRadius, stroke_flags);
+  }
+
+  gfx::Insets GetInsets() const override {
+    auto insets = views::LabelButtonAssetBorder::GetDefaultInsetsForStyle(
+        views::Button::STYLE_TEXTBUTTON);
+    return kBorderStrokeInsets +
+           gfx::Insets(0, insets.left(), 0, insets.right());
+  }
+
+  gfx::Size GetMinimumSize() const override {
+    return gfx::Size(GetInsets().width(), GetInsets().height());
+  }
+
+  static std::unique_ptr<views::InkDropMask> CreateInkDropMask(
+      const gfx::Size& size) {
+    return std::make_unique<views::RoundRectInkDropMask>(
+        size, kBorderStrokeInsets, kCornerRadius);
+  }
+
+ private:
+  static constexpr int kStrokeWidth = 1;
+
+  // Insets between view bounds and the interior of the strokes.
+  static constexpr gfx::Insets kBorderStrokeInsets{kStrokeWidth * 2};
+
+  // Corner radius of the roundrect.
+  static constexpr float kCornerRadius = 1;
+
+  DISALLOW_COPY_AND_ASSIGN(AvatarButtonThemedBorder);
+};
+
+constexpr int AvatarButtonThemedBorder::kStrokeWidth;
+constexpr gfx::Insets AvatarButtonThemedBorder::kBorderStrokeInsets;
+constexpr float AvatarButtonThemedBorder::kCornerRadius;
+
+class AvatarButtonShutdownNotifierFactory
+    : public BrowserContextKeyedServiceShutdownNotifierFactory {
+ public:
+  static AvatarButtonShutdownNotifierFactory* GetInstance() {
+    return base::Singleton<AvatarButtonShutdownNotifierFactory>::get();
+  }
+
+ private:
+  friend struct base::DefaultSingletonTraits<
+      AvatarButtonShutdownNotifierFactory>;
+
+  AvatarButtonShutdownNotifierFactory()
+      : BrowserContextKeyedServiceShutdownNotifierFactory(
+            "AvatarButtonShutdownNotifierFactory") {
+    DependsOn(SigninManagerFactory::GetInstance());
+  }
+  ~AvatarButtonShutdownNotifierFactory() override {}
+
+  DISALLOW_COPY_AND_ASSIGN(AvatarButtonShutdownNotifierFactory);
+};
+
+#if defined(OS_WIN) || defined(OS_MACOSX)
+SkColor BaseColorForButton(const ui::ThemeProvider* theme_provider) {
+  return color_utils::IsDark(
+             theme_provider->GetColor(ThemeProperties::COLOR_FRAME))
+             ? SK_ColorWHITE
+             : SK_ColorBLACK;
+}
+
+gfx::ImageSkia AvatarIconWithBaseColor(const SkColor base_color) {
+  const SkColor icon_color =
+      SkColorSetA(base_color, static_cast<SkAlpha>(0.54 * 0xFF));
+  return gfx::CreateVectorIcon(kAccountCircleIcon, kGenericAvatarIconSize,
+                               icon_color);
+}
+#endif
+
+}  // namespace
+
+AvatarButton::AvatarButton(views::MenuButtonListener* listener,
+                           AvatarButtonStyle button_style,
+                           Profile* profile,
+                           AvatarButtonManager* manager)
+    : MenuButton(base::string16(), listener, false),
+      error_controller_(this, profile),
+      profile_(profile),
+      profile_observer_(this),
+      button_style_(button_style),
+      widget_observer_(this) {
+  DCHECK_NE(button_style, AvatarButtonStyle::NONE);
+#if BUILDFLAG(ENABLE_NATIVE_WINDOW_NAV_BUTTONS)
+  views::NavButtonProvider* nav_button_provider =
+      manager->get_nav_button_provider();
+  render_native_nav_buttons_ = nav_button_provider != nullptr;
+#endif
+  set_notify_action(Button::NOTIFY_ON_PRESS);
+  set_triggerable_event_flags(ui::EF_LEFT_MOUSE_BUTTON |
+                              ui::EF_RIGHT_MOUSE_BUTTON);
+  set_animate_on_state_change(false);
+#if !defined(OS_MACOSX)
+  SetEnabledTextColors(SK_ColorWHITE);
+  SetTextSubpixelRenderingEnabled(false);
+#endif
+  SetHorizontalAlignment(gfx::ALIGN_CENTER);
+
+  profile_observer_.Add(
+      &g_browser_process->profile_manager()->GetProfileAttributesStorage());
+
+  // The largest text height that fits in the button. If the font list height
+  // is larger than this, it will be shrunk to match it.
+  // TODO(noms): Calculate this constant algorithmically from the button's size.
+  const int kDisplayFontHeight = 16;
+  label()->SetFontList(
+      label()->font_list().DeriveWithHeightUpperBound(kDisplayFontHeight));
+
+  bool apply_ink_drop = ShouldApplyInkDrop();
+  if (render_native_nav_buttons_) {
+#if BUILDFLAG(ENABLE_NATIVE_WINDOW_NAV_BUTTONS)
+    SetBackground(nav_button_provider->CreateAvatarButtonBackground(this));
+    SetBorder(nullptr);
+    generic_avatar_ =
+        gfx::CreateVectorIcon(kProfileSwitcherOutlineIcon,
+                              kGenericAvatarIconSize, gfx::kChromeIconGrey);
+#endif
+  } else if (apply_ink_drop) {
+    SetInkDropMode(InkDropMode::ON);
+    SetFocusPainter(nullptr);
+#if defined(OS_LINUX)
+    set_ink_drop_base_color(SK_ColorWHITE);
+    SetBorder(std::make_unique<AvatarButtonThemedBorder>());
+    generic_avatar_ =
+        gfx::CreateVectorIcon(kProfileSwitcherOutlineIcon,
+                              kGenericAvatarIconSize, gfx::kChromeIconGrey);
+#elif defined(OS_WIN)
+    DCHECK_EQ(AvatarButtonStyle::NATIVE, button_style);
+    SetBorder(views::CreateEmptyBorder(kBorderInsets));
+  } else if (button_style == AvatarButtonStyle::THEMED) {
+    const int kNormalImageSet[] = IMAGE_GRID(IDR_AVATAR_THEMED_BUTTON_NORMAL);
+    const int kHoverImageSet[] = IMAGE_GRID(IDR_AVATAR_THEMED_BUTTON_HOVER);
+    const int kPressedImageSet[] = IMAGE_GRID(IDR_AVATAR_THEMED_BUTTON_PRESSED);
+    SetButtonAvatar(IDR_AVATAR_THEMED_BUTTON_AVATAR);
+    SetBorder(
+        CreateThemedBorder(kNormalImageSet, kHoverImageSet, kPressedImageSet));
+  } else if (base::win::GetVersion() < base::win::VERSION_WIN8) {
+    const int kNormalImageSet[] = IMAGE_GRID(IDR_AVATAR_GLASS_BUTTON_NORMAL);
+    const int kHoverImageSet[] = IMAGE_GRID(IDR_AVATAR_GLASS_BUTTON_HOVER);
+    const int kPressedImageSet[] = IMAGE_GRID(IDR_AVATAR_GLASS_BUTTON_PRESSED);
+    SetButtonAvatar(IDR_AVATAR_GLASS_BUTTON_AVATAR);
+    SetBorder(
+        CreateThemedBorder(kNormalImageSet, kHoverImageSet, kPressedImageSet));
+  } else {
+    const int kNormalImageSet[] = IMAGE_GRID(IDR_AVATAR_NATIVE_BUTTON_NORMAL);
+    const int kHoverImageSet[] = IMAGE_GRID(IDR_AVATAR_NATIVE_BUTTON_HOVER);
+    const int kPressedImageSet[] = IMAGE_GRID(IDR_AVATAR_NATIVE_BUTTON_PRESSED);
+    SetButtonAvatar(IDR_AVATAR_NATIVE_BUTTON_AVATAR);
+    SetBorder(
+        CreateThemedBorder(kNormalImageSet, kHoverImageSet, kPressedImageSet));
+#endif
+  }
+
+  profile_shutdown_notifier_ =
+      AvatarButtonShutdownNotifierFactory::GetInstance()
+          ->Get(profile_)
+          ->Subscribe(base::Bind(&AvatarButton::OnProfileShutdown,
+                                 base::Unretained(this)));
+}
+
+AvatarButton::~AvatarButton() {}
+
+void AvatarButton::SetupThemeColorButton() {
+#if defined(OS_WIN)
+  if (IsCondensible()) {
+    // TODO(bsep): This needs to also be called when the Windows accent color
+    // updates, but there is currently no signal for that.
+    const SkColor base_color = BaseColorForButton(GetThemeProvider());
+    set_ink_drop_base_color(base_color);
+    generic_avatar_ = AvatarIconWithBaseColor(base_color);
+  }
+#elif defined(OS_MACOSX)
+  const SkColor base_color = BaseColorForButton(GetThemeProvider());
+  SetEnabledTextColors(base_color);
+  generic_avatar_ = AvatarIconWithBaseColor(base_color);
+#endif
+}
+
+void AvatarButton::OnAvatarButtonPressed(const ui::Event* event) {
+  views::Widget* bubble_widget = ProfileChooserView::GetCurrentBubbleWidget();
+  if (bubble_widget && !widget_observer_.IsObserving(bubble_widget)) {
+    widget_observer_.Add(bubble_widget);
+    pressed_lock_ = std::make_unique<PressedLock>(
+        this, false, ui::LocatedEvent::FromIfValid(event));
+  }
+}
+
+void AvatarButton::AddedToWidget() {
+  SetupThemeColorButton();
+  Update();
+}
+
+void AvatarButton::OnGestureEvent(ui::GestureEvent* event) {
+  // TODO(wjmaclean): The check for ET_GESTURE_LONG_PRESS is done here since
+  // no other UI button based on Button appears to handle mouse
+  // right-click. If other cases are identified, it may make sense to move this
+  // check to Button.
+  if (event->type() == ui::ET_GESTURE_LONG_PRESS)
+    NotifyClick(*event);
+  else
+    MenuButton::OnGestureEvent(event);
+}
+
+gfx::Size AvatarButton::GetMinimumSize() const {
+  if (IsCondensible()) {
+    // Returns the size of the button when it is atop the tabstrip. Called by
+    // GlassBrowserFrameView::LayoutProfileSwitcher().
+    // TODO(emx): Calculate the height based on the top of the new tab button.
+    return gfx::Size(kCondensibleButtonMinWidth, 20);
+  }
+
+  return MenuButton::GetMinimumSize();
+}
+
+gfx::Size AvatarButton::CalculatePreferredSize() const {
+  if (render_native_nav_buttons_)
+    return MenuButton::CalculatePreferredSize();
+
+  // TODO(estade): Calculate the height instead of hardcoding to 20 for the
+  // not-condensible case.
+  gfx::Size size(MenuButton::CalculatePreferredSize().width(), 20);
+
+  if (IsCondensible()) {
+    // Returns the normal size of the button (when it does not overlap the
+    // tabstrip).
+    size.set_width(std::min(std::max(size.width(), kCondensibleButtonMinWidth),
+                            kCondensibleButtonMaxWidth));
+#if defined(OS_WIN)
+    size.set_height(MinimizeButtonMetrics::GetCaptionButtonHeightInDIPs());
+#endif
+  }
+#if defined(OS_MACOSX)
+  size.set_height(kMacButtonHeight);
+#endif
+  return size;
+}
+
+std::unique_ptr<views::InkDropMask> AvatarButton::CreateInkDropMask() const {
+#if defined(OS_MACOSX)
+  // On Mac, this looks and behaves like a regular MD button, so we need a hover
+  // background.
+  // TODO (lgrey): Determine and set the correct insets.
+  constexpr int kHoverCornerRadius = 2;
+  return std::make_unique<views::RoundRectInkDropMask>(size(), gfx::Insets(),
+                                                       kHoverCornerRadius);
+#else
+  if (button_style_ == AvatarButtonStyle::THEMED)
+    return AvatarButtonThemedBorder::CreateInkDropMask(size());
+  return MenuButton::CreateInkDropMask();
+#endif
+}
+
+std::unique_ptr<views::InkDropHighlight> AvatarButton::CreateInkDropHighlight()
+    const {
+  if (button_style_ == AvatarButtonStyle::THEMED)
+    return MenuButton::CreateInkDropHighlight();
+
+  auto ink_drop_highlight = std::make_unique<views::InkDropHighlight>(
+      size(), 0, gfx::RectF(GetLocalBounds()).CenterPoint(),
+      GetInkDropBaseColor());
+  constexpr float kInkDropHighlightOpacity = 0.08f;
+  ink_drop_highlight->set_visible_opacity(kInkDropHighlightOpacity);
+  return ink_drop_highlight;
+}
+
+SkColor AvatarButton::GetInkDropBaseColor() const {
+#if defined(OS_MACOSX)
+  return GetThemeProvider()->GetColor(
+      ThemeProperties::COLOR_TOOLBAR_BUTTON_ICON);
+#else
+  return MenuButton::GetInkDropBaseColor();
+#endif
+}
+
+bool AvatarButton::ShouldEnterPushedState(const ui::Event& event) {
+  if (ProfileChooserView::IsShowing())
+    return false;
+
+  return MenuButton::ShouldEnterPushedState(event);
+}
+
+bool AvatarButton::ShouldUseFloodFillInkDrop() const {
+  return true;
+}
+
+void AvatarButton::OnAvatarErrorChanged() {
+  Update();
+}
+
+void AvatarButton::OnProfileAdded(const base::FilePath& profile_path) {
+  Update();
+}
+
+void AvatarButton::OnProfileWasRemoved(const base::FilePath& profile_path,
+                                       const base::string16& profile_name) {
+  // If deleting the active profile, don't bother updating the avatar
+  // button, as the browser window is being closed anyway.
+  if (profile_->GetPath() != profile_path)
+    Update();
+}
+
+void AvatarButton::OnProfileNameChanged(
+    const base::FilePath& profile_path,
+    const base::string16& old_profile_name) {
+  if (profile_->GetPath() == profile_path)
+    Update();
+}
+
+void AvatarButton::OnProfileSupervisedUserIdChanged(
+    const base::FilePath& profile_path) {
+  if (profile_->GetPath() == profile_path)
+    Update();
+}
+
+void AvatarButton::OnWidgetDestroying(views::Widget* widget) {
+  pressed_lock_.reset();
+  if (render_native_nav_buttons_)
+    SchedulePaint();
+  widget_observer_.Remove(widget);
+}
+
+void AvatarButton::OnProfileShutdown() {
+  // It looks like in some mysterious cases, the AvatarButton outlives the
+  // profile (see http://crbug.com/id=579690). The avatar button is owned by
+  // the browser frame (which is owned by the BrowserWindow), and there is an
+  // expectation for the UI to be destroyed before the profile is destroyed.
+  CHECK(false) << "Avatar button must not outlive the profile.";
+}
+
+void AvatarButton::Update() {
+  // It looks like in some mysterious cases, the AvatarButton outlives the
+  // profile manager (see http://crbug.com/id=579690). The avatar button is
+  // owned by the browser frame (which is owned by the BrowserWindow), and
+  // there is an expectation for the UI to be destroyed before the profile
+  // manager is destroyed.
+  CHECK(g_browser_process->profile_manager())
+      << "Avatar button must not outlive the profile manager";
+
+  ProfileAttributesStorage& storage =
+      g_browser_process->profile_manager()->GetProfileAttributesStorage();
+
+  // If we have a single local profile, then use the generic avatar
+  // button instead of the profile name. Never use the generic button if
+  // the active profile is Guest.
+  const bool use_generic_button =
+      !profile_->IsGuestSession() && storage.GetNumberOfProfiles() == 1 &&
+      !SigninManagerFactory::GetForProfile(profile_)->IsAuthenticated();
+
+  // Always set the accessible name as accessible text, but don't display it if
+  // is just a generic button.
+  base::string16 name =
+      use_generic_button
+          ? l10n_util::GetStringUTF16(IDS_GENERIC_USER_AVATAR_LABEL)
+          : profiles::GetAvatarButtonTextForProfile(profile_);
+  if (use_generic_button) {
+    SetText(base::string16());
+    SetAccessibleName(name);  // Must be set after setting text to override it.
+  } else {
+    SetText(name);
+  }
+
+#if !defined(OS_MACOSX)
+  // If the button has no text, clear the text shadows to make sure the
+  // image is centered correctly. macOS doesn't use a shadow.
+  SetTextShadows(
+      use_generic_button
+          ? gfx::ShadowValues()
+          : gfx::ShadowValues(
+                10, gfx::ShadowValue(gfx::Vector2d(), 2.0f, SK_ColorDKGRAY)));
+#endif
+
+  if (use_generic_button) {
+    SetImage(views::Button::STATE_NORMAL, generic_avatar_);
+  } else if (profile_->IsSyncAllowed() && error_controller_.HasAvatarError()) {
+    // When DICE is enabled and the error is an auth error, the sync-paused icon
+    // is shown.
+    int dummy;
+    const bool should_show_sync_paused_ui =
+        AccountConsistencyModeManager::IsDiceEnabledForProfile(profile_) &&
+        sync_ui_util::GetMessagesForAvatarSyncError(
+            profile_, *SigninManagerFactory::GetForProfile(profile_), &dummy,
+            &dummy) == sync_ui_util::AUTH_ERROR;
+    SetImage(
+        views::Button::STATE_NORMAL,
+        should_show_sync_paused_ui
+            ? gfx::CreateVectorIcon(kSyncPausedIcon, 16, gfx::kGoogleBlue500)
+            : gfx::CreateVectorIcon(kSyncProblemIcon, 16, gfx::kGoogleRed700));
+  } else {
+    SetImage(views::Button::STATE_NORMAL, gfx::ImageSkia());
+  }
+
+  // If we are not using the generic button, then reset the spacing between
+  // the text and the possible authentication error icon.
+  const int kDefaultImageTextSpacing = 5;
+  SetImageLabelSpacing(use_generic_button ? 0 : kDefaultImageTextSpacing);
+
+  PreferredSizeChanged();
+}
+
+void AvatarButton::SetButtonAvatar(int avatar_idr) {
+  ui::ResourceBundle* rb = &ui::ResourceBundle::GetSharedInstance();
+  generic_avatar_ = *rb->GetImageNamed(avatar_idr).ToImageSkia();
+}
+
+// TODO(estade): all versions of this button should condense.
+bool AvatarButton::IsCondensible() const {
+#if defined(OS_WIN)
+  return (base::win::GetVersion() >= base::win::VERSION_WIN10) &&
+         button_style_ == AvatarButtonStyle::NATIVE;
+#else
+  return false;
+#endif
+}
+bool AvatarButton::ShouldApplyInkDrop() const {
+#if defined(OS_LINUX)
+  DCHECK_EQ(AvatarButtonStyle::THEMED, button_style_);
+  return true;
+#elif defined(OS_MACOSX)
+  return true;
+#else
+  if (render_native_nav_buttons_)
+    return false;
+  return IsCondensible();
+#endif
+}
diff --git a/chrome/browser/ui/views/profiles/profile_menu_view.cc b/chrome/browser/ui/views/profiles/profile_menu_view.cc
index 3c714bfb47b3..6c93f2d86511 100644
--- a/chrome/browser/ui/views/profiles/profile_menu_view.cc
+++ b/chrome/browser/ui/views/profiles/profile_menu_view.cc
@@ -257,8 +257,10 @@ void ProfileMenuView::OnPasswordsButtonClicked() {
   // TODO(crbug.com/995757): Remove user action.
   base::RecordAction(
       base::UserMetricsAction("ProfileChooser_PasswordsClicked"));
+#if 0
   NavigateToManagePasswordsPage(
       browser(), password_manager::ManagePasswordsReferrer::kProfileChooser);
+#endif
 }
 
 void ProfileMenuView::OnCreditCardsButtonClicked() {
diff --git a/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc b/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc
index f314c2f86a0e..48fdf2ee1d43 100644
--- a/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc
+++ b/chrome/browser/ui/views/relaunch_notification/relaunch_notification_controller.cc
@@ -305,5 +305,7 @@ void RelaunchNotificationController::Close() {
 }
 
 void RelaunchNotificationController::OnRelaunchDeadlineExpired() {
+#if 0
   chrome::RelaunchIgnoreUnloadHandlers();
+#endif
 }
diff --git a/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc b/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
index 48b7c642b682..7806dffd904e 100644
--- a/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
+++ b/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.cc
@@ -30,6 +30,7 @@ using views::BoxLayout;
 namespace {
 
 // Fixed height of the illustration shown on the top of the dialog.
+#if 0
 constexpr int kSafeBrowsingIllustrationHeight = 148;
 
 // Fixed background color of the illustration shown on the top of the dialog in
@@ -108,6 +109,7 @@ base::string16 GetOkButtonLabel(
       return l10n_util::GetStringUTF16(IDS_PAGE_INFO_PROTECT_ACCOUNT_BUTTON);
   }
 }
+#endif
 
 }  // namespace
 
@@ -137,6 +139,7 @@ PasswordReuseModalWarningDialog::PasswordReuseModalWarningDialog(
       service_(service),
       url_(web_contents->GetLastCommittedURL()),
       password_type_(password_type) {
+#if 0
   DialogDelegate::set_button_label(ui::DIALOG_BUTTON_OK,
                                    GetOkButtonLabel(password_type_));
   DialogDelegate::set_button_label(
@@ -165,13 +168,17 @@ PasswordReuseModalWarningDialog::PasswordReuseModalWarningDialog(
             : l10n_util::GetStringUTF16(IDS_PAGE_INFO_CHANGE_PASSWORD_DETAILS));
     CreateGaiaPasswordReuseModalWarningDialog(message_body_label);
   }
+#endif
 }
 
 PasswordReuseModalWarningDialog::~PasswordReuseModalWarningDialog() {
+#if 0
   if (service_)
     service_->RemoveObserver(this);
+#endif
 }
 
+#if 0
 void PasswordReuseModalWarningDialog::
     CreateSavedPasswordReuseModalWarningDialog(
         const base::string16 message_body,
@@ -221,6 +228,7 @@ void PasswordReuseModalWarningDialog::CreateGaiaPasswordReuseModalWarningDialog(
   }
   AddChildView(message_body_label);
 }
+#endif
 
 gfx::Size PasswordReuseModalWarningDialog::CalculatePreferredSize() const {
   constexpr int kDialogWidth = 400;
diff --git a/chrome/browser/ui/views/tabs/tab_strip.cc b/chrome/browser/ui/views/tabs/tab_strip.cc
index 6c808792ca0a..842740e3216f 100644
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -131,21 +131,9 @@ class TabHoverCardEventSniffer : public ui::EventHandler {
       : hover_card_(hover_card),
         tab_strip_(tab_strip),
         widget_(tab_strip->GetWidget()) {
-#if defined(OS_MACOSX)
-    if (widget_->GetRootView())
-      widget_->GetRootView()->AddPreTargetHandler(this);
-#else
-    if (widget_->GetNativeWindow())
-      widget_->GetNativeWindow()->AddPreTargetHandler(this);
-#endif
   }
 
   ~TabHoverCardEventSniffer() override {
-#if defined(OS_MACOSX)
-    widget_->GetRootView()->RemovePreTargetHandler(this);
-#else
-    widget_->GetNativeWindow()->RemovePreTargetHandler(this);
-#endif
   }
 
  protected:
diff --git a/chrome/browser/ui/views/tabs/window_finder_android.cc b/chrome/browser/ui/views/tabs/window_finder_android.cc
new file mode 100644
index 000000000000..e387278647d9
--- /dev/null
+++ b/chrome/browser/ui/views/tabs/window_finder_android.cc
@@ -0,0 +1,15 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/tabs/window_finder.h"
+
+#include "base/stl_util.h"
+#include "ui/display/screen.h"
+#include "ui/views/widget/widget.h"
+
+gfx::NativeWindow WindowFinder::GetLocalProcessWindowAtPoint(
+    const gfx::Point& screen_point,
+    const std::set<gfx::NativeWindow>& ignore) {
+  return nullptr;
+}
diff --git a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
index f7b987878c46..fbf3cf242b82 100644
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -434,6 +434,8 @@ WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,
     return &NewWebUI<UserActionsUI>;
   if (url.host_piece() == chrome::kChromeUIVersionHost)
     return &NewWebUI<VersionUI>;
+  if (url.host_piece() == chrome::kChromeUIExtensionsHost)
+    return &NewWebUI<extensions::ExtensionsUI>;
 
 #if !defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
diff --git a/chrome/browser/ui/webui/discards/BUILD.gn b/chrome/browser/ui/webui/discards/BUILD.gn
index cf71fc8ea10a..a3d581e4fecb 100644
--- a/chrome/browser/ui/webui/discards/BUILD.gn
+++ b/chrome/browser/ui/webui/discards/BUILD.gn
@@ -4,7 +4,7 @@
 
 import("//mojo/public/tools/bindings/mojom.gni")
 
-if (is_win || is_mac || is_desktop_linux || is_chromeos) {
+if (true || is_win || is_mac || is_desktop_linux || is_chromeos) {
   mojom("mojo_bindings") {
     sources = [
       "discards.mojom",
diff --git a/chrome/browser/ui/webui/media_router/media_router_ui.cc b/chrome/browser/ui/webui/media_router/media_router_ui.cc
new file mode 100644
index 000000000000..e2f3af9e14a8
--- /dev/null
+++ b/chrome/browser/ui/webui/media_router/media_router_ui.cc
@@ -0,0 +1,716 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/webui/media_router/media_router_ui.h"
+
+#include <algorithm>
+#include <string>
+#include <unordered_map>
+#include <utility>
+
+#include "base/guid.h"
+#include "base/macros.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/trace_event/trace_event.h"
+#include "build/build_config.h"
+#include "chrome/browser/media/router/issue_manager.h"
+#include "chrome/browser/media/router/issues_observer.h"
+#include "chrome/browser/media/router/media_router.h"
+#include "chrome/browser/media/router/media_router_factory.h"
+#include "chrome/browser/media/router/media_router_metrics.h"
+#include "chrome/browser/media/router/media_sinks_observer.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/sessions/session_tab_helper.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/browser_navigator.h"
+#include "chrome/browser/ui/browser_navigator_params.h"
+#include "chrome/browser/ui/browser_tabstrip.h"
+#include "chrome/browser/ui/media_router/media_router_ui_helper.h"
+#include "chrome/browser/ui/webui/media_router/media_router_localized_strings_provider.h"
+#include "chrome/browser/ui/webui/media_router/media_router_resources_provider.h"
+#include "chrome/browser/ui/webui/media_router/media_router_webui_message_handler.h"
+#include "chrome/common/chrome_features.h"
+#include "chrome/common/media_router/issue.h"
+#include "chrome/common/media_router/media_route.h"
+#include "chrome/common/media_router/media_sink.h"
+#include "chrome/common/media_router/media_source.h"
+#include "chrome/common/media_router/media_source_helper.h"
+#include "chrome/common/pref_names.h"
+#include "chrome/common/url_constants.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/prefs/pref_service.h"
+#include "components/prefs/scoped_user_pref_update.h"
+#include "content/public/browser/navigation_handle.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/browser/web_ui.h"
+#include "content/public/browser/web_ui_data_source.h"
+#include "content/public/common/fullscreen_video_element.mojom.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/constants.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+#include "third_party/blink/public/common/associated_interfaces/associated_interface_provider.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/web_dialogs/web_dialog_delegate.h"
+#include "url/origin.h"
+
+#if !defined(OS_MACOSX) || BUILDFLAG(MAC_VIEWS_BROWSER)
+#include "chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.h"
+#include "ui/display/display.h"
+#endif
+
+namespace media_router {
+
+// This class calls to refresh the UI when the highest priority issue is
+// updated.
+class MediaRouterUI::UIIssuesObserver : public IssuesObserver {
+ public:
+  UIIssuesObserver(IssueManager* issue_manager, MediaRouterUI* ui)
+      : IssuesObserver(issue_manager), ui_(ui) {
+    DCHECK(ui);
+  }
+
+  ~UIIssuesObserver() override {}
+
+  // IssuesObserver implementation.
+  void OnIssue(const Issue& issue) override { ui_->SetIssue(issue); }
+  void OnIssuesCleared() override { ui_->ClearIssue(); }
+
+ private:
+  // Reference back to the owning MediaRouterUI instance.
+  MediaRouterUI* ui_;
+
+  DISALLOW_COPY_AND_ASSIGN(UIIssuesObserver);
+};
+
+// Observes a WebContents and requests fullscreening of its first
+// video element.  The request is sent after the WebContents is loaded and tab
+// capture has begun. Marked final to prevent inheritance so delete calls are
+// contained to scenarios documented below.
+class MediaRouterUI::WebContentsFullscreenOnLoadedObserver final
+    : public content::WebContentsObserver {
+ public:
+  WebContentsFullscreenOnLoadedObserver(const GURL& file_url,
+                                        content::WebContents* web_contents)
+      : file_url_(file_url), capture_poll_timer_(false, false) {
+    DCHECK(file_url_.SchemeIsFile());
+    DCHECK(fullscreen_request_time_.is_null());
+
+    // If the WebContents is loading, start listening, otherwise just call the
+    // fullscreen function.
+
+    // This class destroys itself in the following situations (at least one of
+    // which will occur):
+    //   * after loading is complete and,
+    //   ** capture has begun and fullscreen requested,
+    //   ** kMaxSecondsToWaitForCapture seconds have passed without capture,
+    //   * another navigation is started,
+    //   * the WebContents is destroyed.
+    if (web_contents->IsLoading()) {
+      Observe(web_contents);
+    } else {
+      FullScreenFirstVideoElement(web_contents);
+    }
+  }
+  ~WebContentsFullscreenOnLoadedObserver() override {}
+
+  // content::WebContentsObserver implementation.
+  void DidStopLoading() override {
+    FullScreenFirstVideoElement(web_contents());
+  }
+
+  void DidStartNavigation(
+      content::NavigationHandle* navigation_handle) override {
+    // If the user takes over and navigates away from the file, stop listening.
+    // (It is possible however for this listener to be created before the
+    // navigation to the requested file triggers, so provided we're still on the
+    // same URL, go ahead and keep listening).
+    if (file_url_ != navigation_handle->GetURL()) {
+      delete this;
+    }
+  }
+
+  void WebContentsDestroyed() override {
+    // If the WebContents is destroyed we will never trigger and need to clean
+    // up.
+    delete this;
+  }
+
+ private:
+  const GURL file_url_;
+
+  // Time intervals used by the logic that detects if capture has started.
+  const int kMaxSecondsToWaitForCapture = 10;
+  const int kPollIntervalInSeconds = 1;
+
+  // The time at which fullscreen was requested.
+  base::TimeTicks fullscreen_request_time_;
+
+  // Poll timer to monitor the capturer count when fullscreening local files.
+  //
+  // TODO(crbug.com/540965): Add a method to WebContentsObserver to report
+  // capturer count changes and get rid of this polling-based approach.
+  base::Timer capture_poll_timer_;
+
+  // Sends a request for full screen to the WebContents targeted at the first
+  // video element.  The request is only sent after capture has begun.
+  void FullScreenFirstVideoElement(content::WebContents* web_contents) {
+    if (file_url_ != web_contents->GetLastCommittedURL()) {
+      // The user has navigated before the casting started. Do not attempt to
+      // fullscreen and cleanup.
+      return;
+    }
+
+    fullscreen_request_time_ = base::TimeTicks::Now();
+    FullscreenIfContentCaptured(web_contents);
+  }
+
+  void FullscreenIfContentCaptured(content::WebContents* web_contents) {
+    if (web_contents->IsBeingCaptured()) {
+      content::mojom::FullscreenVideoElementHandlerAssociatedPtr client;
+      web_contents->GetMainFrame()
+          ->GetRemoteAssociatedInterfaces()
+          ->GetInterface(&client);
+      client->RequestFullscreenVideoElement();
+      delete this;
+      return;
+    } else if (base::TimeTicks::Now() - fullscreen_request_time_ >
+               base::TimeDelta::FromSeconds(kMaxSecondsToWaitForCapture)) {
+      // If content capture hasn't started within the timeout skip fullscreen.
+      DLOG(WARNING) << "Capture of local content did not start within timeout";
+      delete this;
+      return;
+    }
+
+    capture_poll_timer_.Start(
+        FROM_HERE, base::TimeDelta::FromSeconds(kPollIntervalInSeconds),
+        base::BindRepeating(
+            &WebContentsFullscreenOnLoadedObserver::FullscreenIfContentCaptured,
+            base::Unretained(this), web_contents));
+  }
+};
+
+MediaRouterUI::MediaRouterUI(content::WebUI* web_ui)
+    : ConstrainedWebDialogUI(web_ui),
+      ui_initialized_(false),
+      weak_factory_(this) {
+  auto handler = std::make_unique<MediaRouterWebUIMessageHandler>(this);
+  handler_ = handler.get();
+
+  // Create a WebUIDataSource containing the chrome://media-router page's
+  // content.
+  std::unique_ptr<content::WebUIDataSource> html_source(
+      content::WebUIDataSource::Create(chrome::kChromeUIMediaRouterHost));
+
+  AddLocalizedStrings(html_source.get());
+  AddMediaRouterUIResources(html_source.get());
+  // Ownership of |html_source| is transferred to the BrowserContext.
+  content::WebUIDataSource::Add(Profile::FromWebUI(web_ui),
+                                html_source.release());
+
+  web_ui->AddMessageHandler(std::move(handler));
+}
+
+MediaRouterUI::~MediaRouterUI() = default;
+
+void MediaRouterUI::Close() {
+  ConstrainedWebDialogDelegate* delegate = GetConstrainedDelegate();
+  if (delegate) {
+    delegate->GetWebDialogDelegate()->OnDialogClosed(std::string());
+    delegate->OnDialogCloseFromWebUI();
+  }
+}
+
+void MediaRouterUI::OnUIInitialized() {
+  TRACE_EVENT_NESTABLE_ASYNC_END0("media_router", "UI", initiator());
+
+  ui_initialized_ = true;
+
+  // TODO(imcheng): We should be able to instantiate |issue_observer_| during
+  // InitCommon by storing an initial Issue in this class.
+  // Register for Issue updates.
+  issues_observer_ =
+      std::make_unique<UIIssuesObserver>(GetIssueManager(), this);
+  issues_observer_->Init();
+}
+
+bool MediaRouterUI::CreateRoute(const MediaSink::Id& sink_id,
+                                MediaCastMode cast_mode) {
+  // Default the tab casting the content to the initiator, and change if
+  // necessary.
+  content::WebContents* tab_contents = initiator();
+
+  base::Optional<RouteParameters> params;
+  if (cast_mode == MediaCastMode::LOCAL_FILE) {
+    GURL url = media_router_file_dialog_->GetLastSelectedFileUrl();
+    tab_contents = OpenTabWithUrl(url);
+    params = GetLocalFileRouteParameters(sink_id, url, tab_contents);
+  } else {
+    params = GetRouteParameters(sink_id, cast_mode);
+  }
+  if (!params) {
+    SendIssueForUnableToCast(cast_mode);
+    return false;
+  }
+
+  GetIssueManager()->ClearNonBlockingIssues();
+  GetMediaRouter()->CreateRoute(params->source_id, sink_id, params->origin,
+                                tab_contents,
+                                std::move(params->route_response_callbacks),
+                                params->timeout, params->incognito);
+  return true;
+}
+
+bool MediaRouterUI::ConnectRoute(const MediaSink::Id& sink_id,
+                                 const MediaRoute::Id& route_id) {
+  base::Optional<RouteParameters> params =
+      GetRouteParameters(sink_id, MediaCastMode::PRESENTATION);
+  if (!params) {
+    SendIssueForUnableToCast(MediaCastMode::PRESENTATION);
+    return false;
+  }
+  GetIssueManager()->ClearNonBlockingIssues();
+  GetMediaRouter()->ConnectRouteByRouteId(
+      params->source_id, route_id, params->origin, initiator(),
+      std::move(params->route_response_callbacks), params->timeout,
+      params->incognito);
+  return true;
+}
+
+void MediaRouterUI::AddIssue(const IssueInfo& issue) {
+  GetIssueManager()->AddIssue(issue);
+}
+
+void MediaRouterUI::ClearIssue(const Issue::Id& issue_id) {
+  GetIssueManager()->ClearIssue(issue_id);
+}
+
+void MediaRouterUI::OpenFileDialog() {
+  if (!media_router_file_dialog_) {
+    media_router_file_dialog_ = std::make_unique<MediaRouterFileDialog>(this);
+  }
+
+  media_router_file_dialog_->OpenFileDialog(GetBrowser());
+}
+
+void MediaRouterUI::SearchSinksAndCreateRoute(
+    const MediaSink::Id& sink_id,
+    const std::string& search_criteria,
+    const std::string& domain,
+    MediaCastMode cast_mode) {
+  std::unique_ptr<MediaSource> source =
+      query_result_manager()->GetSourceForCastModeAndSink(cast_mode, sink_id);
+  const std::string source_id = source ? source->id() : "";
+
+  // The CreateRoute() part of the function is accomplished in the callback
+  // OnSearchSinkResponseReceived().
+  GetMediaRouter()->SearchSinks(
+      sink_id, source_id, search_criteria, domain,
+      base::BindRepeating(&MediaRouterUI::OnSearchSinkResponseReceived,
+                          weak_factory_.GetWeakPtr(), cast_mode));
+}
+
+bool MediaRouterUI::UserSelectedTabMirroringForCurrentOrigin() const {
+  const base::ListValue* origins =
+      Profile::FromWebUI(web_ui())->GetPrefs()->GetList(
+          ::prefs::kMediaRouterTabMirroringSources);
+  return origins->Find(base::Value(GetSerializedInitiatorOrigin())) !=
+         origins->end();
+}
+
+void MediaRouterUI::RecordCastModeSelection(MediaCastMode cast_mode) {
+  ListPrefUpdate update(Profile::FromWebUI(web_ui())->GetPrefs(),
+                        ::prefs::kMediaRouterTabMirroringSources);
+
+  switch (cast_mode) {
+    case MediaCastMode::PRESENTATION:
+      update->Remove(base::Value(GetSerializedInitiatorOrigin()), nullptr);
+      break;
+    case MediaCastMode::TAB_MIRROR:
+      update->AppendIfNotPresent(
+          std::make_unique<base::Value>(GetSerializedInitiatorOrigin()));
+      break;
+    case MediaCastMode::DESKTOP_MIRROR:
+      // Desktop mirroring isn't domain-specific, so we don't record the
+      // selection.
+      break;
+    case MediaCastMode::LOCAL_FILE:
+      // Local media isn't domain-specific, so we don't record the selection.
+      break;
+    default:
+      NOTREACHED();
+      break;
+  }
+}
+
+std::string MediaRouterUI::GetPresentationRequestSourceName() const {
+  GURL gurl = GetFrameURL();
+  return gurl.SchemeIs(extensions::kExtensionScheme)
+             ? GetExtensionName(gurl, extensions::ExtensionRegistry::Get(
+                                          Profile::FromWebUI(web_ui())))
+             : GetHostFromURL(gurl);
+}
+
+const std::set<MediaCastMode>& MediaRouterUI::cast_modes() const {
+  return cast_modes_;
+}
+
+void MediaRouterUI::SetUIInitializationTimer(const base::Time& start_time) {
+  DCHECK(!start_time.is_null());
+  start_time_ = start_time;
+}
+
+void MediaRouterUI::OnUIInitiallyLoaded() {
+  if (!start_time_.is_null()) {
+    MediaRouterMetrics::RecordMediaRouterDialogPaint(base::Time::Now() -
+                                                     start_time_);
+  }
+}
+
+void MediaRouterUI::OnUIInitialDataReceived() {
+  if (!start_time_.is_null()) {
+    MediaRouterMetrics::RecordMediaRouterDialogLoaded(base::Time::Now() -
+                                                      start_time_);
+    start_time_ = base::Time();
+  }
+}
+
+void MediaRouterUI::UpdateMaxDialogHeight(int height) {
+  if (ui_initialized_) {
+    handler_->UpdateMaxDialogHeight(height);
+  }
+}
+
+MediaRouteController* MediaRouterUI::GetMediaRouteController() const {
+  return route_controller_observer_
+             ? route_controller_observer_->controller().get()
+             : nullptr;
+}
+
+void MediaRouterUI::OnMediaControllerUIAvailable(
+    const MediaRoute::Id& route_id) {
+#if 0
+  scoped_refptr<MediaRouteController> controller =
+      GetMediaRouter()->GetRouteController(route_id);
+  if (!controller) {
+    DVLOG(1) << "Requested a route controller with an invalid route ID.";
+    return;
+  }
+  DVLOG_IF(1, route_controller_observer_)
+      << "Route controller observer unexpectedly exists.";
+  route_controller_observer_ =
+      std::make_unique<UIMediaRouteControllerObserver>(this, controller);
+#endif
+}
+
+void MediaRouterUI::OnMediaControllerUIClosed() {
+  route_controller_observer_.reset();
+}
+
+void MediaRouterUI::InitForTest(
+    MediaRouter* router,
+    content::WebContents* initiator,
+    MediaRouterWebUIMessageHandler* handler,
+    std::unique_ptr<StartPresentationContext> context,
+    std::unique_ptr<MediaRouterFileDialog> file_dialog) {
+  handler_ = handler;
+  set_start_presentation_context_for_test(std::move(context));
+  InitForTest(std::move(file_dialog));
+  InitCommon(initiator);
+  if (start_presentation_context()) {
+    OnDefaultPresentationChanged(
+        start_presentation_context()->presentation_request());
+  }
+
+  OnUIInitialized();
+}
+
+void MediaRouterUI::InitForTest(
+    std::unique_ptr<MediaRouterFileDialog> file_dialog) {
+  media_router_file_dialog_ = std::move(file_dialog);
+}
+
+MediaRouterUI::UIMediaRouteControllerObserver::UIMediaRouteControllerObserver(
+    MediaRouterUI* ui,
+    scoped_refptr<MediaRouteController> controller)
+    : MediaRouteController::Observer(std::move(controller)), ui_(ui) {
+  if (controller_->current_media_status())
+    OnMediaStatusUpdated(controller_->current_media_status().value());
+}
+
+MediaRouterUI::UIMediaRouteControllerObserver::
+    ~UIMediaRouteControllerObserver() {}
+
+void MediaRouterUI::UIMediaRouteControllerObserver::OnMediaStatusUpdated(
+    const MediaStatus& status) {
+  ui_->UpdateMediaRouteStatus(status);
+}
+
+void MediaRouterUI::UIMediaRouteControllerObserver::OnControllerInvalidated() {
+  ui_->OnRouteControllerInvalidated();
+}
+
+Browser* MediaRouterUI::GetBrowser() {
+  CHECK(initiator());
+  return chrome::FindBrowserWithWebContents(initiator());
+}
+
+content::WebContents* MediaRouterUI::OpenTabWithUrl(const GURL url) {
+  // Check if the current page is a new tab. If so open file in current page.
+  // If not then open a new page.
+  if (initiator()->GetVisibleURL() == chrome::kChromeUINewTabURL) {
+    content::NavigationController::LoadURLParams load_params(url);
+    load_params.transition_type = ui::PAGE_TRANSITION_GENERATED;
+    initiator()->GetController().LoadURLWithParams(load_params);
+    return initiator();
+  } else {
+    return chrome::AddSelectedTabWithURL(GetBrowser(), url,
+                                         ui::PAGE_TRANSITION_LINK);
+  }
+}
+
+void MediaRouterUI::FileDialogFileSelected(
+    const ui::SelectedFileInfo& file_info) {
+  handler_->UserSelectedLocalMediaFile(file_info.display_name);
+}
+
+void MediaRouterUI::FileDialogSelectionFailed(const IssueInfo& issue) {
+  AddIssue(issue);
+}
+
+void MediaRouterUI::SetIssue(const Issue& issue) {
+  if (ui_initialized_)
+    handler_->UpdateIssue(issue);
+}
+
+void MediaRouterUI::ClearIssue() {
+  if (ui_initialized_)
+    handler_->ClearIssue();
+}
+
+void MediaRouterUI::OnRoutesUpdated(
+    const std::vector<MediaRoute>& routes,
+    const std::vector<MediaRoute::Id>& joinable_route_ids) {
+  MediaRouterUIBase::OnRoutesUpdated(routes, joinable_route_ids);
+  joinable_route_ids_.clear();
+
+  for (const MediaRoute& route : routes) {
+    if (route.for_display() &&
+        base::ContainsValue(joinable_route_ids, route.media_route_id())) {
+      joinable_route_ids_.push_back(route.media_route_id());
+    }
+  }
+
+  if (ui_initialized_) {
+    handler_->UpdateRoutes(MediaRouterUIBase::routes(), joinable_route_ids_,
+                           routes_and_cast_modes());
+  }
+  UpdateRoutesToCastModesMapping();
+}
+
+void MediaRouterUI::OnRouteResponseReceived(
+    int route_request_id,
+    const MediaSink::Id& sink_id,
+    MediaCastMode cast_mode,
+    const base::string16& presentation_request_source_name,
+    const RouteRequestResult& result) {
+  MediaRouterUIBase::OnRouteResponseReceived(
+      route_request_id, sink_id, cast_mode, presentation_request_source_name,
+      result);
+  handler_->OnCreateRouteResponseReceived(sink_id, result.route());
+  if (result.result_code() == RouteRequestResult::TIMED_OUT)
+    SendIssueForRouteTimeout(cast_mode, presentation_request_source_name);
+}
+
+void MediaRouterUI::MaybeReportFileInformation(
+    const RouteRequestResult& result) {
+  if (result.result_code() == RouteRequestResult::OK)
+    media_router_file_dialog_->MaybeReportLastSelectedFileInformation();
+}
+
+void MediaRouterUI::HandleCreateSessionRequestRouteResponse(
+    const RouteRequestResult&) {
+  Close();
+}
+
+void MediaRouterUI::OnSearchSinkResponseReceived(
+    MediaCastMode cast_mode,
+    const MediaSink::Id& found_sink_id) {
+  DVLOG(1) << "OnSearchSinkResponseReceived";
+  handler_->ReturnSearchResult(found_sink_id);
+
+  CreateRoute(found_sink_id, cast_mode);
+}
+
+void MediaRouterUI::SendIssueForRouteTimeout(
+    MediaCastMode cast_mode,
+    const base::string16& presentation_request_source_name) {
+  std::string issue_title;
+  switch (cast_mode) {
+    case PRESENTATION:
+      DLOG_IF(ERROR, presentation_request_source_name.empty())
+          << "Empty presentation request source name.";
+      issue_title =
+          l10n_util::GetStringFUTF8(IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT,
+                                    presentation_request_source_name);
+      break;
+    case TAB_MIRROR:
+      issue_title = l10n_util::GetStringUTF8(
+          IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT_FOR_TAB);
+      break;
+    case DESKTOP_MIRROR:
+      issue_title = l10n_util::GetStringUTF8(
+          IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT_FOR_DESKTOP);
+      break;
+    default:
+      NOTREACHED();
+  }
+
+  AddIssue(IssueInfo(issue_title, IssueInfo::Action::DISMISS,
+                     IssueInfo::Severity::NOTIFICATION));
+}
+
+void MediaRouterUI::SendIssueForUnableToCast(MediaCastMode cast_mode) {
+  // For a generic error, claim a tab error unless it was specifically desktop
+  // mirroring.
+  std::string issue_title =
+      (cast_mode == MediaCastMode::DESKTOP_MIRROR)
+          ? l10n_util::GetStringUTF8(
+                IDS_MEDIA_ROUTER_ISSUE_UNABLE_TO_CAST_DESKTOP)
+          : l10n_util::GetStringUTF8(
+                IDS_MEDIA_ROUTER_ISSUE_CREATE_ROUTE_TIMEOUT_FOR_TAB);
+  AddIssue(IssueInfo(issue_title, IssueInfo::Action::DISMISS,
+                     IssueInfo::Severity::WARNING));
+}
+
+void MediaRouterUI::InitCommon(content::WebContents* initiator) {
+  MediaRouterUIBase::InitCommon(initiator);
+  UpdateCastModes();
+  // Presentation requests from content must show the origin requesting
+  // presentation: crbug.com/704964
+  if (start_presentation_context())
+    forced_cast_mode_ = MediaCastMode::PRESENTATION;
+}
+
+void MediaRouterUI::OnDefaultPresentationChanged(
+    const content::PresentationRequest& presentation_request) {
+  MediaRouterUIBase::OnDefaultPresentationChanged(presentation_request);
+  UpdateCastModes();
+}
+
+void MediaRouterUI::OnDefaultPresentationRemoved() {
+  MediaRouterUIBase::OnDefaultPresentationRemoved();
+
+  // This should not be set if the dialog was initiated with a default
+  // presentation request from the top level frame.  However, clear it just to
+  // be safe.
+  forced_cast_mode_ = base::nullopt;
+  UpdateCastModes();
+}
+
+base::Optional<RouteParameters> MediaRouterUI::GetLocalFileRouteParameters(
+    const MediaSink::Id& sink_id,
+    const GURL& file_url,
+    content::WebContents* tab_contents) {
+  RouteParameters params;
+  SessionID::id_type tab_id = SessionTabHelper::IdForTab(tab_contents).id();
+  params.source_id = MediaSourceForTab(tab_id).id();
+
+  // Use a placeholder URL as origin for local file casting, which is
+  // essentially mirroring.
+  params.origin = url::Origin::Create(GURL(chrome::kChromeUIMediaRouterURL));
+
+  params.route_response_callbacks.push_back(base::BindOnce(
+      &MediaRouterUI::OnRouteResponseReceived, weak_factory_.GetWeakPtr(),
+      current_route_request_id(), sink_id, MediaCastMode::LOCAL_FILE,
+      base::UTF8ToUTF16(GetTruncatedPresentationRequestSourceName())));
+
+  params.route_response_callbacks.push_back(
+      base::BindOnce(&MediaRouterUIBase::MaybeReportCastingSource,
+                     weak_factory_.GetWeakPtr(), MediaCastMode::LOCAL_FILE));
+
+  params.route_response_callbacks.push_back(base::BindOnce(
+      &MediaRouterUI::MaybeReportFileInformation, weak_factory_.GetWeakPtr()));
+
+  params.route_response_callbacks.push_back(
+      base::BindOnce(&MediaRouterUI::FullScreenFirstVideoElement,
+                     weak_factory_.GetWeakPtr(), file_url, tab_contents));
+
+  params.timeout = GetRouteRequestTimeout(MediaCastMode::LOCAL_FILE);
+  CHECK(initiator());
+  params.incognito = initiator()->GetBrowserContext()->IsOffTheRecord();
+
+  return base::make_optional(std::move(params));
+}
+
+// TODO(crbug.com/792547): Refactor FullScreenFirstVideoElement() and
+// MaybeReportFileInformation() into a local media casting specific location
+// instead of here in the main ui.
+void MediaRouterUI::FullScreenFirstVideoElement(
+    const GURL& file_url,
+    content::WebContents* web_contents,
+    const RouteRequestResult& result) {
+  if (result.result_code() == RouteRequestResult::OK) {
+    new WebContentsFullscreenOnLoadedObserver(file_url, web_contents);
+  }
+}
+
+void MediaRouterUI::UpdateCastModes() {
+  // Gets updated cast modes from |query_result_manager()| and forwards it to
+  // UI.
+  cast_modes_ = query_result_manager()->GetSupportedCastModes();
+  if (ui_initialized_) {
+    handler_->UpdateCastModes(cast_modes(), GetPresentationRequestSourceName(),
+                              forced_cast_mode());
+  }
+}
+
+void MediaRouterUI::UpdateRoutesToCastModesMapping() {
+  std::unordered_map<MediaSource::Id, MediaCastMode> available_source_map;
+  for (const auto& cast_mode : cast_modes()) {
+    for (const auto& source : GetSourcesForCastMode(cast_mode))
+      available_source_map.insert(std::make_pair(source.id(), cast_mode));
+  }
+
+  routes_and_cast_modes_.clear();
+  for (const auto& route : routes()) {
+    auto source_entry = available_source_map.find(route.media_source().id());
+    if (source_entry != available_source_map.end()) {
+      routes_and_cast_modes_.insert(
+          std::make_pair(route.media_route_id(), source_entry->second));
+    }
+  }
+}
+
+std::string MediaRouterUI::GetSerializedInitiatorOrigin() const {
+  url::Origin origin =
+      initiator() ? url::Origin::Create(initiator()->GetLastCommittedURL())
+                  : url::Origin();
+  return origin.Serialize();
+}
+
+void MediaRouterUI::OnRouteControllerInvalidated() {
+  route_controller_observer_.reset();
+  handler_->OnRouteControllerInvalidated();
+}
+void MediaRouterUI::UpdateMediaRouteStatus(const MediaStatus& status) {
+  handler_->UpdateMediaRouteStatus(status);
+}
+
+IssueManager* MediaRouterUI::GetIssueManager() {
+  return GetMediaRouter()->GetIssueManager();
+}
+
+void MediaRouterUI::UpdateSinks() {
+  if (ui_initialized_)
+    handler_->UpdateSinks(GetEnabledSinks());
+}
+
+MediaRouter* MediaRouterUI::GetMediaRouter() const {
+  return MediaRouterFactory::GetApiForBrowserContext(
+      web_ui()->GetWebContents()->GetBrowserContext());
+}
+
+}  // namespace media_router
diff --git a/chrome/browser/ui/webui/settings/change_password_handler.cc b/chrome/browser/ui/webui/settings/change_password_handler.cc
index b34815f9c76f..bf86d6d1e9b8 100644
--- a/chrome/browser/ui/webui/settings/change_password_handler.cc
+++ b/chrome/browser/ui/webui/settings/change_password_handler.cc
@@ -58,24 +58,9 @@ void ChangePasswordHandler::HandleInitialize(const base::ListValue* args) {
 }
 
 void ChangePasswordHandler::HandleChangePassword(const base::ListValue* args) {
-  service_->OnUserAction(
-      web_ui()->GetWebContents(),
-      service_->reused_password_account_type_for_last_shown_warning(),
-      RequestOutcome::UNKNOWN,
-      LoginReputationClientResponse::VERDICT_TYPE_UNSPECIFIED, "unused_token",
-      safe_browsing::WarningUIType::CHROME_SETTINGS,
-      safe_browsing::WarningAction::CHANGE_PASSWORD);
 }
 
 void ChangePasswordHandler::UpdateChangePasswordCardVisibility() {
-  FireWebUIListener(
-      "change-password-visibility",
-      base::Value(
-          service_->IsWarningEnabled(
-              service_
-                  ->reused_password_account_type_for_last_shown_warning()) &&
-          safe_browsing::ChromePasswordProtectionService::
-              ShouldShowChangePasswordSettingUI(profile_)));
 }
 
 }  // namespace settings
diff --git a/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc b/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
index fbf48642e0dd..567cf2fc39f0 100644
--- a/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
+++ b/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
@@ -248,6 +248,7 @@ void LockProfileAndShowUserManager(const base::FilePath& profile_path) {
 void OnSyncSetupComplete(Profile* profile,
                          const std::string& username,
                          const std::string& password) {
+#if 0
   DCHECK(signin_util::IsForceSigninEnabled());
   signin::IdentityManager* identity_manager =
       IdentityManagerFactory::GetForProfile(profile);
@@ -273,6 +274,7 @@ void OnSyncSetupComplete(Profile* profile,
         BrowserList::CloseCallback(),
         /*skip_beforeunload=*/true);
   }
+#endif
 }
 
 }  // namespace
@@ -409,11 +411,13 @@ void InlineSigninHelper::OnClientOAuthSuccessAndBrowserOpened(
       // Display a confirmation dialog to the user.
       base::RecordAction(
           base::UserMetricsAction("Signin_Show_UntrustedSigninPrompt"));
+#if 0
       Browser* browser = chrome::FindLastActiveWithProfile(profile_);
       browser->window()->ShowOneClickSigninConfirmation(
           base::UTF8ToUTF16(email_),
           base::BindOnce(&InlineSigninHelper::UntrustedSigninConfirmed,
                          base::Unretained(this), result.refresh_token));
+#endif
       return;
     }
     CreateSyncStarter(result.refresh_token);
diff --git a/chrome/browser/ui/window_sizer/window_sizer_android.cc b/chrome/browser/ui/window_sizer/window_sizer_android.cc
new file mode 100644
index 000000000000..a75302b74d6c
--- /dev/null
+++ b/chrome/browser/ui/window_sizer/window_sizer_android.cc
@@ -0,0 +1,17 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/window_sizer/window_sizer.h"
+
+// This doesn't matter for aura, which has different tiling.
+// static
+const int WindowSizer::kWindowTilePixels = 10;
+const int WindowSizer::kWindowMaxDefaultWidth = 1050;
+
+// static
+gfx::Point WindowSizer::GetDefaultPopupOrigin(const gfx::Size& size) {
+  // TODO(skuhne): Check if this isn't needed anymore (since it is implemented
+  // in WindowPositioner) and remove it.
+  return gfx::Point();
+}
diff --git a/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc b/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc
index 828d0552721c..470f3599a014 100644
--- a/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc
+++ b/chrome/browser/ui/zoom/chrome_zoom_level_prefs.cc
@@ -81,6 +81,7 @@ std::string ChromeZoomLevelPrefs::GetPartitionKeyForTesting(
 }
 
 void ChromeZoomLevelPrefs::SetDefaultZoomLevelPref(double level) {
+#if 0
   if (blink::PageZoomValuesEqual(level, host_zoom_map_->GetDefaultZoomLevel()))
     return;
 
@@ -92,16 +93,12 @@ void ChromeZoomLevelPrefs::SetDefaultZoomLevelPref(double level) {
   default_zoom_changed_callbacks_.Notify();
   if (zoom_event_manager_)
     zoom_event_manager_->OnDefaultZoomLevelChanged();
+#endif
 }
 
 double ChromeZoomLevelPrefs::GetDefaultZoomLevelPref() const {
   double default_zoom_level = 0.0;
 
-  const base::DictionaryValue* default_zoom_level_dictionary =
-      pref_service_->GetDictionary(prefs::kPartitionDefaultZoomLevel);
-  // If no default has been previously set, the default returned is the
-  // value used to initialize default_zoom_level in this function.
-  default_zoom_level_dictionary->GetDouble(partition_key_, &default_zoom_level);
   return default_zoom_level;
 }
 
@@ -219,26 +216,4 @@ void ChromeZoomLevelPrefs::ExtractPerHostZoomLevels(
 void ChromeZoomLevelPrefs::InitHostZoomMap(
     content::HostZoomMap* host_zoom_map) {
   // This init function must be called only once.
-  DCHECK(!host_zoom_map_);
-  DCHECK(host_zoom_map);
-  host_zoom_map_ = host_zoom_map;
-
-  // Initialize the default zoom level.
-  host_zoom_map_->SetDefaultZoomLevel(GetDefaultZoomLevelPref());
-
-  // Initialize the HostZoomMap with per-host zoom levels from the persisted
-  // zoom-level preference values.
-  const base::DictionaryValue* host_zoom_dictionaries =
-      pref_service_->GetDictionary(prefs::kPartitionPerHostZoomLevels);
-  const base::DictionaryValue* host_zoom_dictionary = nullptr;
-  if (host_zoom_dictionaries->GetDictionary(partition_key_,
-                                            &host_zoom_dictionary)) {
-    // Since we're calling this before setting up zoom_subscription_ below we
-    // don't need to worry that host_zoom_dictionary is indirectly affected
-    // by calls to HostZoomMap::SetZoomLevelForHost().
-    ExtractPerHostZoomLevels(host_zoom_dictionary,
-                             true /* sanitize_partition_host_zoom_levels */);
-  }
-  zoom_subscription_ = host_zoom_map_->AddZoomLevelChangedCallback(base::Bind(
-      &ChromeZoomLevelPrefs::OnZoomLevelChanged, base::Unretained(this)));
 }
diff --git a/chrome/browser/web_applications/BUILD.gn b/chrome/browser/web_applications/BUILD.gn
index 767ce88329cc..5fe1aa2771f9 100644
--- a/chrome/browser/web_applications/BUILD.gn
+++ b/chrome/browser/web_applications/BUILD.gn
@@ -153,7 +153,6 @@ source_set("web_applications_unit_tests") {
     "//chrome/browser",
     "//chrome/browser/web_applications/components",
     "//chrome/common",
-    "//chrome/test:test_support",
     "//content/public/browser",
     "//content/test:test_support",
     "//skia",
@@ -184,8 +183,6 @@ source_set("web_applications_browser_tests") {
     ":web_applications",
     ":web_applications_test_support",
     "//chrome/browser/web_applications/components",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
   ]
 }
 
diff --git a/chrome/browser/web_applications/components/BUILD.gn b/chrome/browser/web_applications/components/BUILD.gn
index 9dd348c9ffdd..360debd54e68 100644
--- a/chrome/browser/web_applications/components/BUILD.gn
+++ b/chrome/browser/web_applications/components/BUILD.gn
@@ -162,7 +162,6 @@ source_set("unit_tests") {
     "//chrome/app/theme:theme_resources",
     "//chrome/browser/web_applications:web_app_test_group",
     "//chrome/browser/web_applications:web_applications_test_support",
-    "//chrome/test:test_support",
     "//content/public/browser",
     "//skia",
     "//testing/gmock",
@@ -188,8 +187,6 @@ source_set("browser_tests") {
     ":components",
     "//chrome/app:command_ids",
     "//chrome/browser/web_applications:web_applications_test_support",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
     "//net:test_support",
   ]
 }
diff --git a/chrome/browser/web_applications/components/web_app_shortcut_android.cc b/chrome/browser/web_applications/components/web_app_shortcut_android.cc
new file mode 100644
index 000000000000..2bc376fe891e
--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.cc
@@ -0,0 +1,122 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/web_applications/components/web_app_shortcut_android.h"
+
+#include <fcntl.h>
+
+#include "base/base_paths.h"
+#include "base/environment.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/i18n/file_util_icu.h"
+#include "base/nix/xdg_util.h"
+#include "base/path_service.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/process/kill.h"
+#include "base/process/launch.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "chrome/browser/shell_integration.h"
+#include "chrome/browser/web_applications/components/web_app_helpers.h"
+#include "chrome/browser/web_applications/components/web_app_shortcut.h"
+#include "chrome/common/buildflags.h"
+#include "chrome/common/chrome_constants.h"
+
+namespace {
+
+#if BUILDFLAG(ENABLE_APP_LIST)
+// The Categories for the App Launcher desktop shortcut. Should be the same as
+// the Chrome desktop shortcut, so they are in the same sub-menu.
+const char kAppListCategories[] = "Network;WebBrowser;";
+#endif
+
+}  // namespace
+
+namespace web_app {
+
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id) {
+  DCHECK(!app_id.empty());
+
+  // Use a prefix, because xdg-desktop-menu requires it.
+  std::string filename(chrome::kBrowserProcessExecutableName);
+  filename.append("-").append(app_id).append("-").append(
+      profile_path.BaseName().value());
+  base::i18n::ReplaceIllegalCharactersInPath(&filename, '_');
+  // Spaces in filenames break xdg-desktop-menu
+  // (see https://bugs.freedesktop.org/show_bug.cgi?id=66605).
+  base::ReplaceChars(filename, " ", "_", &filename);
+  return base::FilePath(filename.append(".desktop"));
+}
+
+void DeleteShortcutOnDesktop(const base::FilePath& shortcut_filename) {
+}
+
+void DeleteShortcutInApplicationsMenu(
+    const base::FilePath& shortcut_filename,
+    const base::FilePath& directory_filename) {
+}
+
+bool CreateDesktopShortcut(
+    const web_app::ShortcutInfo& shortcut_info,
+    const web_app::ShortcutLocations& creation_locations) {
+  return false;
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id) {
+  base::FilePath desktop_path;
+  // If Get returns false, just leave desktop_path empty.
+  base::PathService::Get(base::DIR_USER_DESKTOP, &desktop_path);
+  return GetExistingShortcutLocations(env, profile_path, extension_id,
+                                      desktop_path);
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  web_app::ShortcutLocations locations;
+  return locations;
+}
+
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id) {
+}
+
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path) {
+}
+
+namespace internals {
+
+bool CreatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutLocations& creation_locations,
+                             ShortcutCreationReason /*creation_reason*/,
+                             const ShortcutInfo& shortcut_info) {
+  return false;
+}
+
+void DeletePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void UpdatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const base::string16& /*old_app_title*/,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void DeleteAllShortcutsForProfile(const base::FilePath& profile_path) {
+}
+
+}  // namespace internals
+
+}  // namespace web_app
diff --git a/chrome/browser/web_applications/components/web_app_shortcut_android.h b/chrome/browser/web_applications/components/web_app_shortcut_android.h
new file mode 100644
index 000000000000..7ffccdf1fa46
--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.h
@@ -0,0 +1,62 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+#define CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+
+#include <string>
+
+namespace base {
+class FilePath;
+class Environment;
+}  // namespace base
+
+namespace web_app {
+
+struct ShortcutInfo;
+struct ShortcutLocations;
+
+// Create shortcuts on the desktop or in the application menu (as specified by
+// |shortcut_info|), for the web page or extension in |shortcut_info|.
+// For extensions, duplicate shortcuts are avoided, so if a requested shortcut
+// already exists it is deleted first.
+bool CreateDesktopShortcut(const ShortcutInfo& shortcut_info,
+                           const ShortcutLocations& creation_locations);
+
+// Returns filename for .desktop file based on |profile_path| and
+// |app_id|, sanitized for security.
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id);
+
+// Returns the set of locations in which shortcuts are installed for the
+// extension with |extension_id| in |profile_path|.
+// This searches the file system for .desktop files in appropriate locations. A
+// shortcut with NoDisplay=true causes hidden to become true, instead of
+// creating at APP_MENU_LOCATIONS_SUBDIR_CHROMEAPPS.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id);
+
+// Version of GetExistingShortcutLocations which takes an explicit path
+// to the user's desktop directory. Useful for testing.
+// If |desktop_path| is empty, the desktop is not searched.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// been added for the extension with |extension_id| in |profile_path|.
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// for the profile in |profile_path|.
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path);
+
+}  // namespace web_app
+
+#endif  // CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
diff --git a/chrome/browser/web_applications/extensions/BUILD.gn b/chrome/browser/web_applications/extensions/BUILD.gn
index bcebc3167309..5e4c6029424a 100644
--- a/chrome/browser/web_applications/extensions/BUILD.gn
+++ b/chrome/browser/web_applications/extensions/BUILD.gn
@@ -66,7 +66,6 @@ source_set("unit_tests") {
     "//chrome/browser/web_applications:web_applications_test_support",
     "//chrome/browser/web_applications/components",
     "//chrome/common",
-    "//chrome/test:test_support",
     "//components/crx_file:crx_file",
     "//content/public/browser",
     "//content/test:test_support",
@@ -101,8 +100,6 @@ source_set("browser_tests") {
     "//chrome/browser/web_applications:web_applications_on_extensions_test_support",
     "//chrome/browser/web_applications:web_applications_test_support",
     "//chrome/browser/web_applications/components",
-    "//chrome/test:test_support",
-    "//chrome/test:test_support_ui",
     "//extensions:test_support",
     "//extensions/browser",
     "//extensions/common",
diff --git a/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc b/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
index 17450e25fcec..b72965362986 100644
--- a/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
+++ b/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
@@ -93,12 +93,14 @@ void UpdateAllShortcutsForShortcutInfo(
     const base::string16& old_app_title,
     base::OnceClosure callback,
     std::unique_ptr<ShortcutInfo> shortcut_info) {
+#if 0
   base::FilePath shortcut_data_dir =
       internals::GetShortcutDataDir(*shortcut_info);
   internals::PostShortcutIOTaskAndReply(
       base::BindOnce(&internals::UpdatePlatformShortcuts,
                      std::move(shortcut_data_dir), old_app_title),
       std::move(shortcut_info), std::move(callback));
+#endif
 }
 
 }  // namespace
@@ -253,14 +255,6 @@ void CreateShortcuts(ShortcutCreationReason reason,
 
 void DeleteAllShortcuts(Profile* profile, const extensions::Extension* app) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  std::unique_ptr<ShortcutInfo> shortcut_info(
-      ShortcutInfoForExtensionAndProfile(app, profile));
-  base::FilePath shortcut_data_dir =
-      internals::GetShortcutDataDir(*shortcut_info);
-  internals::PostShortcutIOTask(
-      base::BindOnce(&internals::DeletePlatformShortcuts, shortcut_data_dir),
-      std::move(shortcut_info));
 }
 
 void UpdateAllShortcuts(const base::string16& old_app_title,
diff --git a/chrome/browser/web_applications/web_app_android.cc b/chrome/browser/web_applications/web_app_android.cc
new file mode 100644
index 000000000000..4845c0cacf57
--- /dev/null
+++ b/chrome/browser/web_applications/web_app_android.cc
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/web_applications/web_app.h"
+
+#include <utility>
+
+#include "base/environment.h"
+#include "base/logging.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "chrome/browser/shell_integration_linux.h"
+
+namespace web_app {
+
+void UpdateShortcutsForAllApps(Profile* profile,
+                               const base::Closure& callback) {
+}
+
+namespace internals {
+
+bool CreatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutLocations& creation_locations,
+                             ShortcutCreationReason /*creation_reason*/,
+                             const ShortcutInfo& shortcut_info) {
+  return false;
+}
+
+void DeletePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void UpdatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const base::string16& /*old_app_title*/,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void DeleteAllShortcutsForProfile(const base::FilePath& profile_path) {
+}
+
+}  // namespace internals
+
+}  // namespace web_app
diff --git a/chrome/chrome_paks.gni b/chrome/chrome_paks.gni
index 6469473e6a79..65bd14505dc4 100644
--- a/chrome/chrome_paks.gni
+++ b/chrome/chrome_paks.gni
@@ -121,7 +121,7 @@ template("chrome_extra_paks") {
       sources += invoker.additional_paks
     }
 
-    if (!is_android) {
+    if (true || !is_android) {
       # New paks should be added here by default.
       sources += [
         "$root_gen_dir/chrome/bookmarks_resources.pak",
diff --git a/chrome/common/BUILD.gn b/chrome/common/BUILD.gn
index 76d1a2aaa9e2..c19894df3e6e 100644
--- a/chrome/common/BUILD.gn
+++ b/chrome/common/BUILD.gn
@@ -427,7 +427,8 @@ static_library("common") {
       "media/chrome_media_drm_bridge_client.cc",
       "media/chrome_media_drm_bridge_client.h",
     ]
-  } else {
+  }
+  if (true) {
     # Non-Android.
     public_deps += [ "//chrome/common/importer" ]
   }
diff --git a/chrome/common/chrome_features.cc b/chrome/common/chrome_features.cc
index 92da6a9b69af..0beef57a2ce3 100644
--- a/chrome/common/chrome_features.cc
+++ b/chrome/common/chrome_features.cc
@@ -61,7 +61,7 @@ const base::Feature kAppNotificationStatusMessaging{
     "AppNotificationStatusMessaging", base::FEATURE_DISABLED_BY_DEFAULT};
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // App Service related flags. See chrome/services/app_service/README.md.
 const base::Feature kAppServiceInstanceRegistry{
     "AppServiceInstanceRegistry", base::FEATURE_DISABLED_BY_DEFAULT};
@@ -345,7 +345,7 @@ const base::Feature kEnableAmbientAuthenticationInGuestSession{
     "EnableAmbientAuthenticationInGuestSession",
     base::FEATURE_ENABLED_BY_DEFAULT};
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Upload enterprise cloud reporting without the extension.
 const base::Feature kEnterpriseReportingInBrowser{
     "EnterpriseReportingInBrowser", base::FEATURE_DISABLED_BY_DEFAULT};
@@ -423,7 +423,7 @@ const base::Feature kHappinessTrackingSystem{"HappinessTrackingSystem",
                                              base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Enables or disables the Happiness Tracking System for Desktop Chrome.
 const base::Feature kHappinessTrackingSurveysForDesktop{
     "HappinessTrackingSurveysForDesktop", base::FEATURE_DISABLED_BY_DEFAULT};
@@ -524,14 +524,7 @@ const base::Feature kAcknowledgeNtpOverrideOnDeactivate{
     "AcknowledgeNtpOverrideOnDeactivate", base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
 
-// Enables showing an entry for mixed content in site settings, which controls
-// allowing blockable mixed content. When enabled, the mixed content shield is
-// not shown on the omnibox, since its functionality is replaced by the
-// setting.
-const base::Feature kMixedContentSiteSetting{"MixedContentSiteSetting",
-                                             base::FEATURE_DISABLED_BY_DEFAULT};
-
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 const base::Feature kOnConnectNative{"OnConnectNative",
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
diff --git a/chrome/common/chrome_features.h b/chrome/common/chrome_features.h
index dece93c2ac41..842f6aab723f 100644
--- a/chrome/common/chrome_features.h
+++ b/chrome/common/chrome_features.h
@@ -51,7 +51,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kAppNotificationStatusMessaging;
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kAppServiceInstanceRegistry;
 COMPONENT_EXPORT(CHROME_FEATURES)
@@ -189,7 +189,7 @@ extern const base::Feature kEnableAmbientAuthenticationInGuestSession;
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kEnableAmbientAuthenticationInIncognito;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kEnterpriseReportingInBrowser;
 #endif
@@ -257,7 +257,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kHappinessTrackingSystem;
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kHappinessTrackingSurveysForDesktop;
 
@@ -326,7 +326,7 @@ extern const base::Feature kAcknowledgeNtpOverrideOnDeactivate;
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kMixedContentSiteSetting;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES) extern const base::Feature kOnConnectNative;
 #endif
 
diff --git a/chrome/common/chrome_paths.cc b/chrome/common/chrome_paths.cc
index 1ca92ba2c97c..cfc50aef8875 100644
--- a/chrome/common/chrome_paths.cc
+++ b/chrome/common/chrome_paths.cc
@@ -545,7 +545,7 @@ bool PathProvider(int key, base::FilePath* result) {
 #endif
       break;
 
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if true || defined(OS_LINUX) || defined(OS_MACOSX)
     case chrome::DIR_NATIVE_MESSAGING:
 #if defined(OS_MACOSX)
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
diff --git a/chrome/common/chrome_paths.h b/chrome/common/chrome_paths.h
index 3f73d868b54e..3be451fbc0da 100644
--- a/chrome/common/chrome_paths.h
+++ b/chrome/common/chrome_paths.h
@@ -122,7 +122,7 @@ enum {
   DIR_SUPERVISED_USER_INSTALLED_WHITELISTS,  // Directory where sanitized
                                              // supervised user whitelists are
                                              // installed.
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if true || defined(OS_LINUX) || defined(OS_MACOSX)
   DIR_NATIVE_MESSAGING,       // System directory where native messaging host
                               // manifest files are stored.
   DIR_USER_NATIVE_MESSAGING,  // Directory with Native Messaging Hosts
diff --git a/chrome/common/chrome_switches.cc b/chrome/common/chrome_switches.cc
index 1af109002ed5..40e5cc9de0c1 100644
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -868,7 +868,7 @@ const char kAllowNaClFileHandleAPI[]        = "allow-nacl-file-handle-api";
 const char kAllowNaClSocketAPI[]            = "allow-nacl-socket-api";
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || true
 const char kEnableNewAppMenuIcon[] = "enable-new-app-menu-icon";
 
 // Causes the browser to launch directly in guest mode.
diff --git a/chrome/common/chrome_switches.h b/chrome/common/chrome_switches.h
index 16b22add7446..1c7266bd7936 100644
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -266,7 +266,7 @@ extern const char kAllowNaClFileHandleAPI[];
 extern const char kAllowNaClSocketAPI[];
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || true
 extern const char kEnableNewAppMenuIcon[];
 extern const char kGuest[];
 #endif
diff --git a/chrome/common/extensions/api/api_sources.gni b/chrome/common/extensions/api/api_sources.gni
index 582dd954152b..21c82271deab 100644
--- a/chrome/common/extensions/api/api_sources.gni
+++ b/chrome/common/extensions/api/api_sources.gni
@@ -72,7 +72,7 @@ schema_sources_ = [
   "windows.json",
 ]
 
-if (!is_android) {
+if (true || !is_android) {
   schema_sources_ += [ "processes.idl" ]
 }
 
diff --git a/chrome/common/features.gni b/chrome/common/features.gni
index d3939aa0de92..6e00e2bcfc05 100644
--- a/chrome/common/features.gni
+++ b/chrome/common/features.gni
@@ -30,8 +30,8 @@ declare_args() {
   builtin_cert_verifier_policy_supported = is_chromeos || is_desktop_linux
 
   # Enables support for background apps.
-  enable_background_contents = !is_android && !is_chromecast
-  enable_background_mode = !is_android && !is_chromecast && !is_chromeos
+  enable_background_contents = !is_chromecast
+  enable_background_mode = !is_chromecast && !is_chromeos
 
   # Enable the printing system dialog for platforms that support printing
   # and have a system dialog.
diff --git a/chrome/common/pref_names.cc b/chrome/common/pref_names.cc
index 59e7a98db766..619f1210ca39 100644
--- a/chrome/common/pref_names.cc
+++ b/chrome/common/pref_names.cc
@@ -1031,7 +1031,7 @@ const char kSpeechRecognitionFilterProfanities[] =
 // permitted.
 const char kAllowDeletingBrowserHistory[] = "history.deleting_enabled";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Whether the "Click here to clear your browsing data" tooltip promo has been
 // shown on the History page.
 const char kHistoryMenuPromoShown[] = "history.menu_promo_shown";
@@ -1188,7 +1188,7 @@ const char kContentSettingsPluginWhitelist[] =
     "profile.content_settings.plugin_whitelist";
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Double that indicates the default zoom level.
 const char kPartitionDefaultZoomLevel[] = "partition.default_zoom_level";
 
@@ -1466,7 +1466,7 @@ const char kWebRtcEventLogCollectionAllowed[] = "webrtc.event_logs_collection";
 // in ICE candidates.
 const char kWebRtcLocalIpsAllowedUrls[] = "webrtc.local_ips_allowed_urls";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Whether or not this profile has been shown the Welcome page.
 const char kHasSeenWelcomePage[] = "browser.has_seen_welcome_page";
 #endif
@@ -1635,7 +1635,7 @@ const char kDefaultTasksBySuffix[] =
 // send text across devices.
 const char kSharedClipboardEnabled[] = "browser.shared_clipboard_enabled";
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 // A flag to enable/disable the Click to Call feature which enables users to
 // send phone numbers from desktop to Android phones.
 const char kClickToCallEnabled[] = "browser.click_to_call_enabled";
@@ -1669,7 +1669,7 @@ const char kShutdownNumProcessesSlow[] = "shutdown.num_processes_slow";
 // before shutting everything down.
 const char kRestartLastSessionOnShutdown[] = "restart.last.session.on.shutdown";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 // Pref name for the policy controlling presentation of full-tab promotional
 // and/or educational content.
@@ -1712,7 +1712,7 @@ const char kNtpCollapsedSnapshotDocument[] = "ntp.collapsed_snapshot_document";
 
 // Keeps track of sync promo collapsed state in the Other Devices menu.
 const char kNtpCollapsedSyncPromo[] = "ntp.collapsed_sync_promo";
-#else
+
 // Holds info for New Tab Page custom background
 const char kNtpCustomBackgroundDict[] = "ntp.custom_background_dict";
 const char kNtpCustomBackgroundLocalToDevice[] =
@@ -1779,7 +1779,7 @@ const char kDevToolsTCPDiscoveryConfig[] = "devtools.tcp_discovery_config";
 // A dictionary with generic DevTools settings.
 const char kDevToolsPreferences[] = "devtools.preferences";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Tracks the number of times the dice signin promo has been shown in the user
 // menu.
 const char kDiceSigninUserMenuPromoCount[] = "sync_promo.user_menu_show_count";
@@ -2276,13 +2276,13 @@ const char kSystemTimezoneAutomaticDetectionPolicy[] =
 
 // Pref name for the policy controlling whether to enable Media Router.
 const char kEnableMediaRouter[] = "media_router.enable_media_router";
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Pref name for the policy controlling whether to force the Cast icon to be
 // shown in the toolbar/overflow menu.
 const char kShowCastIconInToolbar[] = "media_router.show_cast_icon_in_toolbar";
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Pref name for the policy controlling the way in which users are notified of
 // the need to relaunch the browser for a pending update.
 const char kRelaunchNotification[] = "browser.relaunch_notification";
@@ -2395,7 +2395,7 @@ const char kCustomHandlersEnabled[] = "custom_handlers.enabled";
 // by the cloud policy subsystem.
 const char kDevicePolicyRefreshRate[] = "policy.device_refresh_rate";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // A boolean where true means that the browser has previously attempted to
 // enable autoupdate and failed, so the next out-of-date browser start should
 // not prompt the user to enable autoupdate, it should offer to reinstall Chrome
@@ -2524,7 +2524,7 @@ const char kRecoveryComponentNeedsElevation[] =
 const char kRegisteredSupervisedUserWhitelists[] =
     "supervised_users.whitelists";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Boolean that indicates whether Chrome enterprise cloud reporting is enabled
 // or not.
 const char kCloudReportingEnabled[] =
@@ -2791,7 +2791,7 @@ const char kSitePerProcess[] = "site_isolation.site_per_process";
 const char kUserTriggeredIsolatedOrigins[] =
     "site_isolation.user_triggered_isolated_origins";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Boolean that specifies whether media (audio/video) autoplay is allowed.
 const char kAutoplayAllowed[] = "media.autoplay_allowed";
 
@@ -2863,7 +2863,7 @@ const char kSharingSyncedDevices[] = "sharing.synced_devices";
 const char kSharingFCMRegistration[] = "sharing.fcm_registration";
 const char kSharingLocalSharingInfo[] = "sharing.local_sharing_info";
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // Dictionary that contains all of the Hats Survey Metadata.
 const char kHatsSurveyMetadata[] = "hats.survey_metadata";
 #endif  // !defined(OS_ANDROID)
diff --git a/chrome/common/pref_names.h b/chrome/common/pref_names.h
index 1da0029dfe92..8f7622c230ea 100644
--- a/chrome/common/pref_names.h
+++ b/chrome/common/pref_names.h
@@ -325,7 +325,7 @@ extern const char kDeviceLoginScreenWebUsbAllowDevicesForUrls[];
 extern const char kShowHomeButton[];
 extern const char kSpeechRecognitionFilterProfanities[];
 extern const char kAllowDeletingBrowserHistory[];
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kHistoryMenuPromoShown[];
 #endif
 extern const char kForceGoogleSafeSearch[];
@@ -368,7 +368,7 @@ extern const char kUseCustomChromeFrame[];
 #if BUILDFLAG(ENABLE_PLUGINS)
 extern const char kContentSettingsPluginWhitelist[];
 #endif
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kPartitionDefaultZoomLevel[];
 extern const char kPartitionPerHostZoomLevels[];
 
@@ -474,7 +474,7 @@ extern const char kWebRTCUDPPortRange[];
 extern const char kWebRtcEventLogCollectionAllowed[];
 extern const char kWebRtcLocalIpsAllowedUrls[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kHasSeenWelcomePage[];
 #endif
 
@@ -544,7 +544,7 @@ extern const char kDefaultTasksBySuffix[];
 
 extern const char kSharedClipboardEnabled[];
 
-#if BUILDFLAG(ENABLE_CLICK_TO_CALL)
+#if BUILDFLAG(ENABLE_CLICK_TO_CALL) || true
 extern const char kClickToCallEnabled[];
 #endif  // BUILDFLAG(ENABLE_CLICK_TO_CALL)
 
@@ -560,7 +560,7 @@ extern const char kShutdownNumProcesses[];
 extern const char kShutdownNumProcessesSlow[];
 
 extern const char kRestartLastSessionOnShutdown[];
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 extern const char kPromotionalTabsEnabled[];
 extern const char kCommandLineFlagSecurityWarningsEnabled[];
@@ -577,7 +577,7 @@ extern const char kNtpCollapsedForeignSessions[];
 extern const char kNtpCollapsedRecentlyClosedTabs[];
 extern const char kNtpCollapsedSnapshotDocument[];
 extern const char kNtpCollapsedSyncPromo[];
-#else
+
 extern const char kNtpCustomBackgroundDict[];
 extern const char kNtpCustomBackgroundLocalToDevice[];
 extern const char kNtpPromoBlocklist[];
@@ -602,7 +602,7 @@ extern const char kDevToolsPreferences[];
 extern const char kDevToolsDiscoverTCPTargetsEnabled[];
 extern const char kDevToolsTCPDiscoveryConfig[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kDiceSigninUserMenuPromoCount[];
 #endif
 
@@ -795,11 +795,11 @@ extern const char kSystemTimezoneAutomaticDetectionPolicy[];
 #endif  // defined(OS_CHROMEOS)
 
 extern const char kEnableMediaRouter[];
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kShowCastIconInToolbar[];
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kRelaunchNotification[];
 extern const char kRelaunchNotificationPeriod[];
 #endif  // !defined(OS_ANDROID)
@@ -808,7 +808,7 @@ extern const char kRelaunchNotificationPeriod[];
 extern const char kRelaunchHeadsUpPeriod[];
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kAttemptedToEnableAutoupdate[];
 
 extern const char kMediaGalleriesUniqueId[];
@@ -858,7 +858,7 @@ extern const char kRecoveryComponentNeedsElevation[];
 
 extern const char kRegisteredSupervisedUserWhitelists[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kCloudReportingEnabled[];
 extern const char kCloudExtensionRequestEnabled[];
 extern const char kCloudExtensionRequestIds[];
@@ -968,7 +968,7 @@ extern const char kIsolateOrigins[];
 extern const char kSitePerProcess[];
 extern const char kUserTriggeredIsolatedOrigins[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kAutoplayAllowed[];
 extern const char kAutoplayWhitelist[];
 extern const char kBlockAutoplayEnabled[];
@@ -1005,7 +1005,7 @@ extern const char kSharingSyncedDevices[];
 extern const char kSharingFCMRegistration[];
 extern const char kSharingLocalSharingInfo[];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 extern const char kHatsSurveyMetadata[];
 #endif  // !defined(OS_ANDROID)
 
diff --git a/chrome/common/url_constants.cc b/chrome/common/url_constants.cc
index ce5309843e4f..d6d843c482dc 100644
--- a/chrome/common/url_constants.cc
+++ b/chrome/common/url_constants.cc
@@ -381,12 +381,12 @@ const char kWindowsXPVistaDeprecationURL[] =
     "https://chrome.blogspot.com/2015/11/updates-to-chrome-platform-support.html";
 #endif
 
-#if BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
+#if true || BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
 const char kChromeSyncLearnMoreURL[] =
     "https://support.google.com/chrome/answer/165139";
 #endif  // BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
 const char kBlockedPluginLearnMoreURL[] =
     "https://support.google.com/chrome/?p=ib_blocked_plugin";
 
diff --git a/chrome/common/url_constants.h b/chrome/common/url_constants.h
index 7791697d1afb..5a8b1a6b62a9 100644
--- a/chrome/common/url_constants.h
+++ b/chrome/common/url_constants.h
@@ -341,12 +341,12 @@ extern const char kChromeCleanerLearnMoreURL[];
 extern const char kWindowsXPVistaDeprecationURL[];
 #endif
 
-#if BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
+#if true || BUILDFLAG(ENABLE_ONE_CLICK_SIGNIN)
 // "Learn more" URL for the one click signin infobar.
 extern const char kChromeSyncLearnMoreURL[];
 #endif
 
-#if BUILDFLAG(ENABLE_PLUGINS)
+#if true || BUILDFLAG(ENABLE_PLUGINS)
 // The URL for the "Learn more" page for the blocked plugin infobar.
 extern const char kBlockedPluginLearnMoreURL[];
 
diff --git a/chrome/common/webui_url_constants.cc b/chrome/common/webui_url_constants.cc
index 5885ecf4bc99..91e75ccdc979 100644
--- a/chrome/common/webui_url_constants.cc
+++ b/chrome/common/webui_url_constants.cc
@@ -316,7 +316,7 @@ bool IsSystemWebUIHost(base::StringPiece host) {
 const char kChromeUICastHost[] = "cast";
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || true
 const char kChromeUIDiscardsHost[] = "discards";
 const char kChromeUIDiscardsURL[] = "chrome://discards/";
 const char kChromeUIHatsHost[] = "hats";
@@ -332,7 +332,7 @@ const char kChromeUISandboxHost[] = "sandbox";
 #endif
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || true
 const char kChromeUIBrowserSwitchHost[] = "browser-switch";
 const char kChromeUIBrowserSwitchURL[] = "chrome://browser-switch/";
 #endif
diff --git a/chrome/common/webui_url_constants.h b/chrome/common/webui_url_constants.h
index 8618c9d0b341..54ba7f26ec04 100644
--- a/chrome/common/webui_url_constants.h
+++ b/chrome/common/webui_url_constants.h
@@ -274,7 +274,7 @@ bool IsSystemWebUIHost(base::StringPiece host);
 extern const char kChromeUICastHost[];
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || true
 extern const char kChromeUIDiscardsHost[];
 extern const char kChromeUIDiscardsURL[];
 extern const char kChromeUIHatsHost[];
@@ -291,7 +291,7 @@ extern const char kChromeUISandboxHost[];
 #endif
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || true
 extern const char kChromeUIBrowserSwitchHost[];
 extern const char kChromeUIBrowserSwitchURL[];
 #endif
diff --git a/chrome/renderer/chrome_content_renderer_client.cc b/chrome/renderer/chrome_content_renderer_client.cc
index ffde51cd276a..e93d7f574efc 100644
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -634,7 +634,7 @@ bool ChromeContentRendererClient::IsPluginHandledExternally(
     const blink::WebElement& plugin_element,
     const GURL& original_url,
     const std::string& mime_type) {
-#if BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PLUGINS)
+#if false && BUILDFLAG(ENABLE_EXTENSIONS) && BUILDFLAG(ENABLE_PLUGINS)
   DCHECK(plugin_element.HasHTMLTagName("object") ||
          plugin_element.HasHTMLTagName("embed"));
   // Blink will next try to load a WebPlugin which would end up in
diff --git a/chrome/renderer/media/chrome_key_systems.cc b/chrome/renderer/media/chrome_key_systems.cc
index b1c800648c70..61d8af548ec9 100644
--- a/chrome/renderer/media/chrome_key_systems.cc
+++ b/chrome/renderer/media/chrome_key_systems.cc
@@ -329,7 +329,7 @@ void AddChromeKeySystems(
 
 #endif  // BUILDFLAG(ENABLE_LIBRARY_CDMS)
 
-#if defined(OS_ANDROID)
+#if BUILDFLAG(ENABLE_WIDEVINE) and defined(OS_ANDROID)
   cdm::AddAndroidWidevine(key_systems_properties);
 #endif  // defined(OS_ANDROID)
 }
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 492c4d805d60..466755a23a83 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -4313,7 +4313,7 @@ test("unit_tests") {
     }
   }
 
-  if (enable_extensions) {
+  if (false && enable_extensions) {
     sources += [
       "../../apps/saved_files_service_unittest.cc",
       "../../tools/json_schema_compiler/test/features_generation_unittest.cc",
diff --git a/chromecast/browser/cast_browser_context.cc b/chromecast/browser/cast_browser_context.cc
index 90dad23b3713..efa9fbd77f57 100644
--- a/chromecast/browser/cast_browser_context.cc
+++ b/chromecast/browser/cast_browser_context.cc
@@ -81,7 +81,7 @@ void CastBrowserContext::InitWhileIOAllowed() {
   BrowserContext::Initialize(this, path_);
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 CastBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
diff --git a/chromecast/browser/cast_browser_context.h b/chromecast/browser/cast_browser_context.h
index 7b0b36c8e0fd..dc1fdbb634aa 100644
--- a/chromecast/browser/cast_browser_context.h
+++ b/chromecast/browser/cast_browser_context.h
@@ -25,7 +25,7 @@ class CastBrowserContext final : public content::BrowserContext {
   ~CastBrowserContext() override;
 
   // BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
diff --git a/components/autofill_payments_strings.grdp b/components/autofill_payments_strings.grdp
index 594ca8cbbceb..526f3a0625cf 100644
--- a/components/autofill_payments_strings.grdp
+++ b/components/autofill_payments_strings.grdp
@@ -68,7 +68,7 @@
     </if>
   </if>
 
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_AUTOFILL_FIELD_LABEL_PHONE" desc="The label of the Phone entry in a settings-like UI to enter a phone number.">
       Phone
     </message>
@@ -79,19 +79,15 @@
 
   <!-- Autofill save credit card bubble or infobar prompt -->
   <if expr="is_android or is_ios">
-    <then>
       <message name="IDS_AUTOFILL_SAVE_CARD_INFOBAR_ACCEPT" desc="Text to show for the Autofill save credit card infobar accept button.">
         Save
       </message>
-    </then>
-    <else>
       <message name="IDS_AUTOFILL_SAVE_CARD_BUBBLE_LOCAL_SAVE_ACCEPT" desc="Text to show for the Autofill save credit card local save bubble accept button.">
         Save
       </message>
       <message name="IDS_AUTOFILL_SAVE_CARD_BUBBLE_UPLOAD_SAVE_ACCEPT" desc="Text to show for the Autofill save credit card upload save bubble accept button.">
         Save
       </message>
-    </else>
   </if>
   <if expr="is_android">
     <message name="IDS_AUTOFILL_SAVE_CARD_PROMPT_CONFIRM" desc="Text to show for the Autofill upload save credit card prompt accept button when more information (e.g., CVC) was needed in order to save the card and was entered." formatter_data="android_java">
@@ -202,7 +198,7 @@
   </message>
 
   <!-- Autofill Local card migration bubble or dialog -->
-  <if expr="not is_ios and not is_android">
+  <if expr="is_android or not is_ios and not is_android">
     <message name="IDS_AUTOFILL_GOOGLE_PAY_LOGO_ACCESSIBLE_NAME" desc="The accessible name for the Google Pay logo in the local card migration bubble or dialog.">
       Google Pay logo
     </message>
@@ -406,7 +402,7 @@
 
   <!-- WebAuthn fingerprint opt-in dialog -->
   <!-- Desktop only -->
-  <if expr="not is_ios and not is_android">
+  <if expr="is_android or not is_ios and not is_android">
     <if expr="is_macosx">
       <message name="IDS_AUTOFILL_WEBAUTHN_OPT_IN_DIALOG_TITLE" desc="Headline asking the user if they want to use their device's platform authenticator to confirm their cards in the future instead of CVC.">
         Use Touch ID instead of CVC?
@@ -462,7 +458,7 @@
 
   <!-- Webauthn verify pending dialog -->
   <!-- Desktop only -->
-  <if expr="not is_ios and not is_android">
+  <if expr="is_android or not is_ios and not is_android">
     <message name="IDS_AUTOFILL_WEBAUTHN_VERIFY_PENDING_DIALOG_TITLE" desc="Headline of the dialog shown when user has opted in to use platform biometric authenticator and has selected one card to fill the form. This shows the verification of the selected card is in progress.">
         Verifying your identity...
     </message>
diff --git a/components/autofill_strings.grdp b/components/autofill_strings.grdp
index 5c3061f09013..7a8e00c80eec 100644
--- a/components/autofill_strings.grdp
+++ b/components/autofill_strings.grdp
@@ -165,7 +165,7 @@
     Show cards from your Google Account
   </message>
 
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_AUTOFILL_POPUP_ACCESSIBLE_NODE_DATA" desc="The accessibility text to speak when we display an autofill popup.">
       Autofill
     </message>
diff --git a/components/bookmarks/browser/BUILD.gn b/components/bookmarks/browser/BUILD.gn
index a28dfd2b6ea4..d172f2c558d5 100644
--- a/components/bookmarks/browser/BUILD.gn
+++ b/components/bookmarks/browser/BUILD.gn
@@ -80,7 +80,7 @@ static_library("browser") {
     all_dependent_configs = [ "//ui/views:flags" ]
   }
 
-  if (toolkit_views && !is_mac) {
+  if (true || (toolkit_views && !is_mac)) {
     sources += [ "bookmark_node_data_views.cc" ]
   }
 
diff --git a/components/bookmarks/browser/bookmark_node_data.h b/components/bookmarks/browser/bookmark_node_data.h
index fa46f3c18d01..a8caa07dc8d0 100644
--- a/components/bookmarks/browser/bookmark_node_data.h
+++ b/components/bookmarks/browser/bookmark_node_data.h
@@ -18,7 +18,7 @@
 #include "ui/base/clipboard/clipboard_buffer.h"
 #include "url/gurl.h"
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
 #include "ui/base/clipboard/clipboard_format_type.h"
 #endif
 
@@ -27,7 +27,7 @@ class Pickle;
 class PickleIterator;
 }
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
 namespace ui {
 class OSExchangeData;
 }
@@ -114,7 +114,7 @@ struct BookmarkNodeData {
 
   ~BookmarkNodeData();
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
   static const ui::ClipboardFormatType& GetBookmarkFormatType();
 #endif
 
@@ -133,7 +133,7 @@ struct BookmarkNodeData {
   // WriteToClipboard() but will also attempt to read a plain bookmark.
   bool ReadFromClipboard(ui::ClipboardBuffer buffer);
 
-#if defined(TOOLKIT_VIEWS)
+#if true || defined(TOOLKIT_VIEWS)
   // Writes elements to data. If there is only one element and it is a URL
   // the URL and title are written to the clipboard in a format other apps can
   // use.
diff --git a/components/components_strings.grd b/components/components_strings.grd
index db81ee5c89ff..22e5b2a7b8bf 100644
--- a/components/components_strings.grd
+++ b/components/components_strings.grd
@@ -257,7 +257,7 @@
       <part file="undo_strings.grdp" />
       <part file="version_ui_strings.grdp" />
 
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <part file="management_strings.grdp" />
       </if>
 
@@ -334,7 +334,7 @@
       <message name="IDS_PLUGIN_NOT_SUPPORTED" desc="The placeholder text for an unsupported plugin.">
         This plugin is not supported
       </message>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <if expr="not use_titlecase">
           <message name="IDS_PRINT" desc="The text label of the Print... menu item. Opens a dialog box to select print settings">
             &amp;Print...
diff --git a/components/content_settings/core/browser/cookie_settings.cc b/components/content_settings/core/browser/cookie_settings.cc
index 84d150c6bb34..42857e78dfc2 100644
--- a/components/content_settings/core/browser/cookie_settings.cc
+++ b/components/content_settings/core/browser/cookie_settings.cc
@@ -57,6 +57,7 @@ void CookieSettings::GetCookieSettings(
 
 void CookieSettings::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
+  LOG(ERROR) << "[Kiwi] CookieSettings::RegisterProfilePrefs";
   registry->RegisterBooleanPref(
       prefs::kBlockThirdPartyCookies, false,
       user_prefs::PrefRegistrySyncable::SYNCABLE_PREF);
diff --git a/components/feature_engagement/public/event_constants.cc b/components/feature_engagement/public/event_constants.cc
index 1e8973aceeaa..00cc4010663a 100644
--- a/components/feature_engagement/public/event_constants.cc
+++ b/components/feature_engagement/public/event_constants.cc
@@ -12,13 +12,13 @@ namespace feature_engagement {
 namespace events {
 
 #if defined(OS_IOS) || defined(OS_WIN) || defined(OS_MACOSX) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || true
 const char kNewTabOpened[] = "new_tab_opened";
 #endif  // defined(OS_IOS) || defined(OS_WIN) || defined(OS_MACOSX) ||
         // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 const char kReopenTabConditionsMet[] = "reopen_tab_conditions_met";
 const char kTabReopened[] = "tab_reopened";
 
diff --git a/components/feature_engagement/public/event_constants.h b/components/feature_engagement/public/event_constants.h
index 638a72e929dc..98b3fefeb966 100644
--- a/components/feature_engagement/public/event_constants.h
+++ b/components/feature_engagement/public/event_constants.h
@@ -14,7 +14,7 @@ namespace events {
 
 // Desktop and IOS.
 #if defined(OS_IOS) || defined(OS_WIN) || defined(OS_MACOSX) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || true
 // The user has explicitly opened a new tab via an entry point from inside of
 // Chrome.
 extern const char kNewTabOpened[];
@@ -23,7 +23,7 @@ extern const char kNewTabOpened[];
 
 // Desktop
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 // All conditions for reopen closed tab IPH were met. Since this IPH needs to
 // track user events (opening/closing tabs, focusing the omnibox, etc) on the
 // second level, it must be done manually.
diff --git a/components/feature_engagement/public/feature_constants.cc b/components/feature_engagement/public/feature_constants.cc
index 520aa2894612..2a495883924a 100644
--- a/components/feature_engagement/public/feature_constants.cc
+++ b/components/feature_engagement/public/feature_constants.cc
@@ -15,7 +15,7 @@ const base::Feature kIPHDummyFeature{"IPH_Dummy",
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 const base::Feature kIPHFocusModeFeature{"IPH_FocusMode",
                                          base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kIPHGlobalMediaControlsFeature{
diff --git a/components/feature_engagement/public/feature_constants.h b/components/feature_engagement/public/feature_constants.h
index de4b4117da04..eb47a316c6a0 100644
--- a/components/feature_engagement/public/feature_constants.h
+++ b/components/feature_engagement/public/feature_constants.h
@@ -18,7 +18,7 @@ extern const base::Feature kIPHDemoMode;
 extern const base::Feature kIPHDummyFeature;
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || true
 extern const base::Feature kIPHFocusModeFeature;
 extern const base::Feature kIPHGlobalMediaControlsFeature;
 extern const base::Feature kIPHReopenTabFeature;
diff --git a/components/guest_view/browser/BUILD.gn b/components/guest_view/browser/BUILD.gn
index c13fb5b75886..a1bd569db576 100644
--- a/components/guest_view/browser/BUILD.gn
+++ b/components/guest_view/browser/BUILD.gn
@@ -6,7 +6,7 @@
 # assert to prevent the accidental building of GuestViews on mobile
 # platforms. If you're now using GuestViews on mobile, go ahead and
 # remove this assert.
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 
 static_library("browser") {
   output_name = "guest_view_browser"
diff --git a/components/guest_view/renderer/BUILD.gn b/components/guest_view/renderer/BUILD.gn
index 51327be6d41e..293dc296f110 100644
--- a/components/guest_view/renderer/BUILD.gn
+++ b/components/guest_view/renderer/BUILD.gn
@@ -6,7 +6,7 @@
 # assert to prevent the accidental building of GuestViews on mobile
 # platforms. If you're now using GuestViews on mobile, go ahead and
 # remove this assert.
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 
 static_library("renderer") {
   sources = [
diff --git a/components/history_strings.grdp b/components/history_strings.grdp
index 48d5f1e84988..ec2e274037b5 100644
--- a/components/history_strings.grdp
+++ b/components/history_strings.grdp
@@ -63,7 +63,7 @@
       Clear Browsing Data...
     </message>
   </if>
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_HISTORY_OTHER_SESSIONS_COLLAPSE_SESSION" desc="In the 'Other Sessions' menu on the history page, the label for the command to collapse (hide) the list of windows and tabs in a session.">
       Collapse list
     </message>
diff --git a/components/keep_alive_registry/BUILD.gn b/components/keep_alive_registry/BUILD.gn
index a2d881330f8d..b40afc237592 100644
--- a/components/keep_alive_registry/BUILD.gn
+++ b/components/keep_alive_registry/BUILD.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android)
+# assert(!is_android)
 
 source_set("keep_alive_registry") {
   sources = [
diff --git a/components/new_or_sad_tab_strings.grdp b/components/new_or_sad_tab_strings.grdp
index ffd57decf406..b16be2aeff6f 100644
--- a/components/new_or_sad_tab_strings.grdp
+++ b/components/new_or_sad_tab_strings.grdp
@@ -112,7 +112,7 @@
                desc="Title of the new tab page, not to be confused with the action of opening a new tab.">
         New Tab
       </message>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <message name="IDS_NEW_TAB_OTR_HEADING"
                  desc="Heading used when a person opens an OTR window">
           Youâ€™ve gone incognito
diff --git a/components/page_info_strings.grdp b/components/page_info_strings.grdp
index 5bac7335cb40..b0afe41cc959 100644
--- a/components/page_info_strings.grdp
+++ b/components/page_info_strings.grdp
@@ -175,7 +175,7 @@
     </message>
 
     <!-- Certificate Viewer link -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_PAGE_INFO_CERTIFICATE" desc="Title of the certificate area in the Page Info bubble, shown when a HTTPS site is loaded.">
         Certificate
       </message>
@@ -203,7 +203,7 @@
     </if>
 
     <!-- Cookies -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_PAGE_INFO_COOKIES" desc="The label for the Cookies setting in the Page Information Window.">
         Cookies
       </message>
@@ -405,8 +405,8 @@
     </message>
 
     <!-- Permission change infobar. -->
-    <if expr="not is_android">
-      <message name="IDS_PAGE_INFO_INFOBAR_TEXT" desc="The string shown in the infobar after the user has changed site permissions settings, reminding them to reload the page in order for the new settings to take effect.">
+    <if expr="is_android or not is_android">
+      <message name=" IDS_PAGE_INFO_INFOBAR_TEXT" desc="The string shown in the infobar after the user has changed site permissions settings, reminding them to reload the page in order for the new settings to take effect.">
         To apply your updated settings to this site, reload this page
       </message>
       <message name="IDS_PAGE_INFO_INFOBAR_BUTTON" desc="The string used in the infobar button allowing the user to reload the page directly from the infobar.">
@@ -415,7 +415,7 @@
     </if>
 
     <!-- Password Protection -->
-    <if expr="not is_android">
+    <if expr="is_android or not is_android">
       <message name="IDS_PAGE_INFO_CHANGE_PASSWORD_SUMMARY" desc="A one-line summary at the top of the Page Info bubble (which shows when you click the security indicator) if user has reuse their google password on current website.">
         Your password may be compromised
       </message>
diff --git a/components/payments/content/payment_request.cc b/components/payments/content/payment_request.cc
index 17f7acf0f47b..9fdad0a32c19 100644
--- a/components/payments/content/payment_request.cc
+++ b/components/payments/content/payment_request.cc
@@ -126,7 +126,7 @@ void PaymentRequest::Init(
     mojo::PendingRemote<mojom::PaymentRequestClient> client,
     std::vector<mojom::PaymentMethodDataPtr> method_data,
     mojom::PaymentDetailsPtr details,
-    mojom::PaymentOptionsPtr options) {
+    mojom::PaymentOptionsPtr options, bool google_pay_bridge_eligible) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   if (is_initialized_) {
diff --git a/components/payments/content/payment_request.h b/components/payments/content/payment_request.h
index 5c77ab5d8040..dbb976431f98 100644
--- a/components/payments/content/payment_request.h
+++ b/components/payments/content/payment_request.h
@@ -72,7 +72,7 @@ class PaymentRequest : public mojom::PaymentRequest,
   void Init(mojo::PendingRemote<mojom::PaymentRequestClient> client,
             std::vector<mojom::PaymentMethodDataPtr> method_data,
             mojom::PaymentDetailsPtr details,
-            mojom::PaymentOptionsPtr options) override;
+            mojom::PaymentOptionsPtr options, bool google_pay_bridge_eligible) override;
   void Show(bool is_user_gesture, bool wait_for_updated_details) override;
   void Retry(mojom::PaymentValidationErrorsPtr errors) override;
   void UpdateWith(mojom::PaymentDetailsPtr details) override;
diff --git a/components/payments_strings.grdp b/components/payments_strings.grdp
index 3d51145884ca..5d0123be1449 100644
--- a/components/payments_strings.grdp
+++ b/components/payments_strings.grdp
@@ -603,7 +603,7 @@
   </if>
 
   <!-- Payment Request section preview strings. They are slightly different on desktop and android because the pluralization and formatting code behaves differently. -->
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_PAYMENT_REQUEST_PAYMENT_METHODS_PREVIEW" desc="This is a snippet of a payment method a user has saved to Chrome, plus an indication of the number of additional payment methods the user has saved. Its function is to show the user has payment methods that can be used to complete a payment, and thus doesn't have to type the entire payment method. [ICU Syntax]">
     {PAYMENT_METHOD, plural,
        =0 {<ph name="PAYMENT_METHOD_PREVIEW">{1}<ex>VISA ....1234</ex></ph>}
diff --git a/components/pdf_strings.grdp b/components/pdf_strings.grdp
index 9a83490afd59..60829170e6b5 100644
--- a/components/pdf_strings.grdp
+++ b/components/pdf_strings.grdp
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <grit-part>
-  <if expr="enable_plugins">
+  <if expr="is_android or enable_plugins">
     <message name="IDS_PDF_NEED_PASSWORD" desc="A message asking the user for a password to open a PDF file.">
       This document is password protected.  Please enter a password.
     </message>
diff --git a/components/policy/core/browser/configuration_policy_handler.cc b/components/policy/core/browser/configuration_policy_handler.cc
index 41e8f34d246b..92ee822cb957 100644
--- a/components/policy/core/browser/configuration_policy_handler.cc
+++ b/components/policy/core/browser/configuration_policy_handler.cc
@@ -364,6 +364,7 @@ SchemaValidatingPolicyHandler::SchemaValidatingPolicyHandler(
     Schema schema,
     SchemaOnErrorStrategy strategy)
     : policy_name_(policy_name), schema_(schema), strategy_(strategy) {
+  LOG(ERROR) << "[Kiwi] Processing schema: " << policy_name;
   DCHECK(schema_.valid());
 }
 
diff --git a/components/policy/resources/policy_templates.json b/components/policy/resources/policy_templates.json
index 0348733dcf97..74fdf99817f7 100644
--- a/components/policy/resources/policy_templates.json
+++ b/components/policy/resources/policy_templates.json
@@ -3949,7 +3949,7 @@
         'items': { 'type': 'string' },
         'id': 'ExtensionInstallSources',
       },
-      'supported_on': ['chrome.*:21-', 'chrome_os:21-'],
+      'supported_on': ['chrome.*:21-', 'chrome_os:21-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4008,7 +4008,7 @@
         },
         'id': 'ExtensionAllowedTypes',
       },
-      'supported_on': ['chrome.*:25-', 'chrome_os:25-'],
+      'supported_on': ['chrome.*:25-', 'chrome_os:25-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4123,7 +4123,7 @@
         },
       },
       'url_schema': 'https://www.chromium.org/administrators/policy-list-3/extension-settings-full',
-      'supported_on': ['chrome.*:62-', 'chrome_os:62-'],
+      'supported_on': ['chrome.*:62-', 'chrome_os:62-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4395,7 +4395,7 @@
       'owners': ['file://components/policy/resources/OWNERS'],
       'type': 'main',
       'schema': { 'type': 'boolean' },
-      'supported_on': ['chrome.*:10-', 'chrome_os:11-'],
+      'supported_on': ['chrome.*:10-', 'chrome_os:11-', 'android:30-'],
       'features': {
         'can_be_recommended': True,
         'dynamic_refresh': True,
@@ -16268,7 +16268,7 @@
           'required': ['url']
         }
       },
-      'supported_on': ['chrome.*:75-', 'chrome_os:75-'],
+      'supported_on': ['chrome.*:75-', 'chrome_os:75-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
diff --git a/components/prefs/pref_service.cc b/components/prefs/pref_service.cc
index 3c067f48bd21..09e9dbaf1dfc 100644
--- a/components/prefs/pref_service.cc
+++ b/components/prefs/pref_service.cc
@@ -97,12 +97,16 @@ PrefService::PrefService(
       user_pref_store_(std::move(user_prefs)),
       read_error_callback_(std::move(read_error_callback)),
       pref_registry_(std::move(pref_registry)) {
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 1";
   pref_notifier_->SetPrefService(this);
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 2";
 
   DCHECK(pref_registry_);
   DCHECK(pref_value_store_);
 
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 3";
   InitFromStorage(async);
+  LOG(ERROR) << "[Kiwi] PrefService::PrefService - Step 4";
 }
 
 PrefService::~PrefService() {
diff --git a/components/search/search.cc b/components/search/search.cc
index 4a0ae2f553ac..039c72c98849 100644
--- a/components/search/search.cc
+++ b/components/search/search.cc
@@ -9,11 +9,7 @@
 namespace search {
 
 bool IsInstantExtendedAPIEnabled() {
-#if defined(OS_IOS) || defined(OS_ANDROID)
-  return false;
-#else
   return true;
-#endif
 }
 
 }  // namespace search
diff --git a/components/signin/features.gni b/components/signin/features.gni
index f4636abdb3f5..8a7488b6c7da 100644
--- a/components/signin/features.gni
+++ b/components/signin/features.gni
@@ -3,7 +3,7 @@
 # found in the LICENSE file.
 
 # Dice is supported on the platform (but not necessarily enabled).
-enable_dice_support = (is_linux && !is_chromeos) || is_mac || is_win
+enable_dice_support = (is_linux && !is_chromeos) || is_mac || is_win || is_android
 
 # Mirror is enabled and other account consistency mechanisms are not available.
 enable_mirror = is_android || is_ios
diff --git a/components/sync_ui_strings.grdp b/components/sync_ui_strings.grdp
index c4751313e4b7..efdd4b94327a 100644
--- a/components/sync_ui_strings.grdp
+++ b/components/sync_ui_strings.grdp
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <grit-part>
-  <if expr="not is_android">
+  <if expr="is_android or not is_android">
     <message name="IDS_SYNC_BASIC_ENCRYPTION_DATA" desc="Text of the radio that when selected enables basic encryption.">
       Encrypt synced passwords with your Google credentials
     </message>
diff --git a/components/ui_devtools/views/BUILD.gn b/components/ui_devtools/views/BUILD.gn
index e9fb3b231966..a22cb17bdea7 100644
--- a/components/ui_devtools/views/BUILD.gn
+++ b/components/ui_devtools/views/BUILD.gn
@@ -34,6 +34,13 @@ source_set("views") {
     "//ui/views",
   ]
 
+  sources += [
+    "dom_agent_android.cc",
+    "dom_agent_android.h",
+    "overlay_agent_android.cc",
+    "overlay_agent_android.h",
+  ]
+
   if (use_aura) {
     sources += [
       "dom_agent_aura.cc",
diff --git a/components/ui_devtools/views/dom_agent_android.cc b/components/ui_devtools/views/dom_agent_android.cc
new file mode 100644
index 000000000000..4a48894229be
--- /dev/null
+++ b/components/ui_devtools/views/dom_agent_android.cc
@@ -0,0 +1,44 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/ui_devtools/views/dom_agent_android.h"
+
+#include "base/stl_util.h"
+#include "components/ui_devtools/views/widget_element.h"
+#include "components/ui_devtools/views/window_element.h"
+
+namespace ui_devtools {
+
+namespace {
+using ui_devtools::protocol::Array;
+using ui_devtools::protocol::DOM::Node;
+}  // namespace
+
+DOMAgentAndroid* DOMAgentAndroid::dom_agent_android_ = nullptr;
+
+DOMAgentAndroid::DOMAgentAndroid() {
+  DCHECK(!dom_agent_android_);
+  dom_agent_android_ = this;
+}
+
+DOMAgentAndroid::~DOMAgentAndroid() {
+  dom_agent_android_ = nullptr;
+}
+
+std::vector<UIElement*> DOMAgentAndroid::CreateChildrenForRoot() {
+  std::vector<UIElement*> children;
+  return children;
+}
+
+std::unique_ptr<Node> DOMAgentAndroid::BuildTreeForWindow(
+    UIElement* window_element_root) {
+  return nullptr;
+}
+
+// static
+std::unique_ptr<DOMAgentViews> DOMAgentViews::Create() {
+  return std::make_unique<DOMAgentAndroid>();
+}
+
+}  // namespace ui_devtools
diff --git a/components/ui_devtools/views/dom_agent_android.h b/components/ui_devtools/views/dom_agent_android.h
new file mode 100644
index 000000000000..08348d5abc23
--- /dev/null
+++ b/components/ui_devtools/views/dom_agent_android.h
@@ -0,0 +1,32 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_ANDROID_H_
+#define COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_ANDROID_H_
+
+#include "components/ui_devtools/views/dom_agent_views.h"
+
+namespace ui_devtools {
+
+class DOMAgentAndroid : public DOMAgentViews {
+
+ public:
+  DOMAgentAndroid();
+
+  ~DOMAgentAndroid() override;
+  static DOMAgentAndroid* GetInstance() { return dom_agent_android_; }
+
+  std::vector<UIElement*> CreateChildrenForRoot() override;
+
+  std::unique_ptr<protocol::DOM::Node> BuildTreeForWindow(
+      UIElement* window_element_root) override;
+
+ private:
+  static DOMAgentAndroid* dom_agent_android_;
+
+  DISALLOW_COPY_AND_ASSIGN(DOMAgentAndroid);
+};
+}  // namespace ui_devtools
+
+#endif  // COMPONENTS_UI_DEVTOOLS_VIEWS_DOM_AGENT_AURA_H_
diff --git a/components/ui_devtools/views/overlay_agent_android.cc b/components/ui_devtools/views/overlay_agent_android.cc
new file mode 100644
index 000000000000..986d65734d9c
--- /dev/null
+++ b/components/ui_devtools/views/overlay_agent_android.cc
@@ -0,0 +1,44 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/ui_devtools/views/overlay_agent_android.h"
+
+#include "components/ui_devtools/dom_agent.h"
+#include "components/ui_devtools/views/window_element.h"
+#include "ui/views/view.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/window_util.h"
+
+namespace ui_devtools {
+
+OverlayAgentAndroid* OverlayAgentAndroid::overlay_agent_android_ = nullptr;
+
+OverlayAgentAndroid::OverlayAgentAndroid(DOMAgent* dom_agent)
+    : OverlayAgentViews(dom_agent) {
+  DCHECK(!overlay_agent_android_);
+  overlay_agent_android_ = this;
+}
+
+OverlayAgentAndroid::~OverlayAgentAndroid() {
+  overlay_agent_android_ = nullptr;
+}
+
+void OverlayAgentAndroid::InstallPreTargetHandler() {
+}
+
+void OverlayAgentAndroid::RemovePreTargetHandler() {
+}
+
+int OverlayAgentAndroid::FindElementIdTargetedByPoint(
+    ui::LocatedEvent* event) const {
+  return 0;
+}
+
+// static
+std::unique_ptr<OverlayAgentViews> OverlayAgentViews::Create(
+    DOMAgent* dom_agent) {
+  return std::make_unique<OverlayAgentAndroid>(dom_agent);
+}
+
+}  // namespace ui_devtools
diff --git a/components/ui_devtools/views/overlay_agent_android.h b/components/ui_devtools/views/overlay_agent_android.h
new file mode 100644
index 000000000000..a991a482cc88
--- /dev/null
+++ b/components/ui_devtools/views/overlay_agent_android.h
@@ -0,0 +1,36 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_UI_DEVTOOLS_VIEWS_OVERLAY_AGENT_ANDROID_H_
+#define COMPONENTS_UI_DEVTOOLS_VIEWS_OVERLAY_AGENT_ANDROID_H_
+
+#include "components/ui_devtools/views/overlay_agent_views.h"
+
+namespace ui_devtools {
+
+class DOMAgent;
+
+class OverlayAgentAndroid : public OverlayAgentViews {
+ public:
+  OverlayAgentAndroid(DOMAgent* dom_agent);
+  ~OverlayAgentAndroid() override;
+
+  int FindElementIdTargetedByPoint(ui::LocatedEvent* event) const override;
+  static OverlayAgentAndroid* GetInstance() { return overlay_agent_android_; }
+
+ private:
+  void InstallPreTargetHandler() override;
+  void RemovePreTargetHandler() override;
+
+  FRIEND_TEST_ALL_PREFIXES(OverlayAgentTest, HighlightWindow);
+  FRIEND_TEST_ALL_PREFIXES(OverlayAgentTest, HighlightEmptyOrInvisibleWindow);
+
+  static OverlayAgentAndroid* overlay_agent_android_;
+
+  DISALLOW_COPY_AND_ASSIGN(OverlayAgentAndroid);
+};
+
+}  // namespace ui_devtools
+
+#endif  // COMPONENTS_UI_DEVTOOLS_VIEWS_OVERLAY_AGENT_AURA_H_
diff --git a/components/ui_devtools/views/overlay_agent_views.cc b/components/ui_devtools/views/overlay_agent_views.cc
index 70f61fca5812..21b7e22f5f62 100644
--- a/components/ui_devtools/views/overlay_agent_views.cc
+++ b/components/ui_devtools/views/overlay_agent_views.cc
@@ -718,10 +718,6 @@ bool OverlayAgentViews::UpdateHighlight(
   layer_for_highlighting_screen_offset_ =
       widget->GetContentsView()->GetBoundsInScreen().OffsetFromOrigin();
 #else
-  gfx::NativeWindow root = window_and_bounds.first->GetRootWindow();
-  root_layer = root->layer();
-  layer_for_highlighting_screen_offset_ =
-      root->GetBoundsInScreen().OffsetFromOrigin();
 #endif  // defined(OS_MACOSX)
   DCHECK(root_layer);
 
diff --git a/components/url_formatter/elide_url.cc b/components/url_formatter/elide_url.cc
index 24f090a1f9ca..1507b09c6ddc 100644
--- a/components/url_formatter/elide_url.cc
+++ b/components/url_formatter/elide_url.cc
@@ -25,7 +25,7 @@
 
 namespace {
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 const base::char16 kDot = '.';
 
 // Build a path from the first |num_components| elements in |path_elements|.
@@ -144,7 +144,7 @@ base::string16 HostForDisplay(base::StringPiece host_in_puny) {
 
 namespace url_formatter {
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 
 // TODO(pkasting): http://crbug.com/77883 This whole function gets
 // kerning/ligatures/etc. issues potentially wrong by assuming that the width of
diff --git a/components/url_formatter/elide_url.h b/components/url_formatter/elide_url.h
index e85cd9db25ac..eeb2183c1c5f 100644
--- a/components/url_formatter/elide_url.h
+++ b/components/url_formatter/elide_url.h
@@ -27,7 +27,7 @@ namespace url_formatter {
 
 // ElideUrl and Elide host require
 // gfx::GetStringWidthF which is not implemented in Android
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 // This function takes a GURL object and elides it. It returns a string
 // composed of parts from subdomain, domain, path, filename and query.
 // A "..." is added automatically at the end if the elided string is bigger
diff --git a/components/web_modal/BUILD.gn b/components/web_modal/BUILD.gn
index 13b631e563ed..c9f1730937d6 100644
--- a/components/web_modal/BUILD.gn
+++ b/components/web_modal/BUILD.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android && !is_ios)
+# assert(!is_android && !is_ios)
 
 component("web_modal") {
   sources = [
diff --git a/components/zoom/BUILD.gn b/components/zoom/BUILD.gn
index f2813cef4113..5fe591bdb2bf 100644
--- a/components/zoom/BUILD.gn
+++ b/components/zoom/BUILD.gn
@@ -2,7 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-assert(!is_android && !is_ios, "Desktop zoom is not used on mobile platforms.")
+# assert(!is_android && !is_ios, "Desktop zoom is not used on mobile platforms.")
 
 static_library("zoom") {
   sources = [
diff --git a/content/app/content_main_runner_impl.cc b/content/app/content_main_runner_impl.cc
index 8b3b16ff94f6..c05dc08a4075 100644
--- a/content/app/content_main_runner_impl.cc
+++ b/content/app/content_main_runner_impl.cc
@@ -404,6 +404,7 @@ class ContentClientInitializer {
   static void Set(const std::string& process_type,
                   ContentMainDelegate* delegate) {
     ContentClient* content_client = GetContentClient();
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Step 1";
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
     if (process_type.empty())
       content_client->browser_ = delegate->CreateContentBrowserClient();
@@ -447,6 +448,7 @@ int RunZygote(ContentMainDelegate* delegate) {
     {switches::kPpapiPluginProcess, PpapiPluginMain},
 #endif
   };
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - RunZygote";
 
   std::vector<std::unique_ptr<service_manager::ZygoteForkDelegate>>
       zygote_fork_delegates;
@@ -521,9 +523,11 @@ static void RegisterMainThreadFactories() {
 // Returns the exit code for this process.
 int RunBrowserProcessMain(const MainFunctionParams& main_function_params,
                           ContentMainDelegate* delegate) {
+  LOG(ERROR) << "[Kiwi] RunBrowserProcessMain - Step 1";
   int exit_code = delegate->RunProcess("", main_function_params);
   if (exit_code >= 0)
     return exit_code;
+  LOG(ERROR) << "[Kiwi] RunBrowserProcessMain - Step 2";
   return BrowserMain(main_function_params);
 }
 #endif  // !defined(CHROME_MULTIPLE_DLL_CHILD)
@@ -586,6 +590,7 @@ int ContentMainRunnerImpl::TerminateForFatalInitializationError() {
 }
 
 int ContentMainRunnerImpl::Initialize(const ContentMainParams& params) {
+  LOG(ERROR) << "[Kiwi] ContentMainRunnerImpl::Initialize - Step 1";
   ui_task_ = params.ui_task;
   created_main_parts_closure_ = params.created_main_parts_closure;
 
@@ -863,6 +868,8 @@ int ContentMainRunnerImpl::Run(bool start_service_manager_only) {
 
   RegisterMainThreadFactories();
 
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager";
+
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
   if (process_type.empty())
     return RunServiceManager(main_params, start_service_manager_only);
@@ -874,26 +881,36 @@ int ContentMainRunnerImpl::Run(bool start_service_manager_only) {
 #if !defined(CHROME_MULTIPLE_DLL_CHILD)
 int ContentMainRunnerImpl::RunServiceManager(MainFunctionParams& main_params,
                                              bool start_service_manager_only) {
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 1";
+
   if (is_browser_main_loop_started_)
     return -1;
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 2";
 
   bool should_start_service_manager_only = start_service_manager_only;
   if (!service_manager_environment_) {
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3";
     if (delegate_->ShouldCreateFeatureList()) {
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3-1";
       // This is intentionally leaked since it needs to live for the duration
       // of the process and there's no benefit in cleaning it up at exit.
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3-2";
       base::FieldTrialList* leaked_field_trial_list =
           SetUpFieldTrialsAndFeatureList().release();
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3-3";
       ANNOTATE_LEAKING_OBJECT_PTR(leaked_field_trial_list);
       ignore_result(leaked_field_trial_list);
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3-4";
       delegate_->PostFieldTrialInitialization();
     }
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3a";
 
     if (GetContentClient()->browser()->ShouldCreateThreadPool()) {
       // Create and start the ThreadPool early to allow upcoming code to use
       // the post_task.h API.
       base::ThreadPoolInstance::Create("Browser");
     }
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3b";
 
     delegate_->PreCreateMainMessageLoop();
 #if defined(OS_WIN)
@@ -909,34 +926,46 @@ int ContentMainRunnerImpl::RunServiceManager(MainFunctionParams& main_params,
     // incorrect to post to a BrowserThread before this point. This instantiates
     // and binds the MessageLoopForUI on the main thread (but it's only labeled
     // as BrowserThread::UI in BrowserMainLoop::MainMessageLoopStart).
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3c";
     BrowserTaskExecutor::Create();
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3d";
     delegate_->PostEarlyInitialization(main_params.ui_task != nullptr);
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3e";
     if (GetContentClient()->browser()->ShouldCreateThreadPool()) {
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3e-1";
       // The FeatureList needs to create before starting the ThreadPool.
       StartBrowserThreadPool();
+      LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3e-2";
     }
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3f";
 
     BrowserTaskExecutor::PostFeatureListSetup();
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3g";
     tracing::InitTracingPostThreadPoolStartAndFeatureList();
 
     if (should_start_service_manager_only)
       ForceInProcessNetworkService(true);
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3h";
     discardable_shared_memory_manager_ =
         std::make_unique<discardable_memory::DiscardableSharedMemoryManager>();
 
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3i";
     // PowerMonitor is needed in reduced mode. BrowserMainLoop will safely skip
     // initializing it again if it has already been initialized.
     base::PowerMonitor::Initialize(
         std::make_unique<base::PowerMonitorDeviceSource>());
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3j";
 
     service_manager_environment_ = std::make_unique<ServiceManagerEnvironment>(
         BrowserTaskExecutor::CreateIOThread());
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3k";
     download::SetIOTaskRunner(
         service_manager_environment_->ipc_thread()->task_runner());
+    LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 3l";
 
     InitializeBrowserMemoryInstrumentationClient();
 
@@ -948,15 +977,19 @@ int ContentMainRunnerImpl::RunServiceManager(MainFunctionParams& main_params,
 #endif
   }
 
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 5";
   if (should_start_service_manager_only) {
     DVLOG(0) << "Chrome is running in ServiceManager only mode.";
     return -1;
   }
 
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 6";
+
   DVLOG(0) << "Chrome is running in full browser mode.";
   is_browser_main_loop_started_ = true;
   startup_data_ = service_manager_environment_->CreateBrowserStartupData();
   main_params.startup_data = startup_data_.get();
+  LOG(ERROR) << "[Kiwi] ContentClientInitializer - Pre RunServiceManager - Step 7";
   return RunBrowserProcessMain(main_params, delegate_);
 }
 #endif  // !defined(CHROME_MULTIPLE_DLL_CHILD)
diff --git a/content/app/content_service_manager_main_delegate.cc b/content/app/content_service_manager_main_delegate.cc
index 86d0a470a7c2..05a30624b4bf 100644
--- a/content/app/content_service_manager_main_delegate.cc
+++ b/content/app/content_service_manager_main_delegate.cc
@@ -23,6 +23,7 @@ ContentServiceManagerMainDelegate::~ContentServiceManagerMainDelegate() =
 
 int ContentServiceManagerMainDelegate::Initialize(
     const InitializeParams& params) {
+  LOG(ERROR) << "[Kiwi] ContentServiceManagerMainDelegate::Initialize - Step 1";
 #if defined(OS_ANDROID)
   // May be called twice on Android due to the way browser startup requests are
   // dispatched by the system.
@@ -33,6 +34,7 @@ int ContentServiceManagerMainDelegate::Initialize(
 #if defined(OS_MACOSX)
   content_main_params_.autorelease_pool = params.autorelease_pool;
 #endif
+  LOG(ERROR) << "[Kiwi] ContentServiceManagerMainDelegate::Initialize - Step 2";
 
   return content_main_runner_->Initialize(content_main_params_);
 }
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 2cb2b5bbdc88..709c4621328b 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2190,9 +2190,11 @@ jumbo_source_set("browser") {
       "renderer_host/pepper/pepper_truetype_font_host.cc",
       "renderer_host/pepper/pepper_truetype_font_host.h",
       "renderer_host/pepper/pepper_truetype_font_linux.cc",
+      "renderer_host/pepper/pepper_truetype_font_android.cc",
       "renderer_host/pepper/pepper_truetype_font_list.h",
       "renderer_host/pepper/pepper_truetype_font_list_host.cc",
       "renderer_host/pepper/pepper_truetype_font_list_host.h",
+      "renderer_host/pepper/pepper_truetype_font_list_android.cc",
       "renderer_host/pepper/pepper_truetype_font_list_mac.mm",
       "renderer_host/pepper/pepper_truetype_font_list_win.cc",
       "renderer_host/pepper/pepper_truetype_font_mac.mm",
@@ -2417,7 +2419,7 @@ jumbo_source_set("browser") {
     }
     defines += [ "APPCACHE_USE_SIMPLE_CACHE" ]
     libs += [ "jnigraphics" ]
-  } else {
+
     # Not Android.
     sources += [
       # The WebAuthn devtools protocol API is not supported in Android yet.
@@ -2425,8 +2427,6 @@ jumbo_source_set("browser") {
       "$target_gen_dir/devtools/protocol/web_authn.h",
 
       # Devtools frontend not included in Android
-      "devtools/devtools_frontend_host_impl.cc",
-      "devtools/devtools_frontend_host_impl.h",
       "devtools/protocol/webauthn_handler.cc",
       "devtools/protocol/webauthn_handler.h",
       "host_zoom_level_context.cc",
@@ -2564,7 +2564,8 @@ jumbo_source_set("browser") {
     ]
   }
 
-  if (use_aura || is_mac) {
+  if (true || use_aura || is_mac) {
+if (false) {
     sources += [
       "compositor/browser_compositor_output_surface.cc",
       "compositor/browser_compositor_output_surface.h",
@@ -2574,8 +2575,6 @@ jumbo_source_set("browser") {
       "compositor/gpu_process_transport_factory.h",
       "compositor/gpu_surfaceless_browser_compositor_output_surface.cc",
       "compositor/gpu_surfaceless_browser_compositor_output_surface.h",
-      "compositor/image_transport_factory.cc",
-      "compositor/image_transport_factory.h",
       "compositor/offscreen_browser_compositor_output_surface.cc",
       "compositor/offscreen_browser_compositor_output_surface.h",
       "compositor/owned_mailbox.cc",
@@ -2588,6 +2587,11 @@ jumbo_source_set("browser") {
       "compositor/software_browser_compositor_output_surface.h",
       "compositor/viz_process_transport_factory.cc",
       "compositor/viz_process_transport_factory.h",
+    ]
+}
+    sources += [
+      "compositor/image_transport_factory.cc",
+      "compositor/image_transport_factory.h",
       "context_factory.cc",
       "renderer_host/browser_compositor_view_mac.h",
       "renderer_host/browser_compositor_view_mac.mm",
diff --git a/content/browser/browser_main.cc b/content/browser/browser_main.cc
index 65668ab3f5fd..97bed835d9a4 100644
--- a/content/browser/browser_main.cc
+++ b/content/browser/browser_main.cc
@@ -31,6 +31,7 @@ class ScopedBrowserMainEvent {
 
 // Main routine for running as the Browser process.
 int BrowserMain(const MainFunctionParams& parameters) {
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 1";
   ScopedBrowserMainEvent scoped_browser_main_event;
 
   base::trace_event::TraceLog::GetInstance()->set_process_name("Browser");
@@ -39,13 +40,16 @@ int BrowserMain(const MainFunctionParams& parameters) {
 
   std::unique_ptr<BrowserMainRunnerImpl> main_runner(
       BrowserMainRunnerImpl::Create());
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 2";
 
   int exit_code = main_runner->Initialize(parameters);
   if (exit_code >= 0)
     return exit_code;
 
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 3";
   exit_code = main_runner->Run();
 
+  LOG(ERROR) << "[Kiwi] BrowserMain - Step 4";
   main_runner->Shutdown();
 
   return exit_code;
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 9da6475030a7..799dcdde09e9 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -573,6 +573,7 @@ BrowserMainLoop::~BrowserMainLoop() {
 }
 
 void BrowserMainLoop::Init() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::Init - Step 1";
   TRACE_EVENT0("startup", "BrowserMainLoop::Init");
 
   // |startup_data| is optional. If set, the thread owned by the data
@@ -588,6 +589,7 @@ void BrowserMainLoop::Init() {
     service_manager_shutdown_closure_ =
         std::move(startup_data->service_manager_shutdown_closure);
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::Init - Step 2";
 
   parts_ = GetContentClient()->browser()->CreateBrowserMainParts(parameters_);
 }
@@ -827,6 +829,7 @@ void BrowserMainLoop::PostMainMessageLoopStart() {
 }
 
 int BrowserMainLoop::PreCreateThreads() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PreCreateThreads - Step 1";
   if (parts_) {
     TRACE_EVENT0("startup",
         "BrowserMainLoop::CreateThreads:PreCreateThreads");
@@ -886,6 +889,7 @@ int BrowserMainLoop::PreCreateThreads() {
 
   // Record metrics about which site isolation flags have been turned on.
   SiteIsolationPolicy::StartRecordingSiteIsolationFlagUsage();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PreCreateThreads - Step 2";
 
   return result_code_;
 }
@@ -895,6 +899,7 @@ void BrowserMainLoop::PreShutdown() {
 }
 
 void BrowserMainLoop::CreateStartupTasks() {
+  LOG(ERROR) << "BrowserMainLoop::CreateStartupTasks - Step 1";
   TRACE_EVENT0("startup", "BrowserMainLoop::CreateStartupTasks");
 
   DCHECK(!startup_task_runner_);
@@ -963,11 +968,13 @@ void BrowserMainLoop::SynchronouslyFlushStartupTasks() {
 #endif  // OS_ANDROID
 
 int BrowserMainLoop::CreateThreads() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 1";
   TRACE_EVENT0("startup,rail", "BrowserMainLoop::CreateThreads");
 
   // Release the ThreadPool's threads.
   scoped_execution_fence_.reset();
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 2";
   // The |io_thread| can have optionally been injected into Init(), but if not,
   // create it here. Thre thread is only tagged as BrowserThread::IO here in
   // order to prevent any code from statically posting to it before
@@ -976,9 +983,12 @@ int BrowserMainLoop::CreateThreads() {
   if (!io_thread_) {
     io_thread_ = BrowserTaskExecutor::CreateIOThread();
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 3";
   io_thread_->RegisterAsBrowserThread();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 4";
   BrowserTaskExecutor::InitializeIOThread();
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 5";
   // TODO(https://crbug.com/863341): Replace with a better API
   GetContentClient()->browser()->PostAfterStartupTask(
       FROM_HERE, base::SequencedTaskRunnerHandle::Get(),
@@ -995,20 +1005,24 @@ int BrowserMainLoop::CreateThreads() {
           // Accessing an Unretained pointer to BrowserMainLoop from a main
           // thread task is therefore safe.
           base::Unretained(this)));
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::CreateThreads - Step 6";
 
   created_threads_ = true;
   return result_code_;
 }
 
 int BrowserMainLoop::PostCreateThreads() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PostCreateThreads - Step 1";
   tracing_controller_ = std::make_unique<content::TracingControllerImpl>();
   content::BackgroundTracingManagerImpl::GetInstance()
       ->AddMetadataGeneratorFunction();
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PostCreateThreads - Step 2";
   if (parts_) {
     TRACE_EVENT0("startup", "BrowserMainLoop::PostCreateThreads");
     parts_->PostCreateThreads();
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::PostCreateThreads - Step 3";
 
   return result_code_;
 }
@@ -1247,16 +1261,19 @@ void BrowserMainLoop::InitializeMainThread() {
 }
 
 int BrowserMainLoop::BrowserThreadsStarted() {
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 1";
   TRACE_EVENT0("startup", "BrowserMainLoop::BrowserThreadsStarted");
 
   // Bring up Mojo IPC and the embedded Service Manager as early as possible.
   // Initializaing mojo requires the IO thread to have been initialized first,
   // so this cannot happen any earlier than now.
   InitializeMojo();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 2";
 
   data_decoder_service_provider_ = std::make_unique<OopDataDecoder>();
 
   HistogramSynchronizer::GetInstance();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 3";
 
   // cc assumes a single client name for metrics in a process, which is
   // is inconsistent with single process mode where both the renderer and
@@ -1276,6 +1293,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
   InitShaderCacheFactorySingleton(
       base::CreateSingleThreadTaskRunner({BrowserThread::IO}));
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 4";
   // Initialize the FontRenderParams on IO thread. This needs to be initialized
   // before gpu process initialization below.
   base::PostTask(FROM_HERE, {BrowserThread::IO},
@@ -1283,6 +1301,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
                                 gfx::GetFontRenderParams(
                                     gfx::FontRenderParamsQuery(), nullptr)));
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 5";
   bool always_uses_gpu = true;
   bool established_gpu_channel = false;
 #if defined(OS_ANDROID)
@@ -1297,6 +1316,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
       parsed_command_line_.HasSwitch(switches::kDisableGpuEarlyInit)) {
     established_gpu_channel = always_uses_gpu = false;
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 6";
 
   host_frame_sink_manager_ = std::make_unique<viz::HostFrameSinkManager>();
   BrowserGpuChannelHostFactory::Initialize(established_gpu_channel);
@@ -1329,6 +1349,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
             compositing_mode_reporter_impl_.get(),
             server_shared_bitmap_manager_.get(), GetResizeTaskRunner()));
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 7";
 
 #if defined(USE_AURA)
   env_->set_context_factory(GetContextFactory());
@@ -1341,6 +1362,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
       tracing::GraphicsMemoryDumpProvider::GetInstance(), "AndroidGraphics",
       nullptr);
 #endif
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 8";
 
   {
     TRACE_EVENT0("startup", "BrowserThreadsStarted::Subsystem:AudioMan");
@@ -1358,6 +1380,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
         GetSystemConnector()->Clone());
   }
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 9";
 #if defined(OS_WIN)
   HDRProxy::Initialize();
   system_message_window_.reset(new media::SystemMessageWindowWin);
@@ -1378,6 +1401,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
   // created; namely, WebRtcEventLogManager.
   // Allowed to leak when the browser exits.
   WebRTCInternals::CreateSingletonInstance();
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 10";
 
   // MediaStreamManager needs the IO thread to be created.
   {
@@ -1422,6 +1446,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
     save_file_manager_ = new SaveFileManager();
   }
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 11";
   // Alert the clipboard class to which threads are allowed to access the
   // clipboard:
   std::vector<base::PlatformThreadId> allowed_clipboard_threads;
@@ -1442,6 +1467,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
         base::BindOnce(base::IgnoreResult(&GpuProcessHost::Get),
                        GPU_PROCESS_KIND_SANDBOXED, true /* force_create */));
   }
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 12";
 
 #if defined(OS_WIN)
   if (!parsed_command_line_.HasSwitch(
@@ -1464,6 +1490,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
   ThemeHelperMac::GetInstance();
 #endif  // defined(OS_MACOSX)
 
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 13";
 #if defined(OS_ANDROID)
   media::SetMediaDrmBridgeClient(GetContentClient()->GetMediaDrmBridgeClient());
   if (base::FeatureList::IsEnabled(features::kFontSrcLocalMatching)) {
@@ -1474,6 +1501,7 @@ int BrowserMainLoop::BrowserThreadsStarted() {
 #if defined(ENABLE_IPC_FUZZER)
   SetFileUrlPathAliasForIpcFuzzer();
 #endif
+  LOG(ERROR) << "[Kiwi] BrowserMainLoop::BrowserThreadsStarted - Step 14";
   return result_code_;
 }
 
diff --git a/content/browser/browser_main_runner_impl.cc b/content/browser/browser_main_runner_impl.cc
index 4b59e815be0a..df6079c62945 100644
--- a/content/browser/browser_main_runner_impl.cc
+++ b/content/browser/browser_main_runner_impl.cc
@@ -62,6 +62,7 @@ BrowserMainRunnerImpl::~BrowserMainRunnerImpl() {
 }
 
 int BrowserMainRunnerImpl::Initialize(const MainFunctionParams& parameters) {
+  LOG(ERROR) << "[Kiwi] BrowserMainRunnerImpl::Initialize - Step 1";
   SCOPED_UMA_HISTOGRAM_LONG_TIMER(
       "Startup.BrowserMainRunnerImplInitializeLongTime");
   TRACE_EVENT0("startup", "BrowserMainRunnerImpl::Initialize");
@@ -75,6 +76,7 @@ int BrowserMainRunnerImpl::Initialize(const MainFunctionParams& parameters) {
 
     const base::TimeTicks start_time_step1 = base::TimeTicks::Now();
 
+    LOG(ERROR) << "[Kiwi] BrowserMainRunnerImpl::Initialize - Step 2";
     SkGraphics::Init();
 
     if (parameters.command_line.HasSwitch(switches::kWaitForDebugger))
@@ -93,6 +95,7 @@ int BrowserMainRunnerImpl::Initialize(const MainFunctionParams& parameters) {
 #endif  // OS_WIN
 
     gfx::InitializeFonts();
+    LOG(ERROR) << "[Kiwi] BrowserMainRunnerImpl::Initialize - Step 3";
 
     main_loop_.reset(
         new BrowserMainLoop(parameters, std::move(scoped_execution_fence_)));
diff --git a/content/browser/compositor/gpu_process_transport_factory.cc b/content/browser/compositor/gpu_process_transport_factory.cc
index 0b438d135229..3965520ffcbe 100644
--- a/content/browser/compositor/gpu_process_transport_factory.cc
+++ b/content/browser/compositor/gpu_process_transport_factory.cc
@@ -821,14 +821,6 @@ GpuProcessTransportFactory::CreatePerCompositorData(
   auto data = std::make_unique<PerCompositorData>();
   if (widget == gfx::kNullAcceleratedWidget) {
     data->surface_handle = gpu::kNullSurfaceHandle;
-  } else {
-#if defined(GPU_SURFACE_HANDLE_IS_ACCELERATED_WINDOW)
-    data->surface_handle = widget;
-#else
-    gpu::GpuSurfaceTracker* tracker = gpu::GpuSurfaceTracker::Get();
-    data->surface_handle = tracker->AddSurfaceForNativeWidget(
-        gpu::GpuSurfaceTracker::SurfaceRecord(widget));
-#endif
   }
 
   PerCompositorData* return_ptr = data.get();
diff --git a/content/browser/devtools/BUILD.gn b/content/browser/devtools/BUILD.gn
index 187a511c6fd6..ebc66d339dae 100644
--- a/content/browser/devtools/BUILD.gn
+++ b/content/browser/devtools/BUILD.gn
@@ -7,7 +7,7 @@ import("//third_party/protobuf/proto_library.gni")
 import("//tools/grit/grit_rule.gni")
 
 group("resources") {
-  if (!is_android) {
+  if (true || !is_android) {
     public_deps = [
       ":devtools_resources",
     ]
diff --git a/content/browser/frame_host/navigation_controller_impl.cc b/content/browser/frame_host/navigation_controller_impl.cc
index 9b489fed825c..1f8f77fd172b 100644
--- a/content/browser/frame_host/navigation_controller_impl.cc
+++ b/content/browser/frame_host/navigation_controller_impl.cc
@@ -946,8 +946,10 @@ void NavigationControllerImpl::LoadURL(const GURL& url,
 }
 
 void NavigationControllerImpl::LoadURLWithParams(const LoadURLParams& params) {
+#if 0
   if (params.is_renderer_initiated)
     DCHECK(params.initiator_origin.has_value());
+#endif
 
   TRACE_EVENT1("browser,navigation",
                "NavigationControllerImpl::LoadURLWithParams", "url",
@@ -3087,7 +3089,9 @@ NavigationControllerImpl::CreateNavigationRequestFromLoadParams(
   DCHECK_EQ(-1, GetIndexOfEntry(entry));
   DCHECK(frame_entry);
   // All renderer-initiated navigations must have an initiator_origin.
+#if 0
   DCHECK(!params.is_renderer_initiated || params.initiator_origin.has_value());
+#endif
 
   GURL url_to_load;
   GURL virtual_url;
diff --git a/content/browser/frame_host/navigation_request.cc b/content/browser/frame_host/navigation_request.cc
index 26bbc64c40fa..56a9ba1d9fa0 100644
--- a/content/browser/frame_host/navigation_request.cc
+++ b/content/browser/frame_host/navigation_request.cc
@@ -897,7 +897,9 @@ NavigationRequest::NavigationRequest(
       commit_navigation_client_(mojo::NullAssociatedRemote()),
       rfh_restored_from_back_forward_cache_(
           rfh_restored_from_back_forward_cache) {
+#if 0
   DCHECK(browser_initiated_ || common_params_->initiator_origin.has_value());
+#endif
   DCHECK(!IsRendererDebugURL(common_params_->url));
   DCHECK(common_params_->method == "POST" || !common_params_->post_data);
   TRACE_EVENT_ASYNC_BEGIN2("navigation", "NavigationRequest", this,
diff --git a/content/browser/renderer_host/pepper/pepper_truetype_font_android.cc b/content/browser/renderer_host/pepper/pepper_truetype_font_android.cc
new file mode 100644
index 000000000000..6ed4c5b0ff16
--- /dev/null
+++ b/content/browser/renderer_host/pepper/pepper_truetype_font_android.cc
@@ -0,0 +1,78 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/pepper/pepper_truetype_font.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+
+#include "base/compiler_specific.h"
+#include "base/files/scoped_file.h"
+#include "base/macros.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/sys_byteorder.h"
+#include "build/build_config.h"
+#include "components/services/font/ppapi_fontconfig_matching.h"
+#include "content/public/common/common_sandbox_support_linux.h"
+#include "ppapi/buildflags/buildflags.h"
+#include "ppapi/c/dev/ppb_truetype_font_dev.h"
+#include "ppapi/c/pp_errors.h"
+#include "ppapi/c/trusted/ppb_browser_font_trusted.h"
+
+namespace content {
+
+namespace {
+
+class PepperTrueTypeFontAndroid : public PepperTrueTypeFont {
+ public:
+  PepperTrueTypeFontAndroid();
+
+  // PepperTrueTypeFont implementation.
+  int32_t Initialize(ppapi::proxy::SerializedTrueTypeFontDesc* desc) override;
+  int32_t GetTableTags(std::vector<uint32_t>* tags) override;
+  int32_t GetTable(uint32_t table_tag,
+                   int32_t offset,
+                   int32_t max_data_length,
+                   std::string* data) override;
+
+ private:
+  ~PepperTrueTypeFontAndroid() override;
+
+  base::ScopedFD fd_;
+
+  DISALLOW_COPY_AND_ASSIGN(PepperTrueTypeFontAndroid);
+};
+
+PepperTrueTypeFontAndroid::PepperTrueTypeFontAndroid() {
+}
+
+PepperTrueTypeFontAndroid::~PepperTrueTypeFontAndroid() {
+}
+
+int32_t PepperTrueTypeFontAndroid::Initialize(
+    ppapi::proxy::SerializedTrueTypeFontDesc* desc) {
+  return fd_.is_valid() ? PP_OK : PP_ERROR_FAILED;
+}
+
+int32_t PepperTrueTypeFontAndroid::GetTableTags(std::vector<uint32_t>* tags) {
+  return PP_ERROR_FAILED;
+}
+
+int32_t PepperTrueTypeFontAndroid::GetTable(uint32_t table_tag,
+                                          int32_t offset,
+                                          int32_t max_data_length,
+                                          std::string* data) {
+  return PP_ERROR_FAILED;
+}
+
+}  // namespace
+
+// static
+PepperTrueTypeFont* PepperTrueTypeFont::Create() {
+  return new PepperTrueTypeFontAndroid();
+}
+
+}  // namespace content
diff --git a/content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc b/content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc
new file mode 100644
index 000000000000..12e2c61a8cf5
--- /dev/null
+++ b/content/browser/renderer_host/pepper/pepper_truetype_font_list_android.cc
@@ -0,0 +1,20 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/logging.h"
+#include "content/browser/renderer_host/pepper/pepper_truetype_font_list.h"
+
+namespace content {
+
+void GetFontFamilies_SlowBlocking(std::vector<std::string>* font_families) {
+  NOTIMPLEMENTED();
+}
+
+void GetFontsInFamily_SlowBlocking(
+    const std::string& family,
+    std::vector<ppapi::proxy::SerializedTrueTypeFontDesc>* fonts_in_family) {
+  NOTIMPLEMENTED();
+}
+
+}  // namespace content
diff --git a/content/browser/renderer_host/render_view_host_impl.cc b/content/browser/renderer_host/render_view_host_impl.cc
index a73a05383e44..5efa9bc1dd0a 100644
--- a/content/browser/renderer_host/render_view_host_impl.cc
+++ b/content/browser/renderer_host/render_view_host_impl.cc
@@ -106,7 +106,7 @@
 #include "ui/gfx/system_fonts_win.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "content/browser/host_zoom_map_impl.h"
 #endif
 
@@ -704,7 +704,7 @@ void RenderViewHostImpl::ClosePage() {
 
     // TODO(creis): Should this be moved to Shutdown?  It may not be called for
     // RenderViewHosts that have been swapped out.
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     static_cast<HostZoomMapImpl*>(HostZoomMap::Get(GetSiteInstance()))
         ->WillCloseRenderView(GetProcess()->GetID(), GetRoutingID());
 #endif
@@ -905,7 +905,7 @@ void RenderViewHostImpl::OnDocumentAvailableInMainFrame(
   if (!uses_temporary_zoom_level)
     return;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   HostZoomMapImpl* host_zoom_map =
       static_cast<HostZoomMapImpl*>(HostZoomMap::Get(GetSiteInstance()));
   host_zoom_map->SetTemporaryZoomLevel(GetProcess()->GetID(),
diff --git a/content/browser/storage_partition_impl.cc b/content/browser/storage_partition_impl.cc
index c05ce85a2327..df33f47430a1 100644
--- a/content/browser/storage_partition_impl.cc
+++ b/content/browser/storage_partition_impl.cc
@@ -90,7 +90,6 @@
 
 #if defined(OS_ANDROID)
 #include "net/android/http_auth_negotiate_android.h"
-#else
 #include "content/browser/host_zoom_map_impl.h"
 #endif  // defined(OS_ANDROID)
 
@@ -1236,7 +1235,7 @@ void StoragePartitionImpl::Initialize() {
   push_messaging_context_ =
       new PushMessagingContext(browser_context_, service_worker_context_);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   host_zoom_level_context_ = new HostZoomLevelContext(
       browser_context_->CreateZoomLevelDelegate(partition_path_));
 #endif  // !defined(OS_ANDROID)
@@ -1459,7 +1458,7 @@ SharedWorkerServiceImpl* StoragePartitionImpl::GetSharedWorkerService() {
   return shared_worker_service_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 HostZoomMap* StoragePartitionImpl::GetHostZoomMap() {
   DCHECK(initialized_);
   DCHECK(host_zoom_level_context_.get());
diff --git a/content/browser/storage_partition_impl.h b/content/browser/storage_partition_impl.h
index 8fa1496d5782..35b7354a9910 100644
--- a/content/browser/storage_partition_impl.h
+++ b/content/browser/storage_partition_impl.h
@@ -47,7 +47,7 @@
 #include "storage/browser/quota/special_storage_policy.h"
 #include "third_party/blink/public/mojom/dom_storage/storage_partition_service.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "content/browser/host_zoom_level_context.h"
 #endif
 
@@ -138,7 +138,7 @@ class CONTENT_EXPORT StoragePartitionImpl
   DevToolsBackgroundServicesContextImpl* GetDevToolsBackgroundServicesContext()
       override;
   ContentIndexContextImpl* GetContentIndexContext() override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   HostZoomMap* GetHostZoomMap() override;
   HostZoomLevelContext* GetHostZoomLevelContext() override;
   ZoomLevelDelegate* GetZoomLevelDelegate() override;
@@ -437,7 +437,7 @@ class CONTENT_EXPORT StoragePartitionImpl
   std::unique_ptr<SharedWorkerServiceImpl> shared_worker_service_;
   scoped_refptr<PushMessagingContext> push_messaging_context_;
   scoped_refptr<storage::SpecialStoragePolicy> special_storage_policy_;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   scoped_refptr<HostZoomLevelContext> host_zoom_level_context_;
 #endif  // !defined(OS_ANDROID)
   scoped_refptr<PlatformNotificationContextImpl> platform_notification_context_;
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index 6f2ee557fb41..28c88eb30ac2 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -176,7 +176,7 @@
 #include "content/browser/android/nfc_host.h"
 #include "content/browser/web_contents/web_contents_android.h"
 #include "services/device/public/mojom/nfc.mojom.h"
-#else  // !OS_ANDROID
+
 #include "content/browser/host_zoom_map_impl.h"
 #endif  // OS_ANDROID
 
@@ -599,7 +599,7 @@ WebContentsImpl::WebContentsImpl(BrowserContext* browser_context)
       audio_stream_monitor_(this),
       media_web_contents_observer_(
           std::make_unique<MediaWebContentsObserver>(this)),
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
       page_scale_factor_is_one_(true),
 #endif  // !defined(OS_ANDROID)
       is_overlay_content_(false),
@@ -1192,7 +1192,7 @@ FindRequestManager* WebContentsImpl::GetFindRequestManagerForTesting() {
   return GetFindRequestManager();
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 void WebContentsImpl::UpdateZoom() {
   RenderWidgetHostImpl* rwh = GetRenderViewHost()->GetWidget();
   if (rwh->GetView())
@@ -5638,7 +5638,7 @@ WebContents* WebContentsImpl::GetAsWebContents() {
   return this;
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 double WebContentsImpl::GetPendingPageZoomLevel() {
   NavigationEntry* pending_entry = GetController().GetPendingEntry();
   if (!pending_entry)
diff --git a/content/browser/web_contents/web_contents_impl.h b/content/browser/web_contents/web_contents_impl.h
index 0f8667f45492..b80dcd3654b5 100644
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -253,7 +253,7 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
   // bitmap.
   void AddAccessibilityMode(ui::AXMode mode);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Sets the zoom level for frames associated with this WebContents.
   void UpdateZoom();
 
@@ -787,7 +787,7 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
   void OnVerticalScrollDirectionChanged(
       viz::VerticalScrollDirection scroll_direction) override;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   double GetPendingPageZoomLevel() override;
 #endif  // !defined(OS_ANDROID)
 
@@ -1853,7 +1853,7 @@ class CONTENT_EXPORT WebContentsImpl : public WebContents,
 
   PageImportanceSignals page_importance_signals_;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   bool page_scale_factor_is_one_;
 #endif  // !defined(OS_ANDROID)
 
diff --git a/content/browser/webui/shared_resources_data_source.cc b/content/browser/webui/shared_resources_data_source.cc
index 64bdcea5ff6a..c3eb826668d1 100644
--- a/content/browser/webui/shared_resources_data_source.cc
+++ b/content/browser/webui/shared_resources_data_source.cc
@@ -87,7 +87,7 @@ const std::map<std::string, std::string> CreatePathPrefixAliasesMap() {
     return aliases;
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   aliases["../../../third_party/polymer/v1_0/components-chromium/polymer2/"] =
       "polymer/v1_0/polymer/";
 #endif  // !defined(OS_ANDROID)
@@ -179,7 +179,7 @@ const std::map<int, std::string> CreateChromeosMojoResourceIdToAliasMap() {
 }
 #endif  // !defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 bool ShouldIgnore(std::string resource) {
 #if defined(OS_CHROMEOS)
   if (UsingMultiplePolymerVersions())
@@ -211,7 +211,7 @@ void AddResourcesToMap(ResourcesMap* resources_map) {
   for (size_t i = 0; i < kWebuiResourcesSize; ++i) {
     const auto& resource = kWebuiResources[i];
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
     if (ShouldIgnore(resource.name))
       continue;
 #endif  // !defined(OS_ANDROID)
diff --git a/content/public/browser/browser_context.h b/content/public/browser/browser_context.h
index 683e352d1dd7..db1d56b33034 100644
--- a/content/public/browser/browser_context.h
+++ b/content/public/browser/browser_context.h
@@ -28,7 +28,7 @@
 #include "third_party/blink/public/mojom/blob/blob.mojom-forward.h"
 #include "third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom-forward.h"
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 #include "content/public/browser/zoom_level_delegate.h"
 #endif
 
@@ -248,7 +248,7 @@ class CONTENT_EXPORT BrowserContext : public base::SupportsUserData {
   // StoragePartition can have time to do necessary cleanups on IO thread.
   void ShutdownStoragePartitions();
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Creates a delegate to initialize a HostZoomMap and persist its information.
   // This is called during creation of each StoragePartition.
   virtual std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
index bcb85464359c..5351e6ac0d85 100644
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -853,7 +853,7 @@ void ContentBrowserClient::CreateWebUsbService(
     RenderFrameHost* render_frame_host,
     mojo::PendingReceiver<blink::mojom::WebUsbService> receiver) {}
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 SerialDelegate* ContentBrowserClient::GetSerialDelegate() {
   return nullptr;
 }
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index b70473936db0..90a9e88ebdeb 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1508,7 +1508,7 @@ class CONTENT_EXPORT ContentBrowserClient {
       RenderFrameHost* render_frame_host,
       mojo::PendingReceiver<blink::mojom::WebUsbService> receiver);
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   // Allows the embedder to provide an implementation of the Serial API.
   virtual SerialDelegate* GetSerialDelegate();
 #endif
diff --git a/content/public/browser/desktop_media_id.cc b/content/public/browser/desktop_media_id.cc
index 9330ec65d449..13ad52db8228 100644
--- a/content/public/browser/desktop_media_id.cc
+++ b/content/public/browser/desktop_media_id.cc
@@ -27,15 +27,13 @@ const DesktopMediaID::Id DesktopMediaID::kNullId = 0;
 // static
 const DesktopMediaID::Id DesktopMediaID::kFakeId = -3;
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) || true
 // static
 DesktopMediaID DesktopMediaID::RegisterNativeWindow(DesktopMediaID::Type type,
                                                     gfx::NativeWindow window) {
   DCHECK(type == TYPE_SCREEN || type == TYPE_WINDOW);
   DCHECK(window);
   DesktopMediaID media_id(type, kNullId);
-  media_id.window_id =
-      DesktopMediaWindowRegistry::GetInstance()->RegisterWindow(window);
   return media_id;
 }
 
diff --git a/content/public/browser/desktop_media_id.h b/content/public/browser/desktop_media_id.h
index c9791b4f436a..839b19686d26 100644
--- a/content/public/browser/desktop_media_id.h
+++ b/content/public/browser/desktop_media_id.h
@@ -28,7 +28,7 @@ struct CONTENT_EXPORT DesktopMediaID {
   // Represents a fake id to create a dummy capturer for autotests.
   static const Id kFakeId;
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) || true
   // Assigns integer identifier to the |window| and returns its DesktopMediaID.
   static DesktopMediaID RegisterNativeWindow(Type type,
                                              gfx::NativeWindow window);
diff --git a/content/public/browser/storage_partition.h b/content/public/browser/storage_partition.h
index da224f4c3478..eaece325dd44 100644
--- a/content/public/browser/storage_partition.h
+++ b/content/public/browser/storage_partition.h
@@ -64,7 +64,7 @@ class PlatformNotificationContext;
 class ServiceWorkerContext;
 class SharedWorkerService;
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 class HostZoomLevelContext;
 class HostZoomMap;
 class ZoomLevelDelegate;
@@ -133,7 +133,7 @@ class CONTENT_EXPORT StoragePartition {
   virtual DevToolsBackgroundServicesContext*
   GetDevToolsBackgroundServicesContext() = 0;
   virtual ContentIndexContext* GetContentIndexContext() = 0;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   virtual HostZoomMap* GetHostZoomMap() = 0;
   virtual HostZoomLevelContext* GetHostZoomLevelContext() = 0;
   virtual ZoomLevelDelegate* GetZoomLevelDelegate() = 0;
diff --git a/content/public/common/pepper_plugin_info.h b/content/public/common/pepper_plugin_info.h
index 753bff723ad0..79846e8c216e 100644
--- a/content/public/common/pepper_plugin_info.h
+++ b/content/public/common/pepper_plugin_info.h
@@ -17,9 +17,11 @@
 #include "ppapi/c/pp_module.h"
 #include "ppapi/c/ppb.h"
 
+#if 0
 #if !BUILDFLAG(ENABLE_PLUGINS)
 #error "Plugins should be enabled"
 #endif
+#endif
 
 namespace content {
 
diff --git a/content/shell/BUILD.gn b/content/shell/BUILD.gn
index e82958e70dd1..3317b006b292 100644
--- a/content/shell/BUILD.gn
+++ b/content/shell/BUILD.gn
@@ -574,7 +574,7 @@ repack("pak") {
     sources +=
         [ "$root_gen_dir/ui/views/resources/views_resources_100_percent.pak" ]
   }
-  if (!is_android) {
+  if (true || !is_android) {
     sources +=
         [ "$root_gen_dir/content/browser/devtools/devtools_resources.pak" ]
     deps += [ "//content/browser/devtools:resources" ]
diff --git a/content/shell/browser/shell_browser_context.cc b/content/shell/browser/shell_browser_context.cc
index 8faba962a63c..1f1dace7bdf0 100644
--- a/content/shell/browser/shell_browser_context.cc
+++ b/content/shell/browser/shell_browser_context.cc
@@ -139,7 +139,7 @@ void ShellBrowserContext::FinishInitWhileIOAllowed() {
   SimpleKeyMap::GetInstance()->Associate(this, key_.get());
 }
 
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 std::unique_ptr<ZoomLevelDelegate> ShellBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath&) {
   return std::unique_ptr<ZoomLevelDelegate>();
diff --git a/content/shell/browser/shell_browser_context.h b/content/shell/browser/shell_browser_context.h
index d199c22ae034..6bc4aab5af5a 100644
--- a/content/shell/browser/shell_browser_context.h
+++ b/content/shell/browser/shell_browser_context.h
@@ -25,7 +25,7 @@ class ClientHintsControllerDelegate;
 class DownloadManagerDelegate;
 class PermissionControllerDelegate;
 class ShellDownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
 class ZoomLevelDelegate;
 #endif  // !defined(OS_ANDROID)
 
@@ -44,7 +44,7 @@ class ShellBrowserContext : public BrowserContext {
 
   // BrowserContext implementation.
   base::FilePath GetPath() override;
-#if !defined(OS_ANDROID)
+#if true || !defined(OS_ANDROID)
   std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
diff --git a/extensions/BUILD.gn b/extensions/BUILD.gn
index ac430db0ec4a..1fa06a47b70f 100644
--- a/extensions/BUILD.gn
+++ b/extensions/BUILD.gn
@@ -203,42 +203,6 @@ repack("shell_and_test_pak") {
   ]
 }
 
-test("extensions_unittests") {
-  sources = [
-    "test/extensions_unittests_main.cc",
-    "test/logging_timer_unittest.cc",
-  ]
-
-  data = [
-    "test/data/",
-    "//chrome/test/data/extensions/",
-    "//components/test/data/cast_certificate/",
-    "$root_out_dir/content_shell.pak",
-    "$root_out_dir/extensions_shell_and_test.pak",
-  ]
-
-  deps = [
-    ":extensions_resources",
-    ":shell_and_test_pak",
-    ":test_support",
-    "//base/test:test_support",
-    "//content/public/common",
-    "//content/test:test_support",
-    "//extensions/browser:unit_tests",
-    "//extensions/common",
-    "//extensions/common:unit_tests",
-    "//extensions/renderer:unit_tests",
-    "//extensions/shell:unit_tests",
-    "//services/data_decoder:lib",
-    "//services/service_manager/public/cpp/test:test_support",
-    "//ui/gl:test_support",
-  ]
-
-  data_deps = [
-    "//third_party/mesa_headers",
-  ]
-}
-
 test("extensions_browsertests") {
   data = [
     "//extensions/test/data/",
diff --git a/extensions/browser/api/api_resource_manager.h b/extensions/browser/api/api_resource_manager.h
index ae047659934e..45c0e6572261 100644
--- a/extensions/browser/api/api_resource_manager.h
+++ b/extensions/browser/api/api_resource_manager.h
@@ -106,8 +106,11 @@ class ApiResourceManager : public BrowserContextKeyedAPI,
  public:
   explicit ApiResourceManager(content::BrowserContext* context)
       : data_(base::MakeRefCounted<ApiResourceData>()) {
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step 1";
     extension_registry_observer_.Add(ExtensionRegistry::Get(context));
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step 2";
     process_manager_observer_.Add(ProcessManager::Get(context));
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step 3";
   }
 
   virtual ~ApiResourceManager() {
@@ -387,10 +390,15 @@ template <class T>
 struct BrowserContextFactoryDependencies<ApiResourceManager<T>> {
   static void DeclareFactoryDependencies(
       BrowserContextKeyedAPIFactory<ApiResourceManager<T>>* factory) {
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Prestep A";
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step A";
     factory->DependsOn(
         ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step B";
     factory->DependsOn(ExtensionRegistryFactory::GetInstance());
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step C";
     factory->DependsOn(ProcessManagerFactory::GetInstance());
+LOG(ERROR) << "[Kiwi] Api Resource Manager - Step D";
   }
 };
 
diff --git a/extensions/browser/api/messaging/message_service.cc b/extensions/browser/api/messaging/message_service.cc
index c3918725562f..bd62f6e04f46 100644
--- a/extensions/browser/api/messaging/message_service.cc
+++ b/extensions/browser/api/messaging/message_service.cc
@@ -441,7 +441,7 @@ void MessageService::OpenChannelToNativeApp(
   channel->opener->IncrementLazyKeepaliveCount();
 
   AddChannel(std::move(channel), receiver_port_id);
-#else  // !(defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX))
+#elif 0  // !(defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX))
   const char kNativeMessagingNotSupportedError[] =
       "Native Messaging is not supported on this platform.";
   opener_port->DispatchOnDisconnect(kNativeMessagingNotSupportedError);
diff --git a/extensions/browser/api/socket/tcp_socket.cc b/extensions/browser/api/socket/tcp_socket.cc
index b01331a2c092..098a99325908 100644
--- a/extensions/browser/api/socket/tcp_socket.cc
+++ b/extensions/browser/api/socket/tcp_socket.cc
@@ -30,35 +30,8 @@ namespace extensions {
 
 namespace {
 
-// Returns true if successfully parsed the SSL protocol version that is
-// represented by a string. Returns false if |version_str| is invalid.
-bool SSLProtocolVersionFromString(const std::string& version_str,
-                                  network::mojom::SSLVersion* version_out) {
-  if (version_str == "tls1") {
-    *version_out = network::mojom::SSLVersion::kTLS1;
-    return true;
-  }
-  if (version_str == "tls1.1") {
-    *version_out = network::mojom::SSLVersion::kTLS11;
-    return true;
-  }
-  if (version_str == "tls1.2") {
-    *version_out = network::mojom::SSLVersion::kTLS12;
-    return true;
-  }
-  if (version_str == "tls1.3") {
-    *version_out = network::mojom::SSLVersion::kTLS13;
-    return true;
-  }
-  return false;
-}
-
 }  // namespace
 
-const char kTCPSocketTypeInvalidError[] =
-    "Cannot call both connect and listen on the same socket.";
-const char kSocketListenError[] = "Could not listen on the specified port.";
-
 static base::LazyInstance<BrowserContextKeyedAPIFactory<
     ApiResourceManager<ResumableTCPSocket>>>::DestructorAtExit g_factory =
     LAZY_INSTANCE_INITIALIZER;
@@ -85,7 +58,6 @@ TCPSocket::TCPSocket(content::BrowserContext* browser_context,
                      const std::string& owner_extension_id)
     : Socket(owner_extension_id),
       browser_context_(browser_context),
-      socket_mode_(UNKNOWN),
       mojo_data_pump_(nullptr),
       task_runner_(base::SequencedTaskRunnerHandle::Get()) {}
 
@@ -97,7 +69,6 @@ TCPSocket::TCPSocket(
     const std::string& owner_extension_id)
     : Socket(owner_extension_id),
       browser_context_(nullptr),
-      socket_mode_(CLIENT),
       client_socket_(std::move(socket)),
       mojo_data_pump_(std::make_unique<MojoDataPump>(std::move(receive_stream),
                                                      std::move(send_stream))),
@@ -113,7 +84,7 @@ TCPSocket::~TCPSocket() {
 void TCPSocket::Connect(const net::AddressList& address,
                         net::CompletionOnceCallback callback) {
   DCHECK(callback);
-
+#if 0
   if (socket_mode_ == SERVER || connect_callback_) {
     std::move(callback).Run(net::ERR_CONNECTION_FAILED);
     return;
@@ -144,6 +115,7 @@ void TCPSocket::Connect(const net::AddressList& address,
                                 storage_partition_, browser_context_, address,
                                 client_socket_.BindNewPipeAndPassReceiver(),
                                 std::move(completion_callback_ui)));
+#endif
 }
 
 void TCPSocket::Disconnect(bool socket_destroying) {
@@ -174,28 +146,6 @@ void TCPSocket::Bind(const std::string& address,
 
 void TCPSocket::Read(int count, ReadCompletionCallback callback) {
   DCHECK(callback);
-
-  const bool socket_destroying = false;
-  if (socket_mode_ != CLIENT) {
-    std::move(callback).Run(net::ERR_FAILED, nullptr, socket_destroying);
-    return;
-  }
-
-  if (!mojo_data_pump_) {
-    std::move(callback).Run(net::ERR_SOCKET_NOT_CONNECTED, nullptr,
-                            socket_destroying);
-    return;
-  }
-  if (mojo_data_pump_->HasPendingRead() || connect_callback_) {
-    // It's illegal to read a net::TCPSocket while a pending Connect or Read is
-    // already in progress.
-    std::move(callback).Run(net::ERR_IO_PENDING, nullptr, socket_destroying);
-    return;
-  }
-
-  read_callback_ = std::move(callback);
-  mojo_data_pump_->Read(count, base::BindOnce(&TCPSocket::OnReadComplete,
-                                              base::Unretained(this)));
 }
 
 void TCPSocket::RecvFrom(int count, RecvFromCompletionCallback callback) {
@@ -213,25 +163,16 @@ void TCPSocket::SendTo(scoped_refptr<net::IOBuffer> io_buffer,
 void TCPSocket::SetKeepAlive(bool enable,
                              int delay,
                              SetKeepAliveCallback callback) {
-  if (!client_socket_) {
-    std::move(callback).Run(net::ERR_FAILED);
-    return;
-  }
-  client_socket_->SetKeepAlive(enable, delay, std::move(callback));
 }
 
 void TCPSocket::SetNoDelay(bool no_delay, SetNoDelayCallback callback) {
-  if (!client_socket_) {
-    std::move(callback).Run(net::ERR_FAILED);
-    return;
-  }
-  client_socket_->SetNoDelay(no_delay, std::move(callback));
 }
 
 void TCPSocket::Listen(const std::string& address,
                        uint16_t port,
                        int backlog,
                        ListenCallback callback) {
+#if 0
   DCHECK(!server_socket_);
   DCHECK(!client_socket_);
   DCHECK(!listen_callback_);
@@ -269,9 +210,11 @@ void TCPSocket::Listen(const std::string& address,
                      browser_context_, ip_end_point, backlog,
                      server_socket_.BindNewPipeAndPassReceiver(),
                      std::move(completion_callback_ui)));
+#endif
 }
 
 void TCPSocket::Accept(AcceptCompletionCallback callback) {
+#if 0
   if (socket_mode_ != SERVER || !server_socket_) {
     std::move(callback).Run(net::ERR_FAILED, mojo::NullRemote(), base::nullopt,
                             mojo::ScopedDataPipeConsumerHandle(),
@@ -291,6 +234,7 @@ void TCPSocket::Accept(AcceptCompletionCallback callback) {
   server_socket_->Accept(
       mojo::NullRemote() /* observer */,
       base::BindOnce(&TCPSocket::OnAccept, base::Unretained(this)));
+#endif
 }
 
 bool TCPSocket::IsConnected() {
@@ -357,12 +301,6 @@ void TCPSocket::OnConnectCompleteOnUIThread(
     const base::Optional<net::IPEndPoint>& peer_addr,
     mojo::ScopedDataPipeConsumerHandle receive_stream,
     mojo::ScopedDataPipeProducerHandle send_stream) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  original_task_runner->PostTask(
-      FROM_HERE,
-      base::BindOnce(std::move(callback), result, local_addr, peer_addr,
-                     std::move(receive_stream), std::move(send_stream)));
 }
 
 void TCPSocket::OnConnectComplete(
@@ -371,18 +309,6 @@ void TCPSocket::OnConnectComplete(
     const base::Optional<net::IPEndPoint>& peer_addr,
     mojo::ScopedDataPipeConsumerHandle receive_stream,
     mojo::ScopedDataPipeProducerHandle send_stream) {
-  DCHECK(!is_connected_);
-  DCHECK(connect_callback_);
-  DCHECK(task_runner_->RunsTasksInCurrentSequence());
-
-  if (result == net::OK) {
-    is_connected_ = true;
-    local_addr_ = local_addr;
-    peer_addr_ = peer_addr;
-    mojo_data_pump_ = std::make_unique<MojoDataPump>(std::move(receive_stream),
-                                                     std::move(send_stream));
-  }
-  std::move(connect_callback_).Run(result);
 }
 
 // static
@@ -393,6 +319,7 @@ void TCPSocket::ListenOnUIThread(
     int backlog,
     mojo::PendingReceiver<network::mojom::TCPServerSocket> receiver,
     network::mojom::NetworkContext::CreateTCPServerSocketCallback callback) {
+#if 0
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   if (!storage_partition) {
@@ -404,6 +331,7 @@ void TCPSocket::ListenOnUIThread(
       net::MutableNetworkTrafficAnnotationTag(
           Socket::GetNetworkTrafficAnnotationTag()),
       std::move(receiver), std::move(callback));
+#endif
 }
 
 // static
@@ -412,25 +340,11 @@ void TCPSocket::OnListenCompleteOnUIThread(
     network::mojom::NetworkContext::CreateTCPServerSocketCallback callback,
     int result,
     const base::Optional<net::IPEndPoint>& local_addr) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  original_task_runner->PostTask(
-      FROM_HERE, base::BindOnce(std::move(callback), result, local_addr));
 }
 
 void TCPSocket::OnListenComplete(
     int result,
     const base::Optional<net::IPEndPoint>& local_addr) {
-  DCHECK(task_runner_->RunsTasksInCurrentSequence());
-  DCHECK(listen_callback_);
-
-  if (result != net::OK) {
-    server_socket_.reset();
-    std::move(listen_callback_).Run(result, kSocketListenError);
-    return;
-  }
-  local_addr_ = local_addr;
-  std::move(listen_callback_).Run(result, "");
 }
 
 content::StoragePartition* TCPSocket::GetStoragePartitionHelper() {
@@ -495,6 +409,7 @@ void TCPSocket::OnUpgradeToTLSComplete(
 
 void TCPSocket::UpgradeToTLS(api::socket::SecureOptions* options,
                              UpgradeToTLSCallback callback) {
+#if 0
   if (!client_socket_ || !mojo_data_pump_ ||
       mojo_data_pump_->HasPendingRead() || mojo_data_pump_->HasPendingWrite()) {
     std::move(callback).Run(net::ERR_FAILED, mojo::NullRemote(),
@@ -562,6 +477,7 @@ void TCPSocket::UpgradeToTLS(api::socket::SecureOptions* options,
       base::BindOnce(&TCPSocket::OnUpgradeToTLSComplete, base::Unretained(this),
                      std::move(callback), std::move(tls_socket),
                      local_addr_.value(), peer_addr_.value()));
+#endif
 }
 
 ResumableTCPSocket::ResumableTCPSocket(content::BrowserContext* browser_context,
diff --git a/extensions/browser/api/socket/tcp_socket.h b/extensions/browser/api/socket/tcp_socket.h
index 4f71a0819771..0dcd75c6a5f7 100644
--- a/extensions/browser/api/socket/tcp_socket.h
+++ b/extensions/browser/api/socket/tcp_socket.h
@@ -170,8 +170,6 @@ class TCPSocket : public Socket {
   // ApiResourceManager which is a BrowserContextKeyedAPI.
   content::BrowserContext* browser_context_;
 
-  SocketMode socket_mode_;
-
   // CLIENT mode.
   mojo::Remote<network::mojom::TCPConnectedSocket> client_socket_;
   // SERVER mode.
diff --git a/extensions/browser/api/system_cpu/BUILD.gn b/extensions/browser/api/system_cpu/BUILD.gn
index 16c1602d2890..e13dbda0a79a 100644
--- a/extensions/browser/api/system_cpu/BUILD.gn
+++ b/extensions/browser/api/system_cpu/BUILD.gn
@@ -11,6 +11,7 @@ source_set("system_cpu") {
   sources = [
     "cpu_info_provider.cc",
     "cpu_info_provider.h",
+    "cpu_info_provider_android.cc",
     "cpu_info_provider_linux.cc",
     "cpu_info_provider_mac.cc",
     "cpu_info_provider_win.cc",
diff --git a/extensions/browser/api/system_cpu/cpu_info_provider_android.cc b/extensions/browser/api/system_cpu/cpu_info_provider_android.cc
new file mode 100644
index 000000000000..2adbdb15f0f7
--- /dev/null
+++ b/extensions/browser/api/system_cpu/cpu_info_provider_android.cc
@@ -0,0 +1,77 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions/browser/api/system_cpu/cpu_info_provider.h"
+
+#include <stdint.h>
+
+#include <cstdio>
+#include <sstream>
+
+#include "base/files/file_util.h"
+#include "base/format_macros.h"
+
+namespace extensions {
+
+namespace {
+
+const char kProcStat[] = "/proc/stat";
+
+}  // namespace
+
+bool CpuInfoProvider::QueryCpuTimePerProcessor(
+    std::vector<api::system_cpu::ProcessorInfo>* infos) {
+  DCHECK(infos);
+
+  // WARNING: this method may return incomplete data because some processors may
+  // be brought offline at runtime. /proc/stat does not report statistics of
+  // offline processors. CPU usages of offline processors will be filled with
+  // zeros.
+  //
+  // An example of output of /proc/stat when processor 0 and 3 are online, but
+  // processor 1 and 2 are offline:
+  //
+  //   cpu  145292 20018 83444 1485410 995 44 3578 0 0 0
+  //   cpu0 138060 19947 78350 1479514 570 44 3576 0 0 0
+  //   cpu3 2033 32 1075 1400 52 0 1 0 0 0
+  std::string contents;
+  if (!base::ReadFileToString(base::FilePath(kProcStat), &contents))
+    return false;
+
+  std::istringstream iss(contents);
+  std::string line;
+
+  // Skip the first line because it is just an aggregated number of
+  // all cpuN lines.
+  std::getline(iss, line);
+  while (std::getline(iss, line)) {
+    if (line.compare(0, 3, "cpu") != 0)
+      continue;
+
+    uint64_t user = 0, nice = 0, sys = 0, idle = 0;
+    uint32_t pindex = 0;
+    int vals =
+        sscanf(line.c_str(),
+               "cpu%" PRIu32 " %" PRIu64 " %" PRIu64 " %" PRIu64 " %" PRIu64,
+               &pindex,
+               &user,
+               &nice,
+               &sys,
+               &idle);
+    if (vals != 5 || pindex >= infos->size()) {
+      NOTREACHED();
+      return false;
+    }
+
+    infos->at(pindex).usage.kernel = static_cast<double>(sys);
+    infos->at(pindex).usage.user = static_cast<double>(user + nice);
+    infos->at(pindex).usage.idle = static_cast<double>(idle);
+    infos->at(pindex).usage.total =
+        static_cast<double>(sys + user + nice + idle);
+  }
+
+  return true;
+}
+
+}  // namespace extensions
diff --git a/extensions/browser/extensions_browser_client.cc b/extensions/browser/extensions_browser_client.cc
index f2a503e5d6de..d508de715184 100644
--- a/extensions/browser/extensions_browser_client.cc
+++ b/extensions/browser/extensions_browser_client.cc
@@ -21,6 +21,7 @@ ExtensionsBrowserClient::ExtensionsBrowserClient() {}
 ExtensionsBrowserClient::~ExtensionsBrowserClient() = default;
 
 ExtensionsBrowserClient* ExtensionsBrowserClient::Get() {
+  LOG(ERROR) << "[Kiwi] ExtensionsBrowserClient::Get - Step: " << g_extension_browser_client;
   return g_extension_browser_client;
 }
 
diff --git a/extensions/browser/guest_view/web_view/web_view_guest.cc b/extensions/browser/guest_view/web_view/web_view_guest.cc
index 7ab074a466e6..2e172eea7042 100644
--- a/extensions/browser/guest_view/web_view/web_view_guest.cc
+++ b/extensions/browser/guest_view/web_view/web_view_guest.cc
@@ -145,6 +145,7 @@ static std::string TerminationStatusToString(base::TerminationStatus status) {
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED_BY_OOM:
       return "oom killed";
 #endif
+    case base::TERMINATION_STATUS_OOM_PROTECTED:
     case base::TERMINATION_STATUS_OOM:
       return "oom";
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED:
diff --git a/extensions/buildflags/buildflags.gni b/extensions/buildflags/buildflags.gni
index 6836e4ae3310..8a637a78a4c7 100644
--- a/extensions/buildflags/buildflags.gni
+++ b/extensions/buildflags/buildflags.gni
@@ -5,7 +5,7 @@
 import("//build/config/features.gni")
 
 declare_args() {
-  enable_extensions = !is_android && !is_ios && !is_fuchsia
+  enable_extensions = !is_ios && !is_fuchsia
 
   # Enables Wi-Fi Display functionality
   # WARNING: This enables MPEG Transport Stream (MPEG-TS) encoding!
diff --git a/google_apis/BUILD.gn b/google_apis/BUILD.gn
index 29d2d7596c89..c58bd1d2fb26 100644
--- a/google_apis/BUILD.gn
+++ b/google_apis/BUILD.gn
@@ -140,7 +140,7 @@ template("google_apis_tmpl") {
       "//services/network/public/cpp",
     ]
 
-    if (use_official_google_api_keys) {
+    if (false && use_official_google_api_keys) {
       deps += [ "internal:generate_metrics_key_header" ]
     }
 
diff --git a/mojo/public/js/mojo_bindings_resources.grd b/mojo/public/js/mojo_bindings_resources.grd
index 4f4db5fe4487..ec4923c33fc0 100644
--- a/mojo/public/js/mojo_bindings_resources.grd
+++ b/mojo/public/js/mojo_bindings_resources.grd
@@ -14,7 +14,7 @@
   <release seq="1">
     <includes>
       <!-- All resources included on Android should use the lite bindings. -->
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <include name="IDR_MOJO_MOJO_BINDINGS_JS"
             file="${root_gen_dir}/mojo/public/js/mojo_bindings.js"
             use_base_dir="false"
diff --git a/services/device/public/cpp/hid/BUILD.gn b/services/device/public/cpp/hid/BUILD.gn
index 3408f2bca518..686e7b30f92b 100644
--- a/services/device/public/cpp/hid/BUILD.gn
+++ b/services/device/public/cpp/hid/BUILD.gn
@@ -7,7 +7,7 @@ import("//build/config/features.gni")
 source_set("hid") {
   # HID is not implemented on Android and we want to be particularly careful
   # about not bloating binary size by accidentially including it.
-  assert(!is_android)
+#  assert(!is_android)
 
   sources = [
     "fake_input_service_linux.cc",
diff --git a/services/service_manager/embedder/main.cc b/services/service_manager/embedder/main.cc
index 53e9e0aafc49..b90f70422cf4 100644
--- a/services/service_manager/embedder/main.cc
+++ b/services/service_manager/embedder/main.cc
@@ -251,6 +251,8 @@ int Main(const MainParams& params) {
   MainDelegate* delegate = params.delegate;
   DCHECK(delegate);
 
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 1";
+
   int exit_code = -1;
   base::debug::GlobalActivityTracker* tracker = nullptr;
   ProcessType process_type = delegate->OverrideProcessType();
@@ -258,6 +260,7 @@ int Main(const MainParams& params) {
   std::unique_ptr<base::mac::ScopedNSAutoreleasePool> autorelease_pool;
 #endif
 
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 2";
   // A flag to indicate whether Main() has been called before. On Android, we
   // may re-run Main() without restarting the browser process. This flag
   // prevents initializing things more than once.
@@ -265,12 +268,15 @@ int Main(const MainParams& params) {
 #if !defined(OS_ANDROID)
   DCHECK(!is_initialized);
 #endif
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3";
   if (!is_initialized) {
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3a";
     is_initialized = true;
 #if defined(OS_MACOSX) && BUILDFLAG(USE_ALLOCATOR_SHIM)
     base::allocator::InitializeAllocatorShim();
 #endif
     base::EnableTerminationOnOutOfMemory();
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3b";
 
 #if defined(OS_LINUX)
     // The various desktop environments set this environment variable that
@@ -286,6 +292,7 @@ int Main(const MainParams& params) {
     setenv("DBUS_SESSION_BUS_ADDRESS", "disabled:", kNoOverrideIfAlreadySet);
 #endif
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3c";
 #if defined(OS_WIN)
     base::win::RegisterInvalidParamHandler();
     ui::win::CreateATLModuleIfNeeded();
@@ -301,17 +308,20 @@ int Main(const MainParams& params) {
     argc = params.argc;
     argv = params.argv;
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3d";
 
     base::CommandLine::Init(argc, argv);
 
 #if defined(OS_POSIX)
     PopulateFDsFromCommandLine();
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3e";
 
     base::EnableTerminationOnHeapCorruption();
 
     SetProcessTitleFromCommandLine(argv);
 #endif  // !defined(OS_ANDROID)
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3f";
 
 // On Android setlocale() is not supported, and we don't override the signal
 // handlers so we can get a stack trace when crashing.
@@ -332,6 +342,7 @@ int Main(const MainParams& params) {
 
     SetupSignalHandlers();
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3g";
 
     const auto& command_line = *base::CommandLine::ForCurrentProcess();
 
@@ -339,6 +350,7 @@ int Main(const MainParams& params) {
     base::win::SetupCRT(command_line);
 #endif
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3h";
     MainDelegate::InitializeParams init_params;
 
 #if defined(OS_MACOSX)
@@ -350,6 +362,7 @@ int Main(const MainParams& params) {
     init_params.autorelease_pool = autorelease_pool.get();
     InitializeMac();
 #endif
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3i";
 
     mojo::core::Configuration mojo_config;
     if (process_type == ProcessType::kDefault &&
@@ -357,16 +370,21 @@ int Main(const MainParams& params) {
             switches::kProcessTypeServiceManager) {
       mojo_config.is_broker_process = true;
     }
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3j";
     mojo_config.max_message_num_bytes = kMaximumMojoMessageSize;
     delegate->OverrideMojoConfiguration(&mojo_config);
     mojo::core::Init(mojo_config);
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3k";
     ui::RegisterPathProvider();
 
     tracker = base::debug::GlobalActivityTracker::Get();
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3l";
     exit_code = delegate->Initialize(init_params);
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3m";
     if (exit_code >= 0) {
       if (tracker) {
+        LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3n";
         tracker->SetProcessPhase(
             base::debug::GlobalActivityTracker::PROCESS_LAUNCH_FAILED);
         tracker->process_data().SetInt("exit-code", exit_code);
@@ -374,6 +392,7 @@ int Main(const MainParams& params) {
       return exit_code;
     }
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3o";
 #if defined(OS_WIN)
     // Route stdio to parent console (if any) or create one.
     if (base::CommandLine::ForCurrentProcess()->HasSwitch(
@@ -382,6 +401,7 @@ int Main(const MainParams& params) {
     }
 #endif
 
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 3p";
     if (base::CommandLine::ForCurrentProcess()->HasSwitch(
             ::switches::kTraceToConsole)) {
       base::trace_event::TraceConfig trace_config =
@@ -391,6 +411,7 @@ int Main(const MainParams& params) {
     }
   }
 
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 4";
   const auto& command_line = *base::CommandLine::ForCurrentProcess();
   if (process_type == ProcessType::kDefault) {
     std::string type_switch =
@@ -403,21 +424,26 @@ int Main(const MainParams& params) {
       process_type = ProcessType::kEmbedder;
     }
   }
+  LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5";
   switch (process_type) {
     case ProcessType::kDefault:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5a";
       NOTREACHED();
       break;
 
     case ProcessType::kServiceManager:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5b";
       exit_code = RunServiceManager(delegate);
       break;
 
     case ProcessType::kService:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5c";
       CommonSubprocessInit();
       exit_code = RunService(delegate);
       break;
 
     case ProcessType::kEmbedder:
+      LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5d";
       if (delegate->IsEmbedderSubprocess())
         CommonSubprocessInit();
       exit_code = delegate->RunEmbedderProcess();
@@ -425,6 +451,7 @@ int Main(const MainParams& params) {
   }
 
   if (tracker) {
+    LOG(ERROR) << "[Kiwi] Embedder::Main - Step 5e";
     if (exit_code == 0) {
       tracker->SetProcessPhaseIfEnabled(
           base::debug::GlobalActivityTracker::PROCESS_EXITED_CLEANLY);
diff --git a/services/tracing/public/cpp/trace_startup.cc b/services/tracing/public/cpp/trace_startup.cc
index 3827c2a8f9f2..a7be4fe0eab4 100644
--- a/services/tracing/public/cpp/trace_startup.cc
+++ b/services/tracing/public/cpp/trace_startup.cc
@@ -100,8 +100,11 @@ void InitTracingPostThreadPoolStartAndFeatureList() {
   // TODO(nuskos): We should switch these to DCHECK once we're reasonably
   // confident we've ensured this is called properly in all processes. Probably
   // after M78 release has been cut (since we'll verify in the rollout of M78).
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 3: " << base::ThreadPoolInstance::Get();
   CHECK(base::ThreadPoolInstance::Get());
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 4: " << base::FeatureList::GetInstance();
   CHECK(base::FeatureList::GetInstance());
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 5";
   // Below are the things tracing must do once per process.
   TraceEventDataSource::GetInstance()->OnTaskSchedulerAvailable();
   if (ShouldSetupSystemTracing()) {
@@ -111,6 +114,7 @@ void InitTracingPostThreadPoolStartAndFeatureList() {
     // state. This Get() call ensures that the constructor has run.
     PerfettoTracedProcess::Get();
   }
+  LOG(ERROR) << "[Kiwi] InitTracingPostThreadPoolStartAndFeatureList - Step 6";
 }
 
 void PropagateTracingFlagsToChildProcessCmdLine(base::CommandLine* cmd_line) {
diff --git a/third_party/blink/public/mojom/BUILD.gn b/third_party/blink/public/mojom/BUILD.gn
index 687a0ba72ecb..736efffdecc3 100644
--- a/third_party/blink/public/mojom/BUILD.gn
+++ b/third_party/blink/public/mojom/BUILD.gn
@@ -153,7 +153,7 @@ mojom("mojom_platform") {
     "worker/worker_main_script_load_params.mojom",
   ]
 
-  if (!is_android) {
+  if (true || !is_android) {
     sources += [ "serial/serial.mojom" ]
   }
 
diff --git a/ui/android/window_android.h b/ui/android/window_android.h
index e9dfbc755172..b21643e8a5d5 100644
--- a/ui/android/window_android.h
+++ b/ui/android/window_android.h
@@ -54,6 +54,14 @@ class UI_ANDROID_EXPORT WindowAndroid : public ViewAndroid {
 
   base::android::ScopedJavaLocalRef<jobject> GetJavaObject();
 
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::PointF* point);
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::Point* point);
+
+
   // Compositor callback relay.
   void OnCompositingDidCommit();
 
diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index 224ced89a428..6b2f4dcba89b 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -447,6 +447,11 @@ jumbo_component("base") {
     deps += [ "//third_party/re2" ]
   }
 
+  sources += [
+    "dragdrop/os_exchange_data_provider_android.cc",
+    "dragdrop/os_exchange_data_provider_android.h",
+  ]
+
   if (!is_ios) {
     # iOS does not use Chromium-specific code for event handling.
     public_deps += [
@@ -607,7 +612,7 @@ jumbo_component("base") {
     ]
   }
 
-  if (!toolkit_views && !use_aura) {
+  if (false && !toolkit_views && !use_aura) {
     sources -= [
       "dragdrop/drag_drop_types.h",
       "dragdrop/drop_target_event.cc",
@@ -624,16 +629,6 @@ jumbo_component("base") {
   if (is_android) {
     deps += [ ":ui_base_jni_headers" ]
     libs += [ "jnigraphics" ]
-
-    sources -= [
-      "cursor/cursor_android.cc",
-      "default_theme_provider.cc",
-      "l10n/l10n_font_util.cc",
-      "models/button_menu_item_model.cc",
-      "pointer/touch_editing_controller.cc",
-      "theme_provider.cc",
-      "ui_base_types.cc",
-    ]
   }
 
   if (use_aura) {
diff --git a/ui/base/cursor/cursor.cc b/ui/base/cursor/cursor.cc
index be37579590ec..e4e62e4aa97c 100644
--- a/ui/base/cursor/cursor.cc
+++ b/ui/base/cursor/cursor.cc
@@ -36,7 +36,7 @@ void Cursor::SetPlatformCursor(const PlatformCursor& platform) {
     RefCustomCursor();
 }
 
-#if !defined(USE_AURA)
+#if false && !defined(USE_AURA)
 void Cursor::RefCustomCursor() {
   NOTIMPLEMENTED();
 }
diff --git a/ui/base/dragdrop/os_exchange_data.cc b/ui/base/dragdrop/os_exchange_data.cc
index 4af8c7b6fcd3..1aa1cc7d963c 100644
--- a/ui/base/dragdrop/os_exchange_data.cc
+++ b/ui/base/dragdrop/os_exchange_data.cc
@@ -114,7 +114,7 @@ bool OSExchangeData::HasAnyFormat(
   if ((formats & FILE_CONTENTS) != 0 && provider_->HasFileContents())
     return true;
 #endif
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
   if ((formats & HTML) != 0 && provider_->HasHtml())
     return true;
 #endif
@@ -159,7 +159,7 @@ void OSExchangeData::SetDownloadFileInfo(DownloadFileInfo* download) {
 }
 #endif
 
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
 bool OSExchangeData::HasHtml() const {
   return provider_->HasHtml();
 }
diff --git a/ui/base/dragdrop/os_exchange_data.h b/ui/base/dragdrop/os_exchange_data.h
index 484e0df3dfef..dff0c7b94077 100644
--- a/ui/base/dragdrop/os_exchange_data.h
+++ b/ui/base/dragdrop/os_exchange_data.h
@@ -63,7 +63,7 @@ class UI_BASE_EXPORT OSExchangeData {
 #if defined(OS_WIN)
     FILE_CONTENTS  = 1 << 4,
 #endif
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
     HTML           = 1 << 5,
 #endif
   };
@@ -138,13 +138,13 @@ class UI_BASE_EXPORT OSExchangeData {
     virtual void SetDownloadFileInfo(DownloadFileInfo* download) = 0;
 #endif
 
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
     virtual void SetHtml(const base::string16& html, const GURL& base_url) = 0;
     virtual bool GetHtml(base::string16* html, GURL* base_url) const = 0;
     virtual bool HasHtml() const = 0;
 #endif
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if true || defined(USE_AURA) || defined(OS_MACOSX)
     virtual void SetDragImage(const gfx::ImageSkia& image,
                               const gfx::Vector2d& cursor_offset) = 0;
     virtual gfx::ImageSkia GetDragImage() const = 0;
@@ -269,7 +269,7 @@ class UI_BASE_EXPORT OSExchangeData {
   void SetDownloadFileInfo(DownloadFileInfo* download);
 #endif
 
-#if defined(USE_AURA)
+#if true || defined(USE_AURA)
   // Adds a snippet of HTML.  |html| is just raw html but this sets both
   // text/html and CF_HTML.
   void SetHtml(const base::string16& html, const GURL& base_url);
diff --git a/ui/base/dragdrop/os_exchange_data_provider_android.cc b/ui/base/dragdrop/os_exchange_data_provider_android.cc
new file mode 100644
index 000000000000..530c1e4ac627
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.cc
@@ -0,0 +1,220 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
+#include "base/logging.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
+#include "ui/base/dragdrop/file_info.h"
+
+namespace ui {
+
+OSExchangeDataProviderAndroid::OSExchangeDataProviderAndroid()
+    : formats_(0) {
+}
+
+OSExchangeDataProviderAndroid::~OSExchangeDataProviderAndroid() = default;
+
+std::unique_ptr<OSExchangeData::Provider>
+OSExchangeDataProviderAndroid::Clone() const {
+  OSExchangeDataProviderAndroid* ret = new OSExchangeDataProviderAndroid();
+  ret->formats_ = formats_;
+  ret->string_ = string_;
+  ret->url_ = url_;
+  ret->title_ = title_;
+  ret->filenames_ = filenames_;
+  ret->pickle_data_ = pickle_data_;
+  // We skip copying the drag images.
+  ret->html_ = html_;
+  ret->base_url_ = base_url_;
+
+  return base::WrapUnique<OSExchangeData::Provider>(ret);
+}
+
+void OSExchangeDataProviderAndroid::MarkOriginatedFromRenderer() {
+  // TODO(dcheng): Currently unneeded because ChromeOS Android correctly separates
+  // URL and filename metadata, and does not implement the DownloadURL protocol.
+}
+
+bool OSExchangeDataProviderAndroid::DidOriginateFromRenderer() const {
+  return false;
+}
+
+void OSExchangeDataProviderAndroid::SetString(const base::string16& data) {
+  if (HasString())
+    return;
+
+  string_ = data;
+  formats_ |= OSExchangeData::STRING;
+}
+
+void OSExchangeDataProviderAndroid::SetURL(const GURL& url,
+                                        const base::string16& title) {
+  url_ = url;
+  title_ = title;
+  formats_ |= OSExchangeData::URL;
+
+  SetString(base::UTF8ToUTF16(url.spec()));
+}
+
+void OSExchangeDataProviderAndroid::SetFilename(const base::FilePath& path) {
+  filenames_.clear();
+  filenames_.push_back(FileInfo(path, base::FilePath()));
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetFilenames(
+    const std::vector<FileInfo>& filenames) {
+  filenames_ = filenames;
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetPickledData(
+    const ClipboardFormatType& format,
+    const base::Pickle& data) {
+  pickle_data_[format] = data;
+  formats_ |= OSExchangeData::PICKLED_DATA;
+}
+
+bool OSExchangeDataProviderAndroid::GetString(base::string16* data) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+  *data = string_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetURLAndTitle(
+    OSExchangeData::FilenameToURLPolicy policy,
+    GURL* url,
+    base::string16* title) const {
+  if ((formats_ & OSExchangeData::URL) == 0) {
+    title->clear();
+    return GetPlainTextURL(url) ||
+           (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(url));
+  }
+
+  if (!url_.is_valid())
+    return false;
+
+  *url = url_;
+  *title = title_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilename(base::FilePath* path) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  DCHECK(!filenames_.empty());
+  *path = filenames_[0].path;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilenames(
+    std::vector<FileInfo>* filenames) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  *filenames = filenames_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPickledData(
+    const ClipboardFormatType& format,
+    base::Pickle* data) const {
+  PickleData::const_iterator i = pickle_data_.find(format);
+  if (i == pickle_data_.end())
+    return false;
+
+  *data = i->second;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasString() const {
+  return (formats_ & OSExchangeData::STRING) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasURL(
+    OSExchangeData::FilenameToURLPolicy policy) const {
+  if ((formats_ & OSExchangeData::URL) != 0) {
+    return true;
+  }
+  // No URL, see if we have plain text that can be parsed as a URL.
+  return GetPlainTextURL(NULL) ||
+         (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(nullptr));
+}
+
+bool OSExchangeDataProviderAndroid::HasFile() const {
+  return (formats_ & OSExchangeData::FILE_NAME) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasCustomFormat(
+    const ClipboardFormatType& format) const {
+  return pickle_data_.find(format) != pickle_data_.end();
+}
+
+void OSExchangeDataProviderAndroid::SetHtml(const base::string16& html,
+                                         const GURL& base_url) {
+  formats_ |= OSExchangeData::HTML;
+  html_ = html;
+  base_url_ = base_url;
+}
+
+bool OSExchangeDataProviderAndroid::GetHtml(base::string16* html,
+                                         GURL* base_url) const {
+  if ((formats_ & OSExchangeData::HTML) == 0)
+    return false;
+  *html = html_;
+  *base_url = base_url_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasHtml() const {
+  return ((formats_ & OSExchangeData::HTML) != 0);
+}
+
+void OSExchangeDataProviderAndroid::SetDragImage(
+    const gfx::ImageSkia& image,
+    const gfx::Vector2d& cursor_offset) {
+  drag_image_ = image;
+  drag_image_offset_ = cursor_offset;
+}
+
+gfx::ImageSkia OSExchangeDataProviderAndroid::GetDragImage() const {
+  return drag_image_;
+}
+
+gfx::Vector2d OSExchangeDataProviderAndroid::GetDragImageOffset() const {
+  return drag_image_offset_;
+}
+
+bool OSExchangeDataProviderAndroid::GetFileURL(GURL* url) const {
+  base::FilePath file_path;
+  if (!GetFilename(&file_path))
+    return false;
+
+  GURL test_url = net::FilePathToFileURL(file_path);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPlainTextURL(GURL* url) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+
+  GURL test_url(string_);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+}  // namespace ui
diff --git a/ui/base/dragdrop/os_exchange_data_provider_android.h b/ui/base/dragdrop/os_exchange_data_provider_android.h
new file mode 100644
index 000000000000..e76e9d6973d3
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.h
@@ -0,0 +1,101 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+
+#include <map>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/pickle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/gfx/geometry/vector2d.h"
+#include "ui/gfx/image/image_skia.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+struct ClipboardFormatType;
+
+// OSExchangeData::Provider implementation for Android on linux.
+class UI_BASE_EXPORT OSExchangeDataProviderAndroid
+    : public OSExchangeData::Provider {
+ public:
+  OSExchangeDataProviderAndroid();
+  ~OSExchangeDataProviderAndroid() override;
+
+  // Overridden from OSExchangeData::Provider:
+  std::unique_ptr<Provider> Clone() const override;
+  void MarkOriginatedFromRenderer() override;
+  bool DidOriginateFromRenderer() const override;
+  void SetString(const base::string16& data) override;
+  void SetURL(const GURL& url, const base::string16& title) override;
+  void SetFilename(const base::FilePath& path) override;
+  void SetFilenames(const std::vector<FileInfo>& filenames) override;
+  void SetPickledData(const ClipboardFormatType& format,
+                      const base::Pickle& data) override;
+  bool GetString(base::string16* data) const override;
+  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
+                      GURL* url,
+                      base::string16* title) const override;
+  bool GetFilename(base::FilePath* path) const override;
+  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
+  bool GetPickledData(const ClipboardFormatType& format,
+                      base::Pickle* data) const override;
+  bool HasString() const override;
+  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
+  bool HasFile() const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
+
+  void SetHtml(const base::string16& html, const GURL& base_url) override;
+  bool GetHtml(base::string16* html, GURL* base_url) const override;
+  bool HasHtml() const override;
+  void SetDragImage(const gfx::ImageSkia& image,
+                    const gfx::Vector2d& cursor_offset) override;
+  gfx::ImageSkia GetDragImage() const override;
+  gfx::Vector2d GetDragImageOffset() const override;
+
+ private:
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
+
+  // Returns true if |formats_| contains a file format and the file name can be
+  // parsed as a URL.
+  bool GetFileURL(GURL* url) const;
+
+  // Returns true if |formats_| contains a string format and the string can be
+  // parsed as a URL.
+  bool GetPlainTextURL(GURL* url) const;
+
+  // Actual formats that have been set. See comment above |known_formats_|
+  // for details.
+  int formats_;
+
+  // String contents.
+  base::string16 string_;
+
+  // URL contents.
+  GURL url_;
+  base::string16 title_;
+
+  // File name.
+  std::vector<FileInfo> filenames_;
+
+  // PICKLED_DATA contents.
+  PickleData pickle_data_;
+
+  // Drag image and offset data.
+  gfx::ImageSkia drag_image_;
+  gfx::Vector2d drag_image_offset_;
+
+  // For HTML format
+  base::string16 html_;
+  GURL base_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAndroid);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
diff --git a/ui/base/dragdrop/os_exchange_data_provider_factory.cc b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
index 4c5fbfbc079a..6ed61179eadf 100644
--- a/ui/base/dragdrop/os_exchange_data_provider_factory.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
@@ -16,6 +16,8 @@
 #include "ui/base/dragdrop/os_exchange_data_provider_win.h"
 #endif
 
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
 namespace ui {
 
 //static
@@ -34,7 +36,7 @@ OSExchangeDataProviderFactory::CreateProvider() {
   NOTIMPLEMENTED();
   return nullptr;
 #else
-#error "Unknown operating system"
+  return std::make_unique<OSExchangeDataProviderAndroid>();
 #endif
 }
 
diff --git a/ui/events/event.h b/ui/events/event.h
index f38982eda75b..f25cdf84a170 100644
--- a/ui/events/event.h
+++ b/ui/events/event.h
@@ -29,6 +29,7 @@
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/geometry/point_conversions.h"
 #include "ui/latency/latency_info.h"
+#include "ui/android/window_android.h"
 
 namespace gfx {
 class Transform;
diff --git a/ui/gfx/BUILD.gn b/ui/gfx/BUILD.gn
index 164089b84732..1e47a951f680 100644
--- a/ui/gfx/BUILD.gn
+++ b/ui/gfx/BUILD.gn
@@ -405,13 +405,6 @@ jumbo_component("gfx") {
     ]
   }
 
-  if ((!use_aura && !toolkit_views) || is_ios) {
-    sources -= [
-      "nine_image_painter.cc",
-      "nine_image_painter.h",
-    ]
-  }
-
   if (use_x11) {
     deps += [ "//ui/gfx/x" ]
     configs += [ "//build/config/linux:x11" ]
diff --git a/ui/message_center/BUILD.gn b/ui/message_center/BUILD.gn
index 9ca2f4b5ce17..3b84024d8675 100644
--- a/ui/message_center/BUILD.gn
+++ b/ui/message_center/BUILD.gn
@@ -38,7 +38,7 @@ jumbo_component("message_center") {
 
   defines = [ "MESSAGE_CENTER_IMPLEMENTATION" ]
 
-  if (enable_message_center) {
+  if (true || enable_message_center) {
     deps += [
       ":message_center_vector_icons",
       "//base:i18n",
@@ -90,7 +90,7 @@ jumbo_component("message_center") {
       ]
     }
 
-    if (toolkit_views) {
+    if (true || toolkit_views) {
       sources += [
         "views/desktop_message_popup_collection.cc",
         "views/desktop_message_popup_collection.h",
diff --git a/ui/native_theme/native_theme_android.cc b/ui/native_theme/native_theme_android.cc
index 1a33a8f3496a..b14357344315 100644
--- a/ui/native_theme/native_theme_android.cc
+++ b/ui/native_theme/native_theme_android.cc
@@ -22,8 +22,7 @@ NativeTheme* NativeTheme::GetInstanceForWeb() {
 }
 
 NativeTheme* NativeTheme::GetInstanceForNativeUi() {
-  NOTREACHED();
-  return nullptr;
+  return NativeThemeAndroid::instance();
 }
 #endif
 
diff --git a/ui/native_theme/native_theme_android.h b/ui/native_theme/native_theme_android.h
index 6d5c3811a0fa..30185986a2ce 100644
--- a/ui/native_theme/native_theme_android.h
+++ b/ui/native_theme/native_theme_android.h
@@ -20,11 +20,11 @@ class NativeThemeAndroid : public NativeThemeBase {
                         const ExtraParams& extra) const override;
   SkColor GetSystemColor(ColorId color_id,
                          ColorScheme color_scheme) const override;
+  static NativeThemeAndroid* instance();
 
  protected:
   friend class NativeTheme;
   friend class base::NoDestructor<NativeThemeAndroid>;
-  static NativeThemeAndroid* instance();
 
   // NativeThemeBase:
   void AdjustCheckboxRadioRectForPadding(SkRect* rect) const override;
diff --git a/ui/resources/BUILD.gn b/ui/resources/BUILD.gn
index a1be35643a27..bc5054a71373 100644
--- a/ui/resources/BUILD.gn
+++ b/ui/resources/BUILD.gn
@@ -209,7 +209,7 @@ repack("repack_ui_test_pak_100_percent") {
     ]
   }
 
-  if (toolkit_views) {
+  if (true || toolkit_views) {
     deps += [ "//ui/views/resources" ]
     sources += [
       "$root_gen_dir/third_party/blink/public/resources/blink_resources.pak",
@@ -238,7 +238,7 @@ repack("repack_ui_test_pak_200_percent") {
     "//ui/resources",
   ]
 
-  if (toolkit_views) {
+  if (true || toolkit_views) {
     deps += [ "//ui/views/resources" ]
     sources +=
         [ "$root_gen_dir/ui/views/resources/views_resources_200_percent.pak" ]
diff --git a/ui/resources/ui_resources.grd b/ui/resources/ui_resources.grd
index 5f88d78bfdea..398bdfe05624 100644
--- a/ui/resources/ui_resources.grd
+++ b/ui/resources/ui_resources.grd
@@ -78,7 +78,7 @@
         <structure type="chrome_scaled_image" name="IDR_AURA_CURSOR_ZOOM_IN" file="common/pointers/zoom_in.png" />
         <structure type="chrome_scaled_image" name="IDR_AURA_CURSOR_ZOOM_OUT" file="common/pointers/zoom_out.png" />
       </if>
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_CLOSE_2" file="close_2.png" />
         <structure type="chrome_scaled_image" name="IDR_CLOSE_2_H" file="close_2_hover.png" />
         <structure type="chrome_scaled_image" name="IDR_CLOSE_2_MASK" file="close_2_mask.png" />
@@ -92,7 +92,7 @@
       </if>
       <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON" file="common/default_favicon.png" />
       <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_DARK" file="common/default_favicon_dark.png" />
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_32" file="common/default_favicon_32.png" />
         <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_DARK_32" file="common/default_favicon_dark_32.png" />
         <structure type="chrome_scaled_image" name="IDR_DEFAULT_FAVICON_64" file="common/default_favicon_64.png" />
@@ -134,7 +134,7 @@
       <if expr="toolkit_views and not is_macosx">
         <structure type="chrome_scaled_image" name="IDR_NOTIFICATION_SETTINGS" file="common/notification_settings.png"/>
       </if>
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <structure type="chrome_scaled_image" name="IDR_NTP_DEFAULT_FAVICON" file="common/ntp_default_favicon.png" />
       </if>
       <if expr="not is_android and not is_ios">
@@ -142,7 +142,7 @@
         <structure type="chrome_scaled_image" name="IDR_OOBE_ACTION_BOX_BUTTON_NORMAL" file="cros/action_box_button_normal.png" />
         <structure type="chrome_scaled_image" name="IDR_OOBE_ACTION_BOX_BUTTON_PRESSED" file="cros/action_box_button_pressed.png" />
       </if>
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <structure type="chrome_scaled_image" name="IDR_SIGNAL_0_BAR" file="common/signal_0_bar.png" />
         <structure type="chrome_scaled_image" name="IDR_SIGNAL_1_BAR" file="common/signal_1_bar.png" />
         <structure type="chrome_scaled_image" name="IDR_SIGNAL_2_BAR" file="common/signal_2_bar.png" />
diff --git a/ui/views/BUILD.gn b/ui/views/BUILD.gn
index 4c814e4495d3..31348e6770de 100644
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -12,7 +12,7 @@ import("//ui/base/ui_features.gni")
 import("//ui/ozone/ozone.gni")
 import("//ui/views/features.gni")
 
-assert(toolkit_views)
+# assert(toolkit_views)
 
 # Reset sources_assignment_filter for the BUILD.gn file to prevent
 # regression during the migration of Chromium away from the feature.
@@ -200,6 +200,7 @@ jumbo_component("views") {
     "drag_controller.h",
     "drag_utils.h",
     "event_monitor.h",
+    "event_monitor_android.h",
     "event_monitor_mac.h",
     "focus/external_focus_tracker.h",
     "focus/focus_manager.h",
@@ -260,6 +261,8 @@ jumbo_component("views") {
     "views_touch_selection_controller_factory.h",
     "widget/drop_helper.h",
     "widget/native_widget.h",
+    "widget/native_widget_aura.h",
+    "widget/native_widget_android.h",
     "widget/native_widget_delegate.h",
     "widget/native_widget_mac.h",
     "widget/native_widget_private.h",
@@ -355,8 +358,6 @@ jumbo_component("views") {
     "controls/image_view.cc",
     "controls/label.cc",
     "controls/link.cc",
-    "controls/menu/menu_closure_animation_mac.mm",
-    "controls/menu/menu_cocoa_watcher_mac.mm",
     "controls/menu/menu_config.cc",
     "controls/menu/menu_controller.cc",
     "controls/menu/menu_delegate.cc",
@@ -658,6 +659,17 @@ jumbo_component("views") {
     ]
   }
 
+  sources += [
+      "native_cursor_android.cc",
+      "controls/native/native_view_host_android.cc",
+      "event_monitor_android.cc",
+      "widget/native_widget_android.cc",
+  ]
+
+  public += [
+      "controls/native/native_view_host_android.h",
+  ]
+
   if (use_aura) {
     public += [
       "accessibility/accessibility_alert_window.h",
@@ -682,6 +694,7 @@ jumbo_component("views") {
       "view_constants_aura.h",
       "widget/focus_manager_event_handler.h",
       "widget/native_widget_aura.h",
+      "widget/native_widget_android.h",
       "widget/tooltip_manager_aura.h",
       "widget/window_reorderer.h",
     ]
diff --git a/ui/views/controls/menu/menu_config_android.cc b/ui/views/controls/menu/menu_config_android.cc
new file mode 100644
index 000000000000..ded2045a5536
--- /dev/null
+++ b/ui/views/controls/menu/menu_config_android.cc
@@ -0,0 +1,13 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/controls/menu/menu_config.h"
+
+namespace views {
+
+void MenuConfig::Init() {
+  arrow_to_edge_padding = 6;
+}
+
+}  // namespace views
diff --git a/ui/views/controls/menu/menu_controller.cc b/ui/views/controls/menu/menu_controller.cc
index bbb1cc387eb2..6f80c431db9b 100644
--- a/ui/views/controls/menu/menu_controller.cc
+++ b/ui/views/controls/menu/menu_controller.cc
@@ -497,10 +497,6 @@ void MenuController::Run(Widget* parent,
     owner_ = parent;
     if (owner_)
       owner_->AddObserver(this);
-
-    // Only create a MenuPreTargetHandler for non-nested menus. Nested menus
-    // will use the existing one.
-    menu_pre_target_handler_ = MenuPreTargetHandler::Create(this, owner_);
   }
 
 #if defined(OS_MACOSX)
@@ -862,8 +858,6 @@ void MenuController::OnGestureEvent(SubmenuView* source,
 #if defined(OS_MACOSX)
     NOTIMPLEMENTED();
 #else   // !defined(OS_MACOSX)
-    event->ConvertLocationToTarget(source->GetWidget()->GetNativeWindow(),
-                                   owner()->GetNativeWindow());
 #endif  // defined(OS_MACOSX)
     owner()->OnGestureEvent(event);
     // Reset |send_gesture_events_to_owner_| when the first gesture ends.
@@ -1012,42 +1006,7 @@ int MenuController::OnDragUpdated(SubmenuView* source,
     if (menu_item)
       over_empty_menu = true;
   }
-  MenuDelegate::DropPosition drop_position = MenuDelegate::DropPosition::kNone;
   int drop_operation = ui::DragDropTypes::DRAG_NONE;
-  if (menu_item) {
-    gfx::Point menu_item_loc(event.location());
-    View::ConvertPointToTarget(source, menu_item, &menu_item_loc);
-    MenuItemView* query_menu_item;
-    if (!over_empty_menu) {
-      int menu_item_height = menu_item->height();
-      if (menu_item->HasSubmenu() &&
-          (menu_item_loc.y() > kDropBetweenPixels &&
-           menu_item_loc.y() < (menu_item_height - kDropBetweenPixels))) {
-        drop_position = MenuDelegate::DropPosition::kOn;
-      } else {
-        drop_position = (menu_item_loc.y() < menu_item_height / 2)
-                            ? MenuDelegate::DropPosition::kBefore
-                            : MenuDelegate::DropPosition::kAfter;
-      }
-      query_menu_item = menu_item;
-    } else {
-      query_menu_item = menu_item->GetParentMenuItem();
-      drop_position = MenuDelegate::DropPosition::kOn;
-    }
-    drop_operation = menu_item->GetDelegate()->GetDropOperation(
-        query_menu_item, event, &drop_position);
-
-    // If the menu has a submenu, schedule the submenu to open.
-    SetSelection(menu_item, menu_item->HasSubmenu() ? SELECTION_OPEN_SUBMENU
-                                                    : SELECTION_DEFAULT);
-
-    if (drop_position == MenuDelegate::DropPosition::kNone ||
-        drop_operation == ui::DragDropTypes::DRAG_NONE)
-      menu_item = nullptr;
-  } else {
-    SetSelection(source->GetMenuItem(), SELECTION_OPEN_SUBMENU);
-  }
-  SetDropMenuItem(menu_item, drop_position);
   last_drop_operation_ = drop_operation;
   return drop_operation;
 }
@@ -2869,34 +2828,6 @@ void MenuController::UpdateActiveMouseView(SubmenuView* event_source,
     if (target == target_menu || !target->GetEnabled())
       target = nullptr;
   }
-  View* active_mouse_view = active_mouse_view_tracker_->view();
-  if (target != active_mouse_view) {
-    SendMouseCaptureLostToActiveView();
-    active_mouse_view = target;
-    active_mouse_view_tracker_->SetView(active_mouse_view);
-    if (active_mouse_view) {
-      gfx::Point target_point(target_menu_loc);
-      View::ConvertPointToTarget(target_menu, active_mouse_view, &target_point);
-      ui::MouseEvent mouse_entered_event(ui::ET_MOUSE_ENTERED, target_point,
-                                         target_point, ui::EventTimeForNow(), 0,
-                                         0);
-      active_mouse_view->OnMouseEntered(mouse_entered_event);
-
-      ui::MouseEvent mouse_pressed_event(
-          ui::ET_MOUSE_PRESSED, target_point, target_point,
-          ui::EventTimeForNow(), event.flags(), event.changed_button_flags());
-      active_mouse_view->OnMousePressed(mouse_pressed_event);
-    }
-  }
-
-  if (active_mouse_view) {
-    gfx::Point target_point(target_menu_loc);
-    View::ConvertPointToTarget(target_menu, active_mouse_view, &target_point);
-    ui::MouseEvent mouse_dragged_event(
-        ui::ET_MOUSE_DRAGGED, target_point, target_point, ui::EventTimeForNow(),
-        event.flags(), event.changed_button_flags());
-    active_mouse_view->OnMouseDragged(mouse_dragged_event);
-  }
 }
 
 void MenuController::SendMouseReleaseToActiveView(SubmenuView* event_source,
diff --git a/ui/views/controls/menu/menu_host.cc b/ui/views/controls/menu/menu_host.cc
index e2bc742bd7de..09a760d709b9 100644
--- a/ui/views/controls/menu/menu_host.cc
+++ b/ui/views/controls/menu/menu_host.cc
@@ -80,13 +80,6 @@ class PreMenuEventDispatchHandler : public ui::EventHandler,
 #endif  // OS_MACOSX
 
 void TransferGesture(Widget* source, Widget* target) {
-#if defined(OS_MACOSX)
-  NOTIMPLEMENTED();
-#else   // !defined(OS_MACOSX)
-  source->GetGestureRecognizer()->TransferEventsTo(
-      source->GetNativeView(), target->GetNativeView(),
-      ui::TransferTouchesBehavior::kDontCancel);
-#endif  // defined(OS_MACOSX)
 }
 
 }  // namespace internal
@@ -138,12 +131,6 @@ void MenuHost::InitMenuHost(Widget* parent,
 #endif
   Init(std::move(params));
 
-#if !defined(OS_MACOSX)
-  pre_dispatch_handler_ =
-      std::make_unique<internal::PreMenuEventDispatchHandler>(
-          menu_controller, submenu_, GetNativeView());
-#endif
-
   DCHECK(!owner_);
   owner_ = parent;
   if (owner_)
@@ -158,32 +145,6 @@ bool MenuHost::IsMenuHostVisible() {
 }
 
 void MenuHost::ShowMenuHost(bool do_capture) {
-  // Doing a capture may make us get capture lost. Ignore it while we're in the
-  // process of showing.
-  base::AutoReset<bool> reseter(&ignore_capture_lost_, true);
-  ShowInactive();
-  if (do_capture) {
-    MenuController* menu_controller =
-        submenu_->GetMenuItem()->GetMenuController();
-    if (menu_controller && menu_controller->send_gesture_events_to_owner()) {
-      // TransferGesture when owner needs gesture events so that the incoming
-      // touch events after MenuHost is created are properly translated into
-      // gesture events instead of being dropped.
-      internal::TransferGesture(owner_, this);
-    } else {
-      GetGestureRecognizer()->CancelActiveTouchesExcept(nullptr);
-    }
-#if defined(MACOSX)
-    // Cancel existing touches, so we don't miss some touch release/cancel
-    // events due to the menu taking capture.
-    GetGestureRecognizer()->CancelActiveTouchesExcept(nullptr);
-#endif  // defined (OS_MACOSX)
-    // If MenuHost has no parent widget, it needs to call Show to get focus,
-    // so that it will get keyboard events.
-    if (owner_ == nullptr)
-      Show();
-    native_widget_private()->SetCapture();
-  }
 }
 
 void MenuHost::HideMenuHost() {
@@ -203,9 +164,6 @@ void MenuHost::DestroyMenuHost() {
   HideMenuHost();
   destroying_ = true;
   static_cast<MenuHostRootView*>(GetRootView())->ClearSubmenu();
-#if !defined(OS_MACOSX)
-  pre_dispatch_handler_.reset();
-#endif
   Close();
 }
 
diff --git a/ui/views/controls/menu/menu_host.h b/ui/views/controls/menu/menu_host.h
index e3df270ad1df..2edfb41d5e00 100644
--- a/ui/views/controls/menu/menu_host.h
+++ b/ui/views/controls/menu/menu_host.h
@@ -95,11 +95,6 @@ class MenuHost : public Widget, public WidgetObserver {
   // If true and capture is lost we don't notify the delegate.
   bool ignore_capture_lost_;
 
-#if !defined(OS_MACOSX)
-  // Handles raw touch events at the moment.
-  std::unique_ptr<internal::PreMenuEventDispatchHandler> pre_dispatch_handler_;
-#endif
-
   DISALLOW_COPY_AND_ASSIGN(MenuHost);
 };
 
diff --git a/ui/views/controls/native/native_view_host_android.cc b/ui/views/controls/native/native_view_host_android.cc
new file mode 100644
index 000000000000..6fa914c45f21
--- /dev/null
+++ b/ui/views/controls/native/native_view_host_android.cc
@@ -0,0 +1,121 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/controls/native/native_view_host_android.h"
+
+#include <memory>
+
+#include "base/logging.h"
+#include "base/optional.h"
+#include "build/build_config.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/base/hit_test.h"
+#include "ui/compositor/paint_recorder.h"
+#include "ui/gfx/geometry/insets.h"
+#include "ui/views/controls/native/native_view_host.h"
+#include "ui/views/painter.h"
+#include "ui/views/view_class_properties.h"
+#include "ui/views/widget/widget.h"
+
+namespace views {
+
+NativeViewHostAndroid::NativeViewHostAndroid(NativeViewHost* host) : host_(host) {}
+
+NativeViewHostAndroid::~NativeViewHostAndroid() {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeViewHostAura, NativeViewHostWrapper implementation:
+void NativeViewHostAndroid::AttachNativeView() {
+}
+
+void NativeViewHostAndroid::SetParentAccessible(
+    gfx::NativeViewAccessible accessible) {
+}
+
+void NativeViewHostAndroid::NativeViewDetaching(bool destroyed) {
+}
+
+void NativeViewHostAndroid::AddedToWidget() {
+}
+
+void NativeViewHostAndroid::RemovedFromWidget() {
+}
+
+bool NativeViewHostAndroid::SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) {
+  return false;
+}
+
+void NativeViewHostAndroid::SetHitTestTopInset(int top_inset) {
+}
+
+void NativeViewHostAndroid::InstallClip(int x, int y, int w, int h) {
+}
+
+int NativeViewHostAndroid::GetHitTestTopInset() const {
+  return top_inset_;
+}
+
+bool NativeViewHostAndroid::HasInstalledClip() {
+  return !!clip_rect_;
+}
+
+void NativeViewHostAndroid::UninstallClip() {
+  clip_rect_.reset();
+}
+
+void NativeViewHostAndroid::ShowWidget(int x,
+                                    int y,
+                                    int w,
+                                    int h,
+                                    int native_w,
+                                    int native_h) {
+}
+
+void NativeViewHostAndroid::HideWidget() {
+}
+
+void NativeViewHostAndroid::SetFocus() {
+}
+
+gfx::NativeView NativeViewHostAndroid::GetNativeViewContainer() const {
+  return gfx::NativeView();
+}
+
+gfx::NativeViewAccessible NativeViewHostAndroid::GetNativeViewAccessible() {
+  return nullptr;
+}
+
+gfx::NativeCursor NativeViewHostAndroid::GetCursor(int x, int y) {
+  return gfx::kNullCursor;
+}
+
+void NativeViewHostAndroid::SetVisible(bool visible) {
+}
+
+// static
+NativeViewHostWrapper* NativeViewHostWrapper::CreateWrapper(
+    NativeViewHost* host) {
+  return new NativeViewHostAndroid(host);
+}
+
+void NativeViewHostAndroid::CreateClippingWindow() {
+}
+
+void NativeViewHostAndroid::AddClippingWindow() {
+}
+
+void NativeViewHostAndroid::RemoveClippingWindow() {
+}
+
+void NativeViewHostAndroid::InstallMask() {
+}
+
+void NativeViewHostAndroid::UninstallMask() {
+}
+
+void NativeViewHostAndroid::UpdateInsets() {
+}
+
+}  // namespace views
diff --git a/ui/views/controls/native/native_view_host_android.h b/ui/views/controls/native/native_view_host_android.h
new file mode 100644
index 000000000000..9434ddcf27f9
--- /dev/null
+++ b/ui/views/controls/native/native_view_host_android.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
+#define UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
+
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "ui/compositor/layer_owner.h"
+#include "ui/gfx/transform.h"
+#include "ui/views/controls/native/native_view_host_wrapper.h"
+#include "ui/views/views_export.h"
+
+namespace views {
+
+class NativeViewHost;
+
+// Android implementation of NativeViewHostWrapper.
+class NativeViewHostAndroid : public NativeViewHostWrapper {
+
+ public:
+  explicit NativeViewHostAndroid(NativeViewHost* host);
+  ~NativeViewHostAndroid() override;
+
+  // Overridden from NativeViewHostWrapper:
+  void AttachNativeView() override;
+  void NativeViewDetaching(bool destroyed) override;
+  void AddedToWidget() override;
+  void RemovedFromWidget() override;
+  bool SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) override;
+  void SetHitTestTopInset(int top_inset) override;
+  int GetHitTestTopInset() const override;
+  void InstallClip(int x, int y, int w, int h) override;
+  bool HasInstalledClip() override;
+  void UninstallClip() override;
+  void ShowWidget(int x, int y, int w, int h, int native_w, int native_h)
+      override;
+  void HideWidget() override;
+  void SetFocus() override;
+  gfx::NativeView GetNativeViewContainer() const override;
+  gfx::NativeViewAccessible GetNativeViewAccessible() override;
+  gfx::NativeCursor GetCursor(int x, int y) override;
+  void SetVisible(bool visible) override;
+  void SetParentAccessible(gfx::NativeViewAccessible) override;
+
+ private:
+  friend class NativeViewHostAndroidTest;
+
+  void CreateClippingWindow();
+
+  // Reparents the native view with the clipping window existing between it and
+  // its old parent, so that the fast resize path works.
+  void AddClippingWindow();
+
+  // If the native view has been reparented via AddClippingWindow, this call
+  // undoes it.
+  void RemoveClippingWindow();
+
+  // Sets or updates the mask layer on the native view's layer.
+  void InstallMask();
+
+  // Unsets the mask layer on the native view's layer.
+  void UninstallMask();
+
+  // Updates the top insets of |clipping_window_|.
+  void UpdateInsets();
+
+  // Our associated NativeViewHost.
+  NativeViewHost* host_;
+
+  // Window that exists between the native view and the parent that allows for
+  // clipping to occur. This is positioned in the coordinate space of
+  // host_->GetWidget().
+  std::unique_ptr<gfx::Rect> clip_rect_;
+
+  // This mask exists for the sake of SetCornerRadius().
+  std::unique_ptr<ui::LayerOwner> mask_;
+
+  // Set when AttachNativeView() is called. This is the original transform of
+  // the NativeView's layer. The NativeView's layer may be modified to scale
+  // when ShowWidget() is called with a native view size not equal to the
+  // region's size. When NativeViewDetaching() is called, the NativeView's
+  // transform is restored to this.
+  gfx::Transform original_transform_;
+
+  // True if a transform different from the original was set.
+  bool original_transform_changed_ = false;
+
+  // The top insets to exclude the underlying native view from the target.
+  int top_inset_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeViewHostAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
diff --git a/ui/views/controls/webview/unhandled_keyboard_event_handler.cc b/ui/views/controls/webview/unhandled_keyboard_event_handler.cc
index 85a1cc6e07ad..473248f1ec24 100644
--- a/ui/views/controls/webview/unhandled_keyboard_event_handler.cc
+++ b/ui/views/controls/webview/unhandled_keyboard_event_handler.cc
@@ -50,9 +50,6 @@ bool UnhandledKeyboardEventHandler::HandleKeyboardEvent(
     ignore_next_char_event_ = false;
   }
 
-  if (event.os_event && !event.skip_in_browser)
-    return HandleNativeKeyboardEvent(event.os_event, focus_manager);
-
   return false;
 }
 
diff --git a/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc b/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
index f6cb4a38d17a..9e9ca028ec45 100644
--- a/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
+++ b/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
@@ -13,7 +13,7 @@ namespace views {
 bool UnhandledKeyboardEventHandler::HandleNativeKeyboardEvent(
     gfx::NativeEvent event,
     FocusManager* focus_manager) {
-  return !focus_manager->OnKeyEvent(*(event->AsKeyEvent()));
+  return false;
 }
 
 }  // namespace views
diff --git a/ui/views/controls/webview/web_dialog_view.cc b/ui/views/controls/webview/web_dialog_view.cc
index ed1c7a5a0456..d9881f9137c5 100644
--- a/ui/views/controls/webview/web_dialog_view.cc
+++ b/ui/views/controls/webview/web_dialog_view.cc
@@ -351,11 +351,7 @@ void WebDialogView::SetContentsBounds(WebContents* source,
 // they're all browser-specific. (This may change in the future.)
 bool WebDialogView::HandleKeyboardEvent(content::WebContents* source,
                                         const NativeWebKeyboardEvent& event) {
-  if (!event.os_event)
-    return false;
-
-  return unhandled_keyboard_event_handler_.HandleKeyboardEvent(
-      event, GetFocusManager());
+  return false;
 }
 
 void WebDialogView::CloseContents(WebContents* source) {
diff --git a/ui/views/event_monitor_android.cc b/ui/views/event_monitor_android.cc
new file mode 100644
index 000000000000..c7cad8b7ea37
--- /dev/null
+++ b/ui/views/event_monitor_android.cc
@@ -0,0 +1,65 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/event_monitor_android.h"
+
+#include <memory>
+
+#include "base/logging.h"
+#include "base/scoped_observer.h"
+#include "ui/events/event_observer.h"
+#include "ui/events/event_target.h"
+
+namespace views {
+
+EventMonitorAndroid::EventMonitorAndroid(ui::EventObserver* event_observer,
+                                   ui::EventTarget* event_target,
+                                   const std::set<ui::EventType>& types) {
+}
+
+EventMonitorAndroid::~EventMonitorAndroid() {
+}
+
+namespace {
+
+// An EventMonitorAndroid that removes its event observer on window destruction.
+class WindowMonitorAndroid : public EventMonitorAndroid {
+ public:
+  WindowMonitorAndroid(ui::EventObserver* event_observer,
+                    ui::EventTarget* target_window,
+                    const std::set<ui::EventType>& types)
+      : EventMonitorAndroid(event_observer, target_window, types) {
+  }
+  ~WindowMonitorAndroid() override = default;
+
+ private:
+
+  DISALLOW_COPY_AND_ASSIGN(WindowMonitorAndroid);
+};
+
+}  // namespace
+
+// static
+std::unique_ptr<EventMonitor> EventMonitor::CreateApplicationMonitor(
+    ui::EventObserver* event_observer,
+    gfx::NativeWindow context,
+    const std::set<ui::EventType>& types) {
+  return std::make_unique<EventMonitorAndroid>(event_observer,
+                                            nullptr, types);
+}
+
+// static
+std::unique_ptr<EventMonitor> EventMonitor::CreateWindowMonitor(
+    ui::EventObserver* event_observer,
+    gfx::NativeWindow target_window,
+    const std::set<ui::EventType>& types) {
+  return std::make_unique<WindowMonitorAndroid>(event_observer, nullptr,
+                                             types);
+}
+
+gfx::Point EventMonitorAndroid::GetLastMouseLocation() {
+  return gfx::Point();
+}
+
+}  // namespace views
diff --git a/ui/views/event_monitor_android.h b/ui/views/event_monitor_android.h
new file mode 100644
index 000000000000..0437aff5003b
--- /dev/null
+++ b/ui/views/event_monitor_android.h
@@ -0,0 +1,37 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_EVENT_MONITOR_ANDROID_H_
+#define UI_VIEWS_EVENT_MONITOR_ANDROID_H_
+
+#include "base/macros.h"
+#include "ui/views/event_monitor.h"
+
+namespace ui {
+class EventTarget;
+}
+
+namespace views {
+
+// Observes events by installing a pre-target handler on the ui::EventTarget.
+class EventMonitorAndroid : public EventMonitor {
+ public:
+  EventMonitorAndroid(ui::EventObserver* event_observer,
+                   ui::EventTarget* event_target,
+                   const std::set<ui::EventType>& types);
+  ~EventMonitorAndroid() override;
+
+  // EventMonitor:
+  gfx::Point GetLastMouseLocation() override;
+
+ protected:
+
+ private:
+
+  DISALLOW_COPY_AND_ASSIGN(EventMonitorAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_EVENT_MONITOR_Android_H_
diff --git a/ui/views/metrics_android.cc b/ui/views/metrics_android.cc
new file mode 100644
index 000000000000..cf576ebb0d95
--- /dev/null
+++ b/ui/views/metrics_android.cc
@@ -0,0 +1,36 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "build/build_config.h"
+#include "ui/views/metrics.h"
+
+#if defined(OS_WIN)
+#include <windows.h>
+#endif
+
+namespace views {
+
+int GetDoubleClickInterval() {
+#if defined(OS_WIN)
+  return ::GetDoubleClickTime();
+#else
+  // TODO(jennyz): This value may need to be adjusted on different platforms.
+  const int kDefaultDoubleClickIntervalMs = 500;
+  return kDefaultDoubleClickIntervalMs;
+#endif
+}
+
+int GetMenuShowDelay() {
+#if defined(OS_WIN)
+  static DWORD delay = 0;
+  if (!delay && !SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &delay, 0))
+    delay = kDefaultMenuShowDelay;
+  return delay;
+#else
+  return 0;
+#endif
+}
+
+}  // namespace views
+
diff --git a/ui/views/native_cursor_android.cc b/ui/views/native_cursor_android.cc
new file mode 100644
index 000000000000..0b6ad4b6dd41
--- /dev/null
+++ b/ui/views/native_cursor_android.cc
@@ -0,0 +1,31 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/native_cursor.h"
+
+#include "ui/base/cursor/cursor.h"
+
+namespace views {
+
+gfx::NativeCursor GetNativeIBeamCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeHandCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeColumnResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeEastWestResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+gfx::NativeCursor GetNativeNorthSouthResizeCursor() {
+  return gfx::kNullCursor;
+}
+
+}  // namespace views
diff --git a/ui/views/view.cc b/ui/views/view.cc
index 9b7245cc9c15..566884ccddae 100644
--- a/ui/views/view.cc
+++ b/ui/views/view.cc
@@ -2307,6 +2307,7 @@ void View::PropagateRemoveNotifications(View* old_parent,
 
 void View::PropagateAddNotifications(const ViewHierarchyChangedDetails& details,
                                      bool is_added_to_widget) {
+#if 0
   {
     internal::ScopedChildrenLock lock(this);
     for (auto* child : children_)
@@ -2318,6 +2319,7 @@ void View::PropagateAddNotifications(const ViewHierarchyChangedDetails& details,
     for (ViewObserver& observer : observers_)
       observer.OnViewAddedToWidget(this);
   }
+#endif
 }
 
 void View::PropagateNativeViewHierarchyChanged() {
diff --git a/ui/views/views_touch_selection_controller_factory_android.cc b/ui/views/views_touch_selection_controller_factory_android.cc
new file mode 100644
index 000000000000..53eb2ede6247
--- /dev/null
+++ b/ui/views/views_touch_selection_controller_factory_android.cc
@@ -0,0 +1,22 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/views_touch_selection_controller_factory.h"
+
+#include "ui/base/ui_base_switches_util.h"
+#include "ui/views/touchui/touch_selection_controller_impl.h"
+
+namespace views {
+
+ViewsTouchEditingControllerFactory::ViewsTouchEditingControllerFactory() {
+}
+
+ui::TouchEditingControllerDeprecated*
+ViewsTouchEditingControllerFactory::Create(
+    ui::TouchEditable* client_view) {
+  return nullptr;
+}
+
+}  // namespace views
+
diff --git a/ui/views/views_touch_selection_controller_factory_aura.cc b/ui/views/views_touch_selection_controller_factory_aura.cc
index 8010719703f6..fb93a372660f 100644
--- a/ui/views/views_touch_selection_controller_factory_aura.cc
+++ b/ui/views/views_touch_selection_controller_factory_aura.cc
@@ -15,7 +15,7 @@ ViewsTouchEditingControllerFactory::ViewsTouchEditingControllerFactory() =
 ui::TouchEditingControllerDeprecated*
 ViewsTouchEditingControllerFactory::Create(
     ui::TouchEditable* client_view) {
-  return new views::TouchSelectionControllerImpl(client_view);
+  return nullptr;
 }
 
 }  // namespace views
diff --git a/ui/views/widget/native_widget_android.cc b/ui/views/widget/native_widget_android.cc
new file mode 100644
index 000000000000..e7dfce7250ab
--- /dev/null
+++ b/ui/views/widget/native_widget_android.cc
@@ -0,0 +1,491 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/widget/native_widget_android.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/location.h"
+#include "base/single_thread_task_runner.h"
+#include "base/strings/string_util.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "build/build_config.h"
+#include "ui/base/class_property.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/ui_base_types.h"
+#include "ui/compositor/layer.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/events/event.h"
+#include "ui/gfx/canvas.h"
+#include "ui/native_theme/native_theme_android.h"
+#include "ui/views/drag_utils.h"
+#include "ui/views/views_delegate.h"
+#include "ui/views/widget/drop_helper.h"
+#include "ui/views/widget/focus_manager_event_handler.h"
+#include "ui/views/widget/native_widget_delegate.h"
+#include "ui/views/widget/root_view.h"
+#include "ui/views/widget/tooltip_manager_aura.h"
+#include "ui/views/widget/widget_aura_utils.h"
+#include "ui/views/widget/widget_delegate.h"
+#include "ui/views/widget/window_reorderer.h"
+#include "ui/wm/core/coordinate_conversion.h"
+#include "ui/wm/core/shadow_types.h"
+#include "ui/wm/core/transient_window_manager.h"
+#include "ui/wm/core/window_animations.h"
+#include "ui/wm/core/window_properties.h"
+#include "ui/wm/core/window_util.h"
+#include "ui/wm/public/activation_client.h"
+#include "ui/wm/public/window_move_client.h"
+
+#if defined(OS_WIN)
+#include "base/win/scoped_gdi_object.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_win.h"
+#endif
+
+#if defined(USE_X11)
+#include "ui/views/linux_ui/linux_ui.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_x11.h"
+#endif
+
+#if !defined(OS_CHROMEOS)
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
+#endif
+
+DEFINE_UI_CLASS_PROPERTY_TYPE(views::internal::NativeWidgetPrivate*)
+
+namespace views {
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, public:
+
+NativeWidgetAndroid::NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate)
+    : delegate_(delegate),
+      ownership_(Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET),
+      destroying_(false) {
+}
+
+// static
+void NativeWidgetAndroid::RegisterNativeWidgetForWindow(
+      internal::NativeWidgetPrivate* native_widget,
+      gfx::NativeWindow window) {
+}
+
+// static
+void NativeWidgetAndroid::AssignIconToAuraWindow(gfx::NativeWindow window,
+                                              const gfx::ImageSkia& window_icon,
+                                              const gfx::ImageSkia& app_icon) {
+}
+
+// static
+void NativeWidgetAndroid::SetShadowElevationFromInitParams(
+    gfx::NativeWindow window,
+    const Widget::InitParams& params) {
+}
+
+// static
+void NativeWidgetAndroid::SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
+                                                     gfx::NativeWindow window) {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, internal::NativeWidgetPrivate implementation:
+
+void NativeWidgetAndroid::InitNativeWidget(Widget::InitParams params) {
+  delegate_->OnNativeWidgetCreated();
+}
+
+void NativeWidgetAndroid::OnWidgetInitDone() {}
+
+NonClientFrameView* NativeWidgetAndroid::CreateNonClientFrameView() {
+  return nullptr;
+}
+
+bool NativeWidgetAndroid::ShouldUseNativeFrame() const {
+  // There is only one frame type for aura.
+  return false;
+}
+
+bool NativeWidgetAndroid::ShouldWindowContentsBeTransparent() const {
+  return false;
+}
+
+void NativeWidgetAndroid::FrameTypeChanged() {
+  // This is called when the Theme has changed; forward the event to the root
+  // widget.
+  GetWidget()->ThemeChanged();
+  GetWidget()->GetRootView()->SchedulePaint();
+}
+
+Widget* NativeWidgetAndroid::GetWidget() {
+  return delegate_->AsWidget();
+}
+
+const Widget* NativeWidgetAndroid::GetWidget() const {
+  return delegate_->AsWidget();
+}
+
+gfx::NativeView NativeWidgetAndroid::GetNativeView() const {
+  return window_;
+}
+
+gfx::NativeWindow NativeWidgetAndroid::GetNativeWindow() const {
+  return window_;
+}
+
+Widget* NativeWidgetAndroid::GetTopLevelWidget() {
+  NativeWidgetPrivate* native_widget = GetTopLevelNativeWidget(GetNativeView());
+  return native_widget ? native_widget->GetWidget() : nullptr;
+}
+
+const ui::Compositor* NativeWidgetAndroid::GetCompositor() const {
+  return nullptr;
+}
+
+const ui::Layer* NativeWidgetAndroid::GetLayer() const {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::ReorderNativeViews() {
+}
+
+void NativeWidgetAndroid::ViewRemoved(View* view) {
+  DCHECK(drop_helper_.get() != nullptr);
+  drop_helper_->ResetTargetViewIfEquals(view);
+}
+
+void NativeWidgetAndroid::SetNativeWindowProperty(const char* name, void* value) {
+}
+
+void* NativeWidgetAndroid::GetNativeWindowProperty(const char* name) const {
+  return nullptr;
+}
+
+TooltipManager* NativeWidgetAndroid::GetTooltipManager() const {
+  return tooltip_manager_.get();
+}
+
+void NativeWidgetAndroid::SetCapture() {
+}
+
+void NativeWidgetAndroid::ReleaseCapture() {
+}
+
+bool NativeWidgetAndroid::HasCapture() const {
+  return false;
+}
+
+ui::InputMethod* NativeWidgetAndroid::GetInputMethod() {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::CenterWindow(const gfx::Size& size) {
+}
+
+void NativeWidgetAndroid::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+}
+
+bool NativeWidgetAndroid::SetWindowTitle(const base::string16& title) {
+  return true;
+}
+
+void NativeWidgetAndroid::SetWindowIcons(const gfx::ImageSkia& window_icon,
+                                      const gfx::ImageSkia& app_icon) {
+}
+
+void NativeWidgetAndroid::InitModalType(ui::ModalType modal_type) {
+}
+
+gfx::Rect NativeWidgetAndroid::GetWindowBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+gfx::Rect NativeWidgetAndroid::GetClientAreaBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+gfx::Rect NativeWidgetAndroid::GetRestoredBounds() const {
+  return gfx::Rect();
+}
+
+std::string NativeWidgetAndroid::GetWorkspace() const {
+  return std::string();
+}
+
+void NativeWidgetAndroid::SetBounds(const gfx::Rect& bounds) {
+}
+
+void NativeWidgetAndroid::SetBoundsConstrained(const gfx::Rect& bounds) {
+}
+
+void NativeWidgetAndroid::SetSize(const gfx::Size& size) {
+}
+
+void NativeWidgetAndroid::StackAbove(gfx::NativeView native_view) {
+}
+
+void NativeWidgetAndroid::StackAtTop() {
+}
+
+void NativeWidgetAndroid::SetShape(std::unique_ptr<Widget::ShapeRects> shape) {
+}
+
+void NativeWidgetAndroid::Close() {
+}
+
+void NativeWidgetAndroid::CloseNow() {
+}
+
+void NativeWidgetAndroid::Show(ui::WindowShowState show_state,
+                            const gfx::Rect& restore_bounds) {
+}
+
+void NativeWidgetAndroid::Hide() {
+}
+
+bool NativeWidgetAndroid::IsVisible() const {
+  return true;
+}
+
+void NativeWidgetAndroid::Activate() {
+}
+
+void NativeWidgetAndroid::Deactivate() {
+}
+
+bool NativeWidgetAndroid::IsActive() const {
+  return true;
+}
+
+void NativeWidgetAndroid::SetZOrderLevel(ui::ZOrderLevel order) {
+}
+
+ui::ZOrderLevel NativeWidgetAndroid::GetZOrderLevel() const {
+  return ui::ZOrderLevel::kNormal;
+}
+
+void NativeWidgetAndroid::SetVisibleOnAllWorkspaces(bool always_visible) {
+  // Not implemented on chromeos or for child widgets.
+}
+
+bool NativeWidgetAndroid::IsVisibleOnAllWorkspaces() const {
+  return false;
+}
+
+void NativeWidgetAndroid::Maximize() {
+}
+
+void NativeWidgetAndroid::Minimize() {
+}
+
+bool NativeWidgetAndroid::IsMaximized() const {
+  return true;
+}
+
+bool NativeWidgetAndroid::IsMinimized() const {
+  return false;
+}
+
+void NativeWidgetAndroid::Restore() {
+}
+
+void NativeWidgetAndroid::SetFullscreen(bool fullscreen) {
+}
+
+bool NativeWidgetAndroid::IsFullscreen() const {
+  return false;
+}
+
+void NativeWidgetAndroid::SetCanAppearInExistingFullscreenSpaces(
+    bool can_appear_in_existing_fullscreen_spaces) {}
+
+void NativeWidgetAndroid::SetOpacity(float opacity) {
+}
+
+void NativeWidgetAndroid::SetAspectRatio(const gfx::SizeF& aspect_ratio) {
+}
+
+void NativeWidgetAndroid::FlashFrame(bool flash) {
+}
+
+void NativeWidgetAndroid::RunShellDrag(View* view,
+                                    std::unique_ptr<ui::OSExchangeData> data,
+                                    const gfx::Point& location,
+                                    int operation,
+                                    ui::DragDropTypes::DragEventSource source) {
+}
+
+void NativeWidgetAndroid::SchedulePaintInRect(const gfx::Rect& rect) {
+}
+
+void NativeWidgetAndroid::ScheduleLayout() {
+}
+
+void NativeWidgetAndroid::SetCursor(gfx::NativeCursor cursor) {
+}
+
+bool NativeWidgetAndroid::IsMouseEventsEnabled() const {
+  return true;
+}
+
+bool NativeWidgetAndroid::IsMouseButtonDown() const {
+  return false;
+}
+
+void NativeWidgetAndroid::ClearNativeFocus() {
+}
+
+gfx::Rect NativeWidgetAndroid::GetWorkAreaBoundsInScreen() const {
+  return gfx::Rect();
+}
+
+Widget::MoveLoopResult NativeWidgetAndroid::RunMoveLoop(
+    const gfx::Vector2d& drag_offset,
+    Widget::MoveLoopSource source,
+    Widget::MoveLoopEscapeBehavior escape_behavior) {
+  return Widget::MOVE_LOOP_CANCELED;
+}
+
+void NativeWidgetAndroid::EndMoveLoop() {
+}
+
+void NativeWidgetAndroid::SetVisibilityChangedAnimationsEnabled(bool value) {
+}
+
+void NativeWidgetAndroid::SetVisibilityAnimationDuration(
+    const base::TimeDelta& duration) {
+}
+
+void NativeWidgetAndroid::SetVisibilityAnimationTransition(
+    Widget::VisibilityTransition transition) {
+}
+
+bool NativeWidgetAndroid::IsTranslucentWindowOpacitySupported() const {
+  return true;
+}
+
+ui::GestureRecognizer* NativeWidgetAndroid::GetGestureRecognizer() {
+  return nullptr;
+}
+
+void NativeWidgetAndroid::OnSizeConstraintsChanged() {
+}
+
+std::string NativeWidgetAndroid::GetName() const {
+  return std::string();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, protected:
+
+NativeWidgetAndroid::~NativeWidgetAndroid() {
+  destroying_ = true;
+  if (ownership_ == Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET)
+    delete delegate_;
+  else
+    CloseNow();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// NativeWidgetAndroid, private:
+
+void NativeWidgetAndroid::SetInitialFocus(ui::WindowShowState show_state) {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Widget, public:
+
+namespace {
+#if defined(OS_WIN) || defined(USE_X11)
+void CloseWindow(gfx::NativeWindow window) {
+  if (window) {
+    Widget* widget = Widget::GetWidgetForNativeView(window);
+    if (widget && widget->is_secondary_widget())
+      // To avoid the delay in shutdown caused by using Close which may wait
+      // for animations, use CloseNow. Because this is only used on secondary
+      // widgets it seems relatively safe to skip the extra processing of
+      // Close.
+      widget->CloseNow();
+  }
+}
+#endif
+
+#if defined(OS_WIN)
+BOOL CALLBACK WindowCallbackProc(HWND hwnd, LPARAM lParam) {
+  gfx::NativeWindow root_window =
+      DesktopWindowTreeHostWin::GetContentWindowForHWND(hwnd);
+  CloseWindow(root_window);
+  return TRUE;
+}
+#endif
+}  // namespace
+
+// static
+void Widget::CloseAllSecondaryWidgets() {
+#if defined(OS_WIN)
+  EnumThreadWindows(GetCurrentThreadId(), WindowCallbackProc, 0);
+#endif
+
+#if defined(USE_X11)
+  DesktopWindowTreeHostX11::CleanUpWindowList(CloseWindow);
+#endif
+}
+
+namespace internal {
+
+////////////////////////////////////////////////////////////////////////////////
+// internal::NativeWidgetPrivate, public:
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::CreateNativeWidget(
+    internal::NativeWidgetDelegate* delegate) {
+  return new NativeWidgetAndroid(delegate);
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeView(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeWindow(
+    gfx::NativeWindow native_window) {
+  return nullptr;
+}
+
+// static
+NativeWidgetPrivate* NativeWidgetPrivate::GetTopLevelNativeWidget(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+// static
+void NativeWidgetPrivate::GetAllChildWidgets(gfx::NativeView native_view,
+                                             Widget::Widgets* children) {
+}
+
+// static
+void NativeWidgetPrivate::GetAllOwnedWidgets(gfx::NativeView native_view,
+                                             Widget::Widgets* owned) {
+}
+
+// static
+void NativeWidgetPrivate::ReparentNativeView(gfx::NativeView native_view,
+                                             gfx::NativeView new_parent) {
+}
+
+// static
+gfx::NativeView NativeWidgetPrivate::GetGlobalCapture(
+    gfx::NativeView native_view) {
+  return nullptr;
+}
+
+}  // namespace internal
+}  // namespace views
diff --git a/ui/views/widget/native_widget_android.h b/ui/views/widget/native_widget_android.h
new file mode 100644
index 000000000000..de83c381d51a
--- /dev/null
+++ b/ui/views/widget/native_widget_android.h
@@ -0,0 +1,192 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
+#define UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "build/build_config.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/events/event_constants.h"
+#include "ui/views/views_export.h"
+#include "ui/views/widget/native_widget_private.h"
+#include "ui/wm/public/activation_change_observer.h"
+#include "ui/wm/public/activation_delegate.h"
+
+#if defined(OS_MACOSX)
+#error This file must not be included on macOS; Chromium Mac doesn't use Aura.
+#endif
+
+namespace aura {
+class Window;
+}
+
+namespace views {
+
+class DropHelper;
+class FocusManagerEventHandler;
+class TooltipManagerAura;
+class WindowReorderer;
+
+class VIEWS_EXPORT NativeWidgetAndroid : public internal::NativeWidgetPrivate {
+ public:
+  explicit NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate);
+
+  // Called internally by NativeWidgetAndroid and DesktopNativeWidgetAndroid to
+  // associate |native_widget| with |window|.
+  static void RegisterNativeWidgetForWindow(
+      internal::NativeWidgetPrivate* native_widget,
+      gfx::NativeWindow window);
+
+  // Assign an icon to aura window.
+  static void AssignIconToAuraWindow(gfx::NativeWindow window,
+                                     const gfx::ImageSkia& window_icon,
+                                     const gfx::ImageSkia& app_icon);
+
+  // If necessary, sets the ShadowElevation of |window| from |params|.
+  static void SetShadowElevationFromInitParams(
+      gfx::NativeWindow window,
+      const Widget::InitParams& params);
+
+  // Sets the window property aura::client::kResizeBehaviorKey based on the
+  // values from the delegate.
+  static void SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
+                                            gfx::NativeWindow window);
+
+  // Overridden from internal::NativeWidgetPrivate:
+  void InitNativeWidget(Widget::InitParams params) override;
+  void OnWidgetInitDone() override;
+  NonClientFrameView* CreateNonClientFrameView() override;
+  bool ShouldUseNativeFrame() const override;
+  bool ShouldWindowContentsBeTransparent() const override;
+  void FrameTypeChanged() override;
+  Widget* GetWidget() override;
+  const Widget* GetWidget() const override;
+  gfx::NativeView GetNativeView() const override;
+  gfx::NativeWindow GetNativeWindow() const override;
+  Widget* GetTopLevelWidget() override;
+  const ui::Compositor* GetCompositor() const override;
+  const ui::Layer* GetLayer() const override;
+  void ReorderNativeViews() override;
+  void ViewRemoved(View* view) override;
+  void SetNativeWindowProperty(const char* name, void* value) override;
+  void* GetNativeWindowProperty(const char* name) const override;
+  TooltipManager* GetTooltipManager() const override;
+  void SetCapture() override;
+  void ReleaseCapture() override;
+  bool HasCapture() const override;
+  ui::InputMethod* GetInputMethod() override;
+  void CenterWindow(const gfx::Size& size) override;
+  void GetWindowPlacement(gfx::Rect* bounds,
+                          ui::WindowShowState* maximized) const override;
+  bool SetWindowTitle(const base::string16& title) override;
+  void SetWindowIcons(const gfx::ImageSkia& window_icon,
+                      const gfx::ImageSkia& app_icon) override;
+  void InitModalType(ui::ModalType modal_type) override;
+  gfx::Rect GetWindowBoundsInScreen() const override;
+  gfx::Rect GetClientAreaBoundsInScreen() const override;
+  gfx::Rect GetRestoredBounds() const override;
+  std::string GetWorkspace() const override;
+  void SetBounds(const gfx::Rect& bounds) override;
+  void SetBoundsConstrained(const gfx::Rect& bounds) override;
+  void SetSize(const gfx::Size& size) override;
+  void StackAbove(gfx::NativeView native_view) override;
+  void StackAtTop() override;
+  void SetShape(std::unique_ptr<Widget::ShapeRects> shape) override;
+  void Close() override;
+  void CloseNow() override;
+  void Show(ui::WindowShowState show_state,
+            const gfx::Rect& restore_bounds) override;
+  void Hide() override;
+  bool IsVisible() const override;
+  void Activate() override;
+  void Deactivate() override;
+  bool IsActive() const override;
+  void SetZOrderLevel(ui::ZOrderLevel order) override;
+  ui::ZOrderLevel GetZOrderLevel() const override;
+  void SetVisibleOnAllWorkspaces(bool always_visible) override;
+  bool IsVisibleOnAllWorkspaces() const override;
+  void Maximize() override;
+  void Minimize() override;
+  bool IsMaximized() const override;
+  bool IsMinimized() const override;
+  void Restore() override;
+  void SetFullscreen(bool fullscreen) override;
+  bool IsFullscreen() const override;
+  void SetCanAppearInExistingFullscreenSpaces(
+      bool can_appear_in_existing_fullscreen_spaces) override;
+  void SetOpacity(float opacity) override;
+  void SetAspectRatio(const gfx::SizeF& aspect_ratio) override;
+  void FlashFrame(bool flash_frame) override;
+  void RunShellDrag(View* view,
+                    std::unique_ptr<ui::OSExchangeData> data,
+                    const gfx::Point& location,
+                    int operation,
+                    ui::DragDropTypes::DragEventSource source) override;
+  void SchedulePaintInRect(const gfx::Rect& rect) override;
+  void ScheduleLayout() override;
+  void SetCursor(gfx::NativeCursor cursor) override;
+  bool IsMouseEventsEnabled() const override;
+  bool IsMouseButtonDown() const override;
+  void ClearNativeFocus() override;
+  gfx::Rect GetWorkAreaBoundsInScreen() const override;
+  Widget::MoveLoopResult RunMoveLoop(
+      const gfx::Vector2d& drag_offset,
+      Widget::MoveLoopSource source,
+      Widget::MoveLoopEscapeBehavior escape_behavior) override;
+  void EndMoveLoop() override;
+  void SetVisibilityChangedAnimationsEnabled(bool value) override;
+  void SetVisibilityAnimationDuration(const base::TimeDelta& duration) override;
+  void SetVisibilityAnimationTransition(
+      Widget::VisibilityTransition transition) override;
+  bool IsTranslucentWindowOpacitySupported() const override;
+  ui::GestureRecognizer* GetGestureRecognizer() override;
+  void OnSizeConstraintsChanged() override;
+  std::string GetName() const override;
+
+ protected:
+  ~NativeWidgetAndroid() override;
+
+  internal::NativeWidgetDelegate* delegate() { return delegate_; }
+
+ private:
+  void SetInitialFocus(ui::WindowShowState show_state);
+
+  internal::NativeWidgetDelegate* delegate_;
+
+  // WARNING: set to NULL when destroyed. As the Widget is not necessarily
+  // destroyed along with |window_| all usage of |window_| should first verify
+  // non-NULL.
+  gfx::NativeWindow window_;
+
+  // See class documentation for Widget in widget.h for a note about ownership.
+  Widget::InitParams::Ownership ownership_;
+
+  // Are we in the destructor?
+  bool destroying_;
+
+  std::unique_ptr<TooltipManagerAura> tooltip_manager_;
+
+  // Reorders child windows of |window_| associated with a view based on the
+  // order of the associated views in the widget's view hierarchy.
+  std::unique_ptr<WindowReorderer> window_reorderer_;
+
+  std::unique_ptr<DropHelper> drop_helper_;
+
+  // Native widget's handler to receive events before the event target.
+  std::unique_ptr<FocusManagerEventHandler> focus_manager_event_handler_;
+
+  // The following factory is used for calls to close the NativeWidgetAndroid
+  // instance.
+  base::WeakPtrFactory<NativeWidgetAndroid> close_widget_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWidgetAndroid);
+};
+
+}  // namespace views
+
+#endif  // UI_VIEWS_WIDGET_NATIVE_WIDGET_AURA_H_
diff --git a/ui/views/widget/widget.cc b/ui/views/widget/widget.cc
index af72459e1589..e1238331e0d8 100644
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -33,6 +33,7 @@
 #include "ui/views/focus/widget_focus_manager.h"
 #include "ui/views/views_delegate.h"
 #include "ui/views/widget/native_widget_private.h"
+#include "ui/native_theme/native_theme_android.h"
 #include "ui/views/widget/root_view.h"
 #include "ui/views/widget/tooltip_manager.h"
 #include "ui/views/widget/widget_delegate.h"
@@ -175,6 +176,10 @@ ui::ZOrderLevel Widget::InitParams::EffectiveZOrderLevel() const {
 ////////////////////////////////////////////////////////////////////////////////
 // Widget, public:
 
+const ui::NativeTheme* Widget::GetNativeTheme() const {
+  return ui::NativeThemeAndroid::instance();
+}
+
 Widget::Widget() = default;
 
 Widget::~Widget() {
@@ -229,42 +234,35 @@ Widget* Widget::CreateWindowWithContextAndBounds(WidgetDelegate* delegate,
 
 // static
 Widget* Widget::GetWidgetForNativeView(gfx::NativeView native_view) {
-  internal::NativeWidgetPrivate* native_widget =
-      internal::NativeWidgetPrivate::GetNativeWidgetForNativeView(native_view);
-  return native_widget ? native_widget->GetWidget() : nullptr;
+  return NULL;
 }
 
 // static
 Widget* Widget::GetWidgetForNativeWindow(gfx::NativeWindow native_window) {
-  internal::NativeWidgetPrivate* native_widget =
-      internal::NativeWidgetPrivate::GetNativeWidgetForNativeWindow(
-          native_window);
-  return native_widget ? native_widget->GetWidget() : nullptr;
+  return NULL;
 }
 
 // static
 Widget* Widget::GetTopLevelWidgetForNativeView(gfx::NativeView native_view) {
-  internal::NativeWidgetPrivate* native_widget =
-      internal::NativeWidgetPrivate::GetTopLevelNativeWidget(native_view);
-  return native_widget ? native_widget->GetWidget() : nullptr;
+  return NULL;
 }
 
 // static
 void Widget::GetAllChildWidgets(gfx::NativeView native_view,
                                 Widgets* children) {
-  internal::NativeWidgetPrivate::GetAllChildWidgets(native_view, children);
+  return ;
 }
 
 // static
 void Widget::GetAllOwnedWidgets(gfx::NativeView native_view,
                                 Widgets* owned) {
-  internal::NativeWidgetPrivate::GetAllOwnedWidgets(native_view, owned);
+  return ;
 }
 
 // static
 void Widget::ReparentNativeView(gfx::NativeView native_view,
                                 gfx::NativeView new_parent) {
-  internal::NativeWidgetPrivate::ReparentNativeView(native_view, new_parent);
+  return ;
 }
 
 // static
@@ -344,13 +342,16 @@ void Widget::Init(InitParams params) {
   root_view_.reset(CreateRootView());
   default_theme_provider_ = std::make_unique<ui::DefaultThemeProvider>();
 
+#if 0
   // Copy the elements of params that will be used after it is moved.
   const InitParams::Type type = params.type;
   const gfx::Rect bounds = params.bounds;
   const ui::WindowShowState show_state = params.show_state;
   WidgetDelegate* delegate = params.delegate;
+#endif
 
   native_widget_->InitNativeWidget(std::move(params));
+#if 0
   if (type == InitParams::TYPE_MENU)
     is_mouse_button_pressed_ = native_widget_->IsMouseButtonDown();
   if (RequiresNonClientView(type)) {
@@ -396,6 +397,7 @@ void Widget::Init(InitParams params) {
     observer_manager_.Add(native_theme);
 #else
   observer_manager_.Add(GetNativeTheme());
+#endif
 #endif
   native_widget_initialized_ = true;
   native_widget_->OnWidgetInitDone();
@@ -1255,91 +1257,6 @@ void Widget::OnKeyEvent(ui::KeyEvent* event) {
 //                   RootView from anywhere in Widget. Use
 //                   SendEventToSink() instead. See crbug.com/348087.
 void Widget::OnMouseEvent(ui::MouseEvent* event) {
-  View* root_view = GetRootView();
-  switch (event->type()) {
-    case ui::ET_MOUSE_PRESSED: {
-      last_mouse_event_was_move_ = false;
-
-      // We may get deleted by the time we return from OnMousePressed. So we
-      // use an observer to make sure we are still alive.
-      WidgetDeletionObserver widget_deletion_observer(this);
-
-      gfx::NativeView current_capture =
-          internal::NativeWidgetPrivate::GetGlobalCapture(
-              native_widget_->GetNativeView());
-      // Make sure we're still visible before we attempt capture as the mouse
-      // press processing may have made the window hide (as happens with menus).
-      //
-      // It is possible that capture has changed as a result of a mouse-press.
-      // In these cases do not update internal state.
-      //
-      // A mouse-press may trigger a nested message-loop, and absorb the paired
-      // release. If so the code returns here. So make sure that that
-      // mouse-button is still down before attempting to do a capture.
-      if (root_view && root_view->OnMousePressed(*event) &&
-          widget_deletion_observer.IsWidgetAlive() && IsVisible() &&
-          native_widget_->IsMouseButtonDown() &&
-          current_capture == internal::NativeWidgetPrivate::GetGlobalCapture(
-                                 native_widget_->GetNativeView())) {
-        is_mouse_button_pressed_ = true;
-        if (!native_widget_->HasCapture())
-          native_widget_->SetCapture();
-        event->SetHandled();
-      }
-      return;
-    }
-
-    case ui::ET_MOUSE_RELEASED:
-      last_mouse_event_was_move_ = false;
-      is_mouse_button_pressed_ = false;
-      // Release capture first, to avoid confusion if OnMouseReleased blocks.
-      if (auto_release_capture_ && native_widget_->HasCapture()) {
-        base::AutoReset<bool> resetter(&ignore_capture_loss_, true);
-        native_widget_->ReleaseCapture();
-      }
-      if (root_view)
-        root_view->OnMouseReleased(*event);
-      if ((event->flags() & ui::EF_IS_NON_CLIENT) == 0 &&
-          // If none of the "normal" buttons are pressed, this event may be from
-          // one of the newer mice that have buttons bound to browser forward
-          // back actions. Don't squelch the event and let the default handler
-          // process it.
-          (event->flags() &
-           (ui::EF_LEFT_MOUSE_BUTTON | ui::EF_MIDDLE_MOUSE_BUTTON |
-            ui::EF_RIGHT_MOUSE_BUTTON)) != 0)
-        event->SetHandled();
-      return;
-
-    case ui::ET_MOUSE_MOVED:
-    case ui::ET_MOUSE_DRAGGED:
-      if (native_widget_->HasCapture() && is_mouse_button_pressed_) {
-        last_mouse_event_was_move_ = false;
-        if (root_view)
-          root_view->OnMouseDragged(*event);
-      } else if (!last_mouse_event_was_move_ ||
-                 last_mouse_event_position_ != event->location()) {
-        last_mouse_event_position_ = event->location();
-        last_mouse_event_was_move_ = true;
-        if (root_view)
-          root_view->OnMouseMoved(*event);
-      }
-      return;
-
-    case ui::ET_MOUSE_EXITED:
-      last_mouse_event_was_move_ = false;
-      if (root_view)
-        root_view->OnMouseExited(*event);
-      return;
-
-    case ui::ET_MOUSEWHEEL:
-      if (root_view && root_view->OnMouseWheel(
-          static_cast<const ui::MouseWheelEvent&>(*event)))
-        event->SetHandled();
-      return;
-
-    default:
-      return;
-  }
 }
 
 void Widget::OnMouseCaptureLost() {
diff --git a/ui/webui/resources/css/roboto.css b/ui/webui/resources/css/roboto.css
index af0bdbc6a976..827bec2913ef 100644
--- a/ui/webui/resources/css/roboto.css
+++ b/ui/webui/resources/css/roboto.css
@@ -2,7 +2,7 @@
  * Use of this source code is governed by a BSD-style license that can be
  * found in the LICENSE file. */
 
-<if expr="not chromeos and not is_android">
+<if expr="is_android or not chromeos and not is_android">
 @font-face {
   font-family: 'Roboto';
   font-style: normal;
diff --git a/ui/webui/resources/webui_resources.grd b/ui/webui/resources/webui_resources.grd
index c48c0f22da36..90955f7af882 100644
--- a/ui/webui/resources/webui_resources.grd
+++ b/ui/webui/resources/webui_resources.grd
@@ -135,12 +135,12 @@ without changes to the corresponding grd file. -->
                use_base_dir="false" type="BINDATA" compress="gzip"
                preprocess="true" />
 
-      <if expr="not is_android">
+      <if expr="is_android or not is_android">
         <part file="cr_components/cr_components_images.grdp" />
         <part file="cr_elements_images.grdp" />
       </if>
 
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <part file="cr_components/cr_components_resources_v3.grdp" />
         <part file="cr_elements_resources_v3.grdp" />
         <part file="cr_polymer_resources_v3.grdp" />
@@ -462,7 +462,7 @@ without changes to the corresponding grd file. -->
                    compress="gzip" />
       </if>
 
-      <if expr="not is_android and not is_ios">
+      <if expr="is_android or not is_android and not is_ios">
         <part file="cr_components/cr_components_resources.grdp" />
         <part file="cr_elements_resources.grdp" />
         <part file="cr_polymer_resources.grdp" />
-- 
2.17.1

